CCS PCM C Compiler, Version 5.115, 43599               09-Jun-24 18:21

               Filename:   E:\STUDY\HKII-2023-2024\DO_AN_1\PROJECT\CODE_FINNAL\main.lst

               ROM used:   4513 words (55%)
                           Largest free fragment is 2048
               RAM used:   91 (25%) at main() level
                           142 (39%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   05A
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   08F
.................... #include <library_project.c>
.................... /*
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
....................                        SU PHAM KY THUAT - TP.HCM
....................  DO AN 1 - HIEU CHINH NHIET DO HO CA VA CHO CA AN TU DONG - KET NOI ESP
.................... 
....................    THANH VIEN:
....................       VO MINH THUAN   - 21161366
....................       LE QUANG THUONG - 21161367
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... */
.................... #include <define_pic16f.c>
.................... //! config mode to operation of pic16f877a
.................... #include <16f877a.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
008C:  DATA F3,39
008D:  DATA BA,37
008E:  DATA 6B,00
*
00C0:  DATA C4,37
00C1:  DATA A0,30
00C2:  DATA 6E,10
00C3:  DATA 31,10
00C4:  DATA 2D,10
00C5:  DATA C8,25
00C6:  DATA C9,24
00C7:  DATA 00,00
00C8:  DATA 53,28
00C9:  DATA 4B,2A
00CA:  DATA 2D,2A
00CB:  DATA 50,24
00CC:  DATA C3,26
00CD:  DATA 00,00
00CE:  DATA 2D,00
00CF:  DATA 2D,00
00D0:  DATA 2E,00
00D1:  DATA 2E,00
00D2:  DATA 4E,22
00D3:  DATA 3A,10
00D4:  DATA 00,01
00D5:  DATA A0,37
00D6:  DATA 43,00
00D7:  DATA 4E,22
00D8:  DATA AD,23
00D9:  DATA 48,1D
00DA:  DATA 20,00
00DB:  DATA A0,37
00DC:  DATA 43,00
00DD:  DATA 20,27
00DE:  DATA 20,00
00DF:  DATA 47,28
00E0:  DATA 47,00
00E1:  DATA 4E,2A
00E2:  DATA 4E,00
00E3:  DATA 20,2A
00E4:  DATA 20,00
00E5:  DATA DF,2F
00E6:  DATA 00,00
00E7:  DATA DF,2F
00E8:  DATA 00,00
00E9:  DATA 64,3A
00EA:  DATA 3A,39
00EB:  DATA 74,1D
00EC:  DATA 00,10
00ED:  DATA 64,3A
00EE:  DATA 3A,36
00EF:  DATA 74,1D
00F0:  DATA 00,01
00F1:  DATA 64,3A
00F2:  DATA 3A,39
00F3:  DATA 61,1D
00F4:  DATA 00,01
00F5:  DATA E3,30
00F6:  DATA 69,10
00F7:  DATA E4,30
00F8:  DATA 74,10
00F9:  DATA E4,37
00FA:  DATA EE,33
00FB:  DATA 20,34
00FC:  DATA 6F,00
00FD:  DATA F4,17
00FE:  DATA 67,10
00FF:  DATA 63,34
0100:  DATA 6F,10
0101:  DATA E3,30
0102:  DATA A0,30
0103:  DATA 6E,00
0104:  DATA 63,34
0105:  DATA E5,31
0106:  DATA 6B,10
0107:  DATA E3,37
0108:  DATA 6D,10
0109:  DATA E5,39
010A:  DATA 70,00
010B:  DATA 49,37
010C:  DATA E6,37
010D:  DATA F2,36
010E:  DATA 61,3A
010F:  DATA E9,37
0110:  DATA 6E,00
0111:  DATA D6,32
0112:  DATA F2,39
0113:  DATA E9,37
0114:  DATA 6E,1D
0115:  DATA 20,2B
0116:  DATA 31,17
0117:  DATA 30,17
0118:  DATA 30,00
0119:  DATA C8,32
011A:  DATA 6C,36
011B:  DATA 6F,10
011C:  DATA 66,39
011D:  DATA EF,36
011E:  DATA 20,28
011F:  DATA C9,21
0120:  DATA 31,1B
0121:  DATA 46,1C
0122:  DATA B7,1B
0123:  DATA C1,10
0124:  DATA 00,00
*
034D:  MOVF   0B,W
034E:  BSF    03.5
034F:  MOVWF  35
0350:  BCF    03.5
0351:  BCF    0B.7
0352:  BSF    03.5
0353:  BSF    03.6
0354:  BSF    0C.7
0355:  BSF    0C.0
0356:  NOP
0357:  NOP
0358:  BCF    03.6
0359:  BTFSS  35.7
035A:  GOTO   35E
035B:  BCF    03.5
035C:  BSF    0B.7
035D:  BSF    03.5
035E:  BCF    03.5
035F:  BSF    03.6
0360:  MOVF   0C,W
0361:  ANDLW  7F
0362:  BTFSC  03.2
0363:  GOTO   3BF
0364:  BSF    03.5
0365:  BCF    03.6
0366:  MOVWF  35
0367:  BCF    03.5
0368:  BSF    03.6
0369:  MOVF   0D,W
036A:  BSF    03.5
036B:  BCF    03.6
036C:  MOVWF  36
036D:  BCF    03.5
036E:  BSF    03.6
036F:  MOVF   0F,W
0370:  BSF    03.5
0371:  BCF    03.6
0372:  MOVWF  37
0373:  MOVF   35,W
0374:  MOVWF  38
0375:  BCF    03.5
0376:  CALL   330
0377:  BSF    03.5
0378:  MOVF   36,W
0379:  BCF    03.5
037A:  BSF    03.6
037B:  MOVWF  0D
037C:  BSF    03.5
037D:  BCF    03.6
037E:  MOVF   37,W
037F:  BCF    03.5
0380:  BSF    03.6
0381:  MOVWF  0F
0382:  BCF    03.6
0383:  MOVF   0B,W
0384:  BSF    03.5
0385:  MOVWF  38
0386:  BCF    03.5
0387:  BCF    0B.7
0388:  BSF    03.5
0389:  BSF    03.6
038A:  BSF    0C.7
038B:  BSF    0C.0
038C:  NOP
038D:  NOP
038E:  BCF    03.6
038F:  BTFSS  38.7
0390:  GOTO   394
0391:  BCF    03.5
0392:  BSF    0B.7
0393:  BSF    03.5
0394:  BCF    03.5
0395:  BSF    03.6
0396:  RLF    0C,W
0397:  RLF    0E,W
0398:  ANDLW  7F
0399:  BTFSC  03.2
039A:  GOTO   3BF
039B:  BSF    03.5
039C:  BCF    03.6
039D:  MOVWF  35
039E:  BCF    03.5
039F:  BSF    03.6
03A0:  MOVF   0D,W
03A1:  BSF    03.5
03A2:  BCF    03.6
03A3:  MOVWF  36
03A4:  BCF    03.5
03A5:  BSF    03.6
03A6:  MOVF   0F,W
03A7:  BSF    03.5
03A8:  BCF    03.6
03A9:  MOVWF  37
03AA:  MOVF   35,W
03AB:  MOVWF  38
03AC:  BCF    03.5
03AD:  CALL   330
03AE:  BSF    03.5
03AF:  MOVF   36,W
03B0:  BCF    03.5
03B1:  BSF    03.6
03B2:  MOVWF  0D
03B3:  BSF    03.5
03B4:  BCF    03.6
03B5:  MOVF   37,W
03B6:  BCF    03.5
03B7:  BSF    03.6
03B8:  MOVWF  0F
03B9:  INCF   0D,F
03BA:  BTFSC  03.2
03BB:  INCF   0F,F
03BC:  BCF    03.6
03BD:  GOTO   34D
03BE:  BSF    03.6
03BF:  BCF    03.6
03C0:  RETURN
*
03E7:  MOVF   0B,W
03E8:  BSF    03.5
03E9:  MOVWF  20
03EA:  BCF    03.5
03EB:  BCF    0B.7
03EC:  BSF    03.5
03ED:  BSF    03.6
03EE:  BSF    0C.7
03EF:  BSF    0C.0
03F0:  NOP
03F1:  NOP
03F2:  BCF    03.6
03F3:  BTFSS  20.7
03F4:  GOTO   3F8
03F5:  BCF    03.5
03F6:  BSF    0B.7
03F7:  BSF    03.5
03F8:  BCF    03.5
03F9:  BSF    03.6
03FA:  MOVF   0C,W
03FB:  ANDLW  7F
03FC:  BTFSC  03.2
03FD:  GOTO   45B
03FE:  BSF    03.5
03FF:  BCF    03.6
0400:  MOVWF  20
0401:  BCF    03.5
0402:  BSF    03.6
0403:  MOVF   0D,W
0404:  BSF    03.5
0405:  BCF    03.6
0406:  MOVWF  21
0407:  BCF    03.5
0408:  BSF    03.6
0409:  MOVF   0F,W
040A:  BSF    03.5
040B:  BCF    03.6
040C:  MOVWF  22
040D:  MOVF   20,W
040E:  BCF    03.5
040F:  BTFSS  0C.4
0410:  GOTO   40F
0411:  MOVWF  19
0412:  BSF    03.5
0413:  MOVF   21,W
0414:  BCF    03.5
0415:  BSF    03.6
0416:  MOVWF  0D
0417:  BSF    03.5
0418:  BCF    03.6
0419:  MOVF   22,W
041A:  BCF    03.5
041B:  BSF    03.6
041C:  MOVWF  0F
041D:  BCF    03.6
041E:  MOVF   0B,W
041F:  BSF    03.5
0420:  MOVWF  23
0421:  BCF    03.5
0422:  BCF    0B.7
0423:  BSF    03.5
0424:  BSF    03.6
0425:  BSF    0C.7
0426:  BSF    0C.0
0427:  NOP
0428:  NOP
0429:  BCF    03.6
042A:  BTFSS  23.7
042B:  GOTO   42F
042C:  BCF    03.5
042D:  BSF    0B.7
042E:  BSF    03.5
042F:  BCF    03.5
0430:  BSF    03.6
0431:  RLF    0C,W
0432:  RLF    0E,W
0433:  ANDLW  7F
0434:  BTFSC  03.2
0435:  GOTO   45B
0436:  BSF    03.5
0437:  BCF    03.6
0438:  MOVWF  20
0439:  BCF    03.5
043A:  BSF    03.6
043B:  MOVF   0D,W
043C:  BSF    03.5
043D:  BCF    03.6
043E:  MOVWF  21
043F:  BCF    03.5
0440:  BSF    03.6
0441:  MOVF   0F,W
0442:  BSF    03.5
0443:  BCF    03.6
0444:  MOVWF  22
0445:  MOVF   20,W
0446:  BCF    03.5
0447:  BTFSS  0C.4
0448:  GOTO   447
0449:  MOVWF  19
044A:  BSF    03.5
044B:  MOVF   21,W
044C:  BCF    03.5
044D:  BSF    03.6
044E:  MOVWF  0D
044F:  BSF    03.5
0450:  BCF    03.6
0451:  MOVF   22,W
0452:  BCF    03.5
0453:  BSF    03.6
0454:  MOVWF  0F
0455:  INCF   0D,F
0456:  BTFSC  03.2
0457:  INCF   0F,F
0458:  BCF    03.6
0459:  GOTO   3E7
045A:  BSF    03.6
045B:  BCF    03.6
045C:  RETURN
045D:  MOVF   7D,W
045E:  ANDLW  07
045F:  MOVWF  77
0460:  RRF    7D,W
0461:  MOVWF  78
0462:  RRF    78,F
0463:  RRF    78,F
0464:  MOVLW  1F
0465:  ANDWF  78,F
0466:  MOVF   78,W
0467:  BSF    03.5
0468:  ADDWF  20,W
0469:  MOVWF  04
046A:  BCF    03.7
046B:  BTFSC  21.0
046C:  BSF    03.7
046D:  MOVF   00,W
046E:  MOVWF  78
046F:  INCF   77,F
0470:  GOTO   472
0471:  RRF    78,F
0472:  DECFSZ 77,F
0473:  GOTO   471
0474:  MOVLW  01
0475:  ANDWF  78,F
0476:  BCF    03.5
0477:  RETURN
*
0507:  CLRF   78
0508:  CLRF   79
0509:  CLRF   77
050A:  CLRF   7A
050B:  BSF    03.5
050C:  MOVF   31,W
050D:  BTFSS  03.2
050E:  GOTO   512
050F:  MOVF   30,W
0510:  BTFSC  03.2
0511:  GOTO   52C
0512:  MOVLW  10
0513:  MOVWF  32
0514:  BCF    03.0
0515:  RLF    2E,F
0516:  RLF    2F,F
0517:  RLF    77,F
0518:  RLF    7A,F
0519:  MOVF   31,W
051A:  SUBWF  7A,W
051B:  BTFSS  03.2
051C:  GOTO   51F
051D:  MOVF   30,W
051E:  SUBWF  77,W
051F:  BTFSS  03.0
0520:  GOTO   528
0521:  MOVF   30,W
0522:  SUBWF  77,F
0523:  BTFSS  03.0
0524:  DECF   7A,F
0525:  MOVF   31,W
0526:  SUBWF  7A,F
0527:  BSF    03.0
0528:  RLF    78,F
0529:  RLF    79,F
052A:  DECFSZ 32,F
052B:  GOTO   514
052C:  BCF    03.5
052D:  RETURN
*
05B7:  MOVLW  10
05B8:  BSF    03.5
05B9:  MOVWF  20
05BA:  CLRF   77
05BB:  CLRF   7A
05BC:  RRF    7C,F
05BD:  RRF    7B,F
05BE:  BTFSS  03.0
05BF:  GOTO   5C6
05C0:  MOVF   7D,W
05C1:  ADDWF  77,F
05C2:  BTFSC  03.0
05C3:  INCF   7A,F
05C4:  MOVF   7E,W
05C5:  ADDWF  7A,F
05C6:  RRF    7A,F
05C7:  RRF    77,F
05C8:  RRF    79,F
05C9:  RRF    78,F
05CA:  DECFSZ 20,F
05CB:  GOTO   5BC
*
05E0:  CLRF   77
05E1:  CLRF   78
05E2:  BSF    03.5
05E3:  MOVF   26,W
05E4:  BCF    03.0
05E5:  BTFSC  27.0
05E6:  ADDWF  77,F
05E7:  RRF    77,F
05E8:  RRF    78,F
05E9:  BTFSC  27.1
05EA:  ADDWF  77,F
05EB:  RRF    77,F
05EC:  RRF    78,F
05ED:  BTFSC  27.2
05EE:  ADDWF  77,F
05EF:  RRF    77,F
05F0:  RRF    78,F
05F1:  BTFSC  27.3
05F2:  ADDWF  77,F
05F3:  RRF    77,F
05F4:  RRF    78,F
05F5:  BTFSC  27.4
05F6:  ADDWF  77,F
05F7:  RRF    77,F
05F8:  RRF    78,F
05F9:  BTFSC  27.5
05FA:  ADDWF  77,F
05FB:  RRF    77,F
05FC:  RRF    78,F
05FD:  BTFSC  27.6
05FE:  ADDWF  77,F
05FF:  RRF    77,F
0600:  RRF    78,F
0601:  BTFSC  27.7
0602:  ADDWF  77,F
0603:  RRF    77,F
0604:  RRF    78,F
0605:  BCF    03.5
0606:  RETURN
*
061C:  BSF    03.5
061D:  MOVF   36,W
061E:  CLRF   78
061F:  SUBWF  35,W
0620:  BTFSC  03.0
0621:  GOTO   625
0622:  MOVF   35,W
0623:  MOVWF  77
0624:  GOTO   631
0625:  CLRF   77
0626:  MOVLW  08
0627:  MOVWF  37
0628:  RLF    35,F
0629:  RLF    77,F
062A:  MOVF   36,W
062B:  SUBWF  77,W
062C:  BTFSC  03.0
062D:  MOVWF  77
062E:  RLF    78,F
062F:  DECFSZ 37,F
0630:  GOTO   628
0631:  BCF    03.5
0632:  RETURN
*
0800:  MOVLW  20
0801:  BSF    03.5
0802:  BTFSS  20.4
0803:  MOVLW  30
0804:  MOVWF  21
0805:  MOVF   7E,W
0806:  MOVWF  77
0807:  BTFSS  7E.7
0808:  GOTO   011
0809:  COMF   77,F
080A:  INCF   77,F
080B:  MOVF   77,W
080C:  MOVWF  7E
080D:  MOVLW  2D
080E:  MOVWF  21
080F:  BSF    20.7
0810:  BSF    20.0
0811:  MOVF   7E,W
0812:  MOVWF  35
0813:  MOVLW  64
0814:  MOVWF  36
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   61C
0818:  BSF    0A.3
0819:  MOVF   77,W
081A:  MOVWF  7E
081B:  MOVLW  30
081C:  ADDWF  78,W
081D:  BSF    03.5
081E:  MOVWF  22
081F:  MOVF   7E,W
0820:  MOVWF  35
0821:  MOVLW  0A
0822:  MOVWF  36
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   61C
0826:  BSF    0A.3
0827:  MOVLW  30
0828:  ADDWF  77,W
0829:  BSF    03.5
082A:  MOVWF  24
082B:  MOVLW  30
082C:  ADDWF  78,W
082D:  MOVWF  23
082E:  MOVF   21,W
082F:  MOVWF  77
0830:  MOVLW  30
0831:  SUBWF  22,W
0832:  BTFSC  03.2
0833:  GOTO   038
0834:  BSF    20.1
0835:  BTFSC  20.7
0836:  BSF    20.2
0837:  GOTO   04C
0838:  MOVF   21,W
0839:  MOVWF  22
083A:  MOVLW  20
083B:  MOVWF  21
083C:  MOVLW  30
083D:  SUBWF  23,W
083E:  BTFSC  03.2
083F:  GOTO   044
0840:  BSF    20.0
0841:  BTFSC  20.7
0842:  BSF    20.1
0843:  GOTO   04C
0844:  BTFSS  03.2
0845:  BSF    20.0
0846:  BTFSS  03.2
0847:  GOTO   04C
0848:  MOVF   22,W
0849:  MOVWF  23
084A:  MOVLW  20
084B:  MOVWF  22
084C:  BTFSC  20.2
084D:  GOTO   053
084E:  BTFSC  20.1
084F:  GOTO   059
0850:  BTFSC  20.0
0851:  GOTO   05F
0852:  GOTO   065
0853:  MOVF   21,W
0854:  BCF    03.5
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
0858:  BSF    03.5
0859:  MOVF   22,W
085A:  BCF    03.5
085B:  BTFSS  0C.4
085C:  GOTO   05B
085D:  MOVWF  19
085E:  BSF    03.5
085F:  MOVF   23,W
0860:  BCF    03.5
0861:  BTFSS  0C.4
0862:  GOTO   061
0863:  MOVWF  19
0864:  BSF    03.5
0865:  MOVF   24,W
0866:  BCF    03.5
0867:  BTFSS  0C.4
0868:  GOTO   067
0869:  MOVWF  19
086A:  RETURN
*
09C5:  MOVF   7B,W
09C6:  XORWF  7C,W
09C7:  ANDLW  80
09C8:  MOVWF  7E
09C9:  BTFSS  7B.7
09CA:  GOTO   1CD
09CB:  COMF   7B,F
09CC:  INCF   7B,F
09CD:  BTFSS  7C.7
09CE:  GOTO   1D1
09CF:  COMF   7C,F
09D0:  INCF   7C,F
09D1:  MOVF   7C,W
09D2:  CLRF   78
09D3:  SUBWF  7B,W
09D4:  BTFSC  03.0
09D5:  GOTO   1D9
09D6:  MOVF   7B,W
09D7:  MOVWF  77
09D8:  GOTO   1E5
09D9:  CLRF   77
09DA:  MOVLW  08
09DB:  MOVWF  7D
09DC:  RLF    7B,F
09DD:  RLF    77,F
09DE:  MOVF   7C,W
09DF:  SUBWF  77,W
09E0:  BTFSC  03.0
09E1:  MOVWF  77
09E2:  RLF    78,F
09E3:  DECFSZ 7D,F
09E4:  GOTO   1DC
09E5:  BTFSS  7E.7
09E6:  GOTO   1E9
09E7:  COMF   78,F
09E8:  INCF   78,F
09E9:  RETURN
.................... 
.................... #list
.................... 
.................... #device  adc=10
.................... #fuses   hs, nowdt, put, noprotect, nolvp
.................... #use     delay(clock=20MHz) 
*
01DA:  MOVLW  7C
01DB:  MOVWF  04
01DC:  BCF    03.7
01DD:  MOVF   00,W
01DE:  BTFSC  03.2
01DF:  GOTO   1ED
01E0:  MOVLW  06
01E1:  MOVWF  78
01E2:  CLRF   77
01E3:  DECFSZ 77,F
01E4:  GOTO   1E3
01E5:  DECFSZ 78,F
01E6:  GOTO   1E2
01E7:  MOVLW  7B
01E8:  MOVWF  77
01E9:  DECFSZ 77,F
01EA:  GOTO   1E9
01EB:  DECFSZ 00,F
01EC:  GOTO   1E0
01ED:  RETURN
*
02E5:  MOVLW  03
02E6:  BSF    03.5
02E7:  SUBWF  21,F
02E8:  BTFSS  03.0
02E9:  GOTO   2F4
02EA:  MOVLW  A1
02EB:  MOVWF  04
02EC:  BCF    03.7
02ED:  MOVF   00,W
02EE:  BTFSC  03.2
02EF:  GOTO   2F4
02F0:  GOTO   2F2
02F1:  GOTO   2F2
02F2:  DECFSZ 00,F
02F3:  GOTO   2F1
02F4:  BCF    03.5
02F5:  RETURN
.................... #use     i2c(master,slow,sda=pin_c4,scl=pin_c3)
*
014E:  BCF    14.7
014F:  BCF    0C.3
0150:  BSF    03.5
0151:  MOVF   48,W
0152:  BCF    03.5
0153:  MOVWF  13
0154:  MOVLW  02
0155:  BTFSC  14.7
0156:  GOTO   15E
0157:  BSF    03.5
0158:  BTFSC  14.2
0159:  GOTO   158
015A:  MOVLW  00
015B:  BTFSC  11.6
015C:  MOVLW  01
015D:  BCF    03.5
015E:  MOVWF  78
015F:  RETURN
0160:  BCF    14.6
0161:  BSF    03.5
0162:  BSF    11.3
0163:  BTFSC  11.3
0164:  GOTO   163
0165:  BTFSC  77.0
0166:  BCF    11.5
0167:  BTFSS  77.0
0168:  BSF    11.5
0169:  BSF    11.4
016A:  BTFSC  11.4
016B:  GOTO   16A
016C:  BCF    03.5
016D:  MOVF   13,W
016E:  MOVWF  78
016F:  RETURN
.................... #use     rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits = 8, stream=UART_STREAM)
.................... #use fast_io(C)
.................... #use fast_io(D)
.................... #use fast_io(E)
.................... #use fast_io(B)
.................... #use fast_io(A)
.................... 
.................... //! define name again to user
.................... #define usi8  unsigned int8
.................... #define usi16 unsigned int16
.................... #define usi32 unsigned int32
.................... #define si8   signed   int8
.................... #define si16  signed   int16
.................... #define si32  signed   int32
.................... #define bool int1
.................... 
.................... //! define variables
.................... bool flag_10ms = false;
.................... bool flag_10s = false;
.................... bool isDs18b20 = false;
.................... 
.................... usi8 limitTemperature = 25;
.................... 
.................... usi16 tick_10ms;
.................... usi16 tick_100ms;
.................... 
.................... usi8 giay_tam, bdn, tt_ht = 0;
.................... si8 gt_mod = 0, tg_chinh = 0;
.................... 
.................... bool e_11, e_22, e_33;
.................... 
.................... usi8 eat_hh, eat_pp, eat_ss;
.................... 
.................... #define maxLevel 6
.................... 
.................... usi8 countLevel = 0;
.................... usi8 countLevelRev = 0;
.................... 
.................... bool flag_servo;
.................... usi8 count_servo = 0;
.................... 
.................... #define tang false
.................... #define giam true
.................... 
.................... //! define available for ds18b20
.................... usi16 temperature;
.................... usi8 dt_ng;
.................... usi16 dt_tp;
.................... usi16 tt;
.................... 
.................... //! define button to use
.................... #ifndef bt0
.................... #define bt0    pin_b0
.................... #endif
.................... 
.................... #ifndef bt1
.................... #define bt1    pin_b1
.................... #endif
.................... 
.................... #ifndef bt2
.................... #define bt2    pin_b2
.................... #endif
.................... 
.................... #ifndef bt3
.................... #define bt3    pin_b3
.................... #endif
.................... 
.................... //! define pin sensors
.................... #define pin_ds18b20 pin_a0
.................... 
.................... //! define pin controls
.................... #ifndef pinServo
.................... #define pinServo    pin_c1
.................... #endif
.................... 
.................... #ifndef pinDLCold
.................... #define pinDLCold     pin_d6
.................... #endif
.................... 
.................... #ifndef pinDLHot
.................... #define pinDLHot      pin_d7
.................... #endif
.................... 
.................... #ifndef ledTest
.................... #define ledTest       pin_b5
.................... #endif
.................... 
.................... #include <library_uart.c>
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
1037:  BCF    03.5
1038:  CLRF   44
1039:  CLRF   45
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... //! define buffer size is 16 byte
.................... #define BUFFER_SIZE 16
.................... 
.................... //! define available for uart buffer
.................... char receivedString[BUFFER_SIZE]="";
103A:  CLRF   46
.................... volatile unsigned int index = 0;
.................... volatile int stringComplete = 0;
.................... volatile unsigned int indexComplete = 0;
.................... 
.................... #int_rda
.................... void read_uart(){
....................    if(kbhit()){
*
005A:  BTFSS  0C.5
005B:  GOTO   086
.................... //!   Read the received character
....................       char receivedChar = getch();  
005C:  BTFSS  0C.5
005D:  GOTO   05C
005E:  MOVF   1A,W
005F:  BSF    03.5
0060:  MOVWF  4B
....................        
....................        if (receivedChar == '\r' || receivedChar == '\n') {
0061:  MOVF   4B,W
0062:  SUBLW  0D
0063:  BTFSC  03.2
0064:  GOTO   069
0065:  MOVF   4B,W
0066:  SUBLW  0A
0067:  BTFSS  03.2
0068:  GOTO   075
.................... //!        End of string (carriage return detected)
....................            receivedString[index] = '\0';  // Null-terminate the string
0069:  MOVLW  46
006A:  BCF    03.5
006B:  ADDWF  56,W
006C:  MOVWF  04
006D:  BCF    03.7
006E:  CLRF   00
....................            indexComplete = index;
006F:  MOVF   56,W
0070:  MOVWF  58
....................            stringComplete = 1;  // Set the flag to indicate string reception complete
0071:  MOVLW  01
0072:  MOVWF  57
....................        } else {
0073:  GOTO   086
0074:  BSF    03.5
....................           // Store the received character
....................            if (index < BUFFER_SIZE - 1) {
0075:  BCF    03.5
0076:  MOVF   56,W
0077:  SUBLW  0E
0078:  BTFSS  03.0
0079:  GOTO   084
....................                receivedString[index++] = receivedChar;
007A:  MOVF   56,W
007B:  INCF   56,F
007C:  ADDLW  46
007D:  MOVWF  04
007E:  BCF    03.7
007F:  BSF    03.5
0080:  MOVF   4B,W
0081:  MOVWF  00
....................            } else {
0082:  GOTO   087
0083:  BCF    03.5
....................                // Handle buffer overflow
....................                index = BUFFER_SIZE - 1;  // Prevent overflow
0084:  MOVLW  0F
0085:  MOVWF  56
0086:  BSF    03.5
....................            }
....................        }
....................    }
0087:  BCF    03.5
0088:  BCF    0C.5
0089:  BCF    0A.3
008A:  BCF    0A.4
008B:  GOTO   033
.................... }
.................... 
.................... usi8 decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
*
07BB:  MOVF   7D,W
07BC:  BSF    03.5
07BD:  MOVWF  35
07BE:  MOVLW  0A
07BF:  MOVWF  36
07C0:  BCF    03.5
07C1:  CALL   61C
07C2:  SWAPF  78,W
07C3:  MOVWF  7E
07C4:  MOVLW  F0
07C5:  ANDWF  7E,F
07C6:  MOVF   7D,W
07C7:  BSF    03.5
07C8:  MOVWF  35
07C9:  MOVLW  0A
07CA:  MOVWF  36
07CB:  BCF    03.5
07CC:  CALL   61C
07CD:  MOVF   77,W
07CE:  ADDWF  7E,W
07CF:  MOVWF  78
07D0:  RETURN
.................... }
.................... 
.................... void send_ok(){
....................    printf("ss:ok");
*
07B3:  MOVLW  8C
07B4:  BSF    03.6
07B5:  MOVWF  0D
07B6:  MOVLW  00
07B7:  MOVWF  0F
07B8:  BCF    03.6
07B9:  CALL   3E7
07BA:  RETURN
.................... }
.................... 
.................... void handle_uart(){
....................    if (stringComplete) {
*
1191:  MOVF   57,F
1192:  BTFSC  03.2
1193:  GOTO   226
....................       stringComplete = 0;
1194:  CLRF   57
....................       index = 0;
1195:  CLRF   56
....................       indexComplete = 0;
1196:  CLRF   58
....................       if(receivedString[0] == 's' && receivedString[1] == 't' && receivedString[2] == ':'){
1197:  MOVF   46,W
1198:  SUBLW  73
1199:  BTFSS  03.2
119A:  GOTO   1B6
119B:  MOVF   47,W
119C:  SUBLW  74
119D:  BTFSS  03.2
119E:  GOTO   1B6
119F:  MOVF   48,W
11A0:  SUBLW  3A
11A1:  BTFSS  03.2
11A2:  GOTO   1B6
.................... //!      Header for changing temperature found
.................... //!      frame "st:23"
....................          limitTemperature = ((receivedString[3] - '0') * 10) + (receivedString[4] - '0');
11A3:  MOVLW  30
11A4:  SUBWF  49,W
11A5:  MOVWF  7C
11A6:  BSF    03.5
11A7:  MOVWF  26
11A8:  MOVLW  0A
11A9:  MOVWF  27
11AA:  BCF    0A.4
11AB:  BCF    03.5
11AC:  CALL   5E0
11AD:  BSF    0A.4
11AE:  MOVLW  30
11AF:  SUBWF  4A,W
11B0:  ADDWF  78,W
11B1:  MOVWF  2D
....................          send_ok();
11B2:  BCF    0A.4
11B3:  CALL   7B3
11B4:  BSF    0A.4
....................       }
11B5:  GOTO   226
....................       else if(receivedString[0] == 's' && receivedString[1] == 'a' && receivedString[2] == ':'){
11B6:  MOVF   46,W
11B7:  SUBLW  73
11B8:  BTFSS  03.2
11B9:  GOTO   211
11BA:  MOVF   47,W
11BB:  SUBLW  61
11BC:  BTFSS  03.2
11BD:  GOTO   211
11BE:  MOVF   48,W
11BF:  SUBLW  3A
11C0:  BTFSS  03.2
11C1:  GOTO   211
.................... //!      Header for changing alarm settings found
.................... //!      frame "sa:gpg:11-11-11"
....................          if(receivedString[3] == 'g' && receivedString[4] == 'p' && receivedString[5] == 'g'){
11C2:  MOVF   49,W
11C3:  SUBLW  67
11C4:  BTFSS  03.2
11C5:  GOTO   210
11C6:  MOVF   4A,W
11C7:  SUBLW  70
11C8:  BTFSS  03.2
11C9:  GOTO   210
11CA:  MOVF   4B,W
11CB:  SUBLW  67
11CC:  BTFSS  03.2
11CD:  GOTO   210
....................             // Address for changing gpg alarm settings found
....................             eat_hh = decToBcd((receivedString[7] - '0') * 10) + (receivedString[8] - '0');
11CE:  MOVLW  30
11CF:  SUBWF  4D,W
11D0:  MOVWF  7C
11D1:  BSF    03.5
11D2:  MOVWF  26
11D3:  MOVLW  0A
11D4:  MOVWF  27
11D5:  BCF    0A.4
11D6:  BCF    03.5
11D7:  CALL   5E0
11D8:  BSF    0A.4
11D9:  MOVF   78,W
11DA:  MOVWF  7B
11DB:  MOVWF  7D
11DC:  BCF    0A.4
11DD:  CALL   7BB
11DE:  BSF    0A.4
11DF:  MOVLW  30
11E0:  SUBWF  4E,W
11E1:  ADDWF  78,W
11E2:  MOVWF  37
....................             eat_pp = decToBcd((receivedString[10] - '0') * 10) + (receivedString[11] - '0');
11E3:  MOVLW  30
11E4:  SUBWF  50,W
11E5:  MOVWF  7C
11E6:  BSF    03.5
11E7:  MOVWF  26
11E8:  MOVLW  0A
11E9:  MOVWF  27
11EA:  BCF    0A.4
11EB:  BCF    03.5
11EC:  CALL   5E0
11ED:  BSF    0A.4
11EE:  MOVF   78,W
11EF:  MOVWF  7B
11F0:  MOVWF  7D
11F1:  BCF    0A.4
11F2:  CALL   7BB
11F3:  BSF    0A.4
11F4:  MOVLW  30
11F5:  SUBWF  51,W
11F6:  ADDWF  78,W
11F7:  MOVWF  38
....................             eat_ss = decToBcd((receivedString[13] - '0') * 10) + (receivedString[14] - '0');
11F8:  MOVLW  30
11F9:  SUBWF  53,W
11FA:  MOVWF  7C
11FB:  BSF    03.5
11FC:  MOVWF  26
11FD:  MOVLW  0A
11FE:  MOVWF  27
11FF:  BCF    0A.4
1200:  BCF    03.5
1201:  CALL   5E0
1202:  BSF    0A.4
1203:  MOVF   78,W
1204:  MOVWF  7B
1205:  MOVWF  7D
1206:  BCF    0A.4
1207:  CALL   7BB
1208:  BSF    0A.4
1209:  MOVLW  30
120A:  SUBWF  54,W
120B:  ADDWF  78,W
120C:  MOVWF  39
....................             send_ok();
120D:  BCF    0A.4
120E:  CALL   7B3
120F:  BSF    0A.4
....................          }
....................       }
1210:  GOTO   226
....................       else if(receivedString[0] == 'c' && receivedString[1] == 's' && receivedString[2] == ':'){
1211:  MOVF   46,W
1212:  SUBLW  63
1213:  BTFSS  03.2
1214:  GOTO   226
1215:  MOVF   47,W
1216:  SUBLW  73
1217:  BTFSS  03.2
1218:  GOTO   226
1219:  MOVF   48,W
121A:  SUBLW  3A
121B:  BTFSS  03.2
121C:  GOTO   226
.................... //!      Header for controling servo manual
.................... //!      frame "cs:1" -> servo on    
.................... //!      frame "cs:0" -> servo off
....................          flag_servo = receivedString[3] - '0';
121D:  MOVLW  30
121E:  SUBWF  49,W
121F:  MOVWF  78
1220:  BCF    2C.6
1221:  BTFSC  78.0
1222:  BSF    2C.6
....................          send_ok();
1223:  BCF    0A.4
1224:  CALL   7B3
1225:  BSF    0A.4
....................       }
....................    }  
.................... }
.................... 
.................... 
.................... 
.................... #int_timer1
.................... void interrupt_timer1()
.................... {
....................    set_timer1(59286);
*
008F:  CLRF   0E
0090:  MOVLW  E7
0091:  MOVWF  0F
0092:  MOVLW  96
0093:  MOVWF  0E
0094:  NOP
....................    
....................    flag_10ms = !flag_10ms;
0095:  MOVLW  01
0096:  XORWF  2C,F
.................... 
....................    tick_10ms++;
0097:  INCF   2E,F
0098:  BTFSC  03.2
0099:  INCF   2F,F
.................... 
.................... //! when tick_10ms >= 10 --> 100ms
....................    if(tick_10ms >= 10){
009A:  MOVF   2F,F
009B:  BTFSS  03.2
009C:  GOTO   0A1
009D:  MOVF   2E,W
009E:  SUBLW  09
009F:  BTFSC  03.0
00A0:  GOTO   0BC
....................       bdn++;
00A1:  INCF   33,F
....................       tick_10ms = 0;
00A2:  CLRF   2F
00A3:  CLRF   2E
....................       
....................       if(tick_100ms < 100) tick_100ms++;
00A4:  MOVF   31,F
00A5:  BTFSS  03.2
00A6:  GOTO   0AF
00A7:  MOVF   30,W
00A8:  SUBLW  63
00A9:  BTFSS  03.0
00AA:  GOTO   0AF
00AB:  INCF   30,F
00AC:  BTFSC  03.2
00AD:  INCF   31,F
00AE:  GOTO   0B2
....................       else{
....................          tick_100ms = 0;
00AF:  CLRF   31
00B0:  CLRF   30
....................          flag_10s = true;
00B1:  BSF    2C.1
....................       }
....................       
.................... //! disable flag servo on --> flag_servo >> false
....................       if(flag_servo == true){
00B2:  BTFSS  2C.6
00B3:  GOTO   0BC
....................          if(count_servo < 100) count_servo++; // 10s
00B4:  MOVF   3C,W
00B5:  SUBLW  63
00B6:  BTFSS  03.0
00B7:  GOTO   0BA
00B8:  INCF   3C,F
00B9:  GOTO   0BC
....................          else{
....................             count_servo = 0;
00BA:  CLRF   3C
....................             flag_servo = false;
00BB:  BCF    2C.6
....................          }
....................       }
....................    }
00BC:  BCF    0C.0
00BD:  BCF    0A.3
00BE:  BCF    0A.4
00BF:  GOTO   033
.................... }
.................... 
.................... void setup_initialize(){
.................... //! set up timer 1 to timer count is 10ms of one cycle
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);
*
0125:  MOVLW  B5
0126:  MOVWF  10
....................    set_timer1(59286);
0127:  CLRF   0E
0128:  MOVLW  E7
0129:  MOVWF  0F
012A:  MOVLW  96
012B:  MOVWF  0E
012C:  NOP
.................... 
.................... //! enable interrupt timer 1 and read data uart
....................    enable_interrupts(global);
012D:  MOVLW  C0
012E:  IORWF  0B,F
....................    enable_interrupts(int_timer1);
012F:  BSF    03.5
0130:  BSF    0C.0
....................    enable_interrupts(int_rda);
0131:  BSF    0C.5
.................... 
.................... 
.................... //! setup mode for all gpio of pic16f877a
....................    set_tris_a(0xff);
0132:  MOVLW  FF
0133:  MOVWF  05
....................    set_tris_b(0xdf);
0134:  MOVLW  DF
0135:  MOVWF  06
....................    set_tris_d(0x00); //output_d(0x00);
0136:  MOVLW  00
0137:  MOVWF  08
....................    set_tris_e(0x00); //output_e(0x00);
0138:  BCF    09.0
0139:  BCF    09.1
013A:  BCF    09.2
....................    set_tris_c(0x98); //output_c(0x98);
013B:  MOVLW  98
013C:  MOVWF  07
....................  
.................... //! setup variable initialize
....................    flag_10ms = false;
013D:  BCF    03.5
013E:  BCF    2C.0
....................    flag_10s  = false;
013F:  BCF    2C.1
....................    isDs18b20 = false;
0140:  BCF    2C.2
....................    
....................    limitTemperature = 25;
0141:  MOVLW  19
0142:  MOVWF  2D
....................    
....................    e_11 = true; e_22 = true; e_33 = true;
0143:  BSF    2C.3
0144:  BSF    2C.4
0145:  BSF    2C.5
....................    
....................    eat_hh = 0x09; eat_pp = 0x30; eat_ss = 0x30;
0146:  MOVLW  09
0147:  MOVWF  37
0148:  MOVLW  30
0149:  MOVWF  38
014A:  MOVWF  39
014B:  BCF    0A.3
014C:  BSF    0A.4
014D:  GOTO   05F (RETURN)
.................... }
.................... 
.................... #include <library_button.c>
.................... //! button place
.................... //! bt3 - bt2 - bt1 - bt0
.................... 
.................... usi8 countPush = 0;
.................... usi8 countTick = 0;
.................... 
.................... bool push_btn(bool isRelease, usi8 pin){
.................... //! isRelease == 0 --> push button is hold
.................... //! isRelease == 1 --> push button is release
....................    if(!input(pin)){
*
1078:  MOVF   7B,W
1079:  MOVWF  7D
107A:  BSF    03.5
107B:  CLRF   21
107C:  CLRF   20
107D:  BCF    0A.4
107E:  BCF    03.5
107F:  CALL   45D
1080:  BSF    0A.4
1081:  BTFSC  78.0
1082:  GOTO   0AD
....................       if(flag_10ms == true) countPush++;
1083:  BTFSS  2C.0
1084:  GOTO   086
1085:  INCF   5B,F
.................... //! check if countPush == 2 (20ms) --> debound button
....................       if(countPush >= 1){
1086:  MOVF   5B,W
1087:  SUBLW  00
1088:  BTFSC  03.0
1089:  GOTO   0AA
....................          if(!input(pin)){
108A:  MOVF   7B,W
108B:  MOVWF  7D
108C:  BSF    03.5
108D:  CLRF   21
108E:  CLRF   20
108F:  BCF    0A.4
1090:  BCF    03.5
1091:  CALL   45D
1092:  BSF    0A.4
1093:  BTFSC  78.0
1094:  GOTO   0A7
....................             if(isRelease == false) while(!input(pin));
1095:  MOVF   76,F
1096:  BTFSS  03.2
1097:  GOTO   0A3
1098:  MOVF   7B,W
1099:  MOVWF  7D
109A:  BSF    03.5
109B:  CLRF   21
109C:  CLRF   20
109D:  BCF    0A.4
109E:  BCF    03.5
109F:  CALL   45D
10A0:  BSF    0A.4
10A1:  BTFSS  78.0
10A2:  GOTO   098
....................             countPush = 0;
10A3:  CLRF   5B
....................             return true;
10A4:  MOVLW  01
10A5:  MOVWF  78
10A6:  GOTO   0AF
....................          }
....................          return false;
10A7:  MOVLW  00
10A8:  MOVWF  78
10A9:  GOTO   0AF
....................       }
....................       return false;
10AA:  MOVLW  00
10AB:  MOVWF  78
10AC:  GOTO   0AF
....................    }
.................... //!   countPush = 0;
....................    return false;
10AD:  MOVLW  00
10AE:  MOVWF  78
.................... }
.................... 
.................... bool tick_btn(usi8 delay, usi8 pin){
.................... //! dl is time delay that compute with 10ms for dl is 1
....................    if(!input(pin)){
*
07D1:  MOVF   7B,W
07D2:  MOVWF  7D
07D3:  BSF    03.5
07D4:  CLRF   21
07D5:  CLRF   20
07D6:  BCF    03.5
07D7:  CALL   45D
07D8:  BTFSC  78.0
07D9:  GOTO   7E7
....................       if(flag_10ms == true) countTick++;
07DA:  BTFSC  2C.0
07DB:  INCF   5C,F
.................... //! check if countTick >= delay (delay * 10ms) --> time delay wanna to tick rising signal
....................       if(countTick >= delay){
07DC:  MOVF   76,W
07DD:  SUBWF  5C,W
07DE:  BTFSS  03.0
07DF:  GOTO   7E4
....................          countTick = 0;
07E0:  CLRF   5C
....................          return true;
07E1:  MOVLW  01
07E2:  MOVWF  78
07E3:  GOTO   7E9
....................       }
....................       return false;
07E4:  MOVLW  00
07E5:  MOVWF  78
07E6:  GOTO   7E9
....................    }
.................... //!   countTick = 0;
....................    return false;
07E7:  MOVLW  00
07E8:  MOVWF  78
07E9:  RETURN
.................... }
.................... 
.................... #include <library_i2c.c>
.................... #define pcf8574_addr_wr 0x4E // 0b01001110
.................... #define pcf8574_addr_rd 0x4F // 0b01001111
.................... 
.................... //! i2c reset
.................... void i2c_reset()
.................... {
....................    i2c_start();
....................    i2c_stop();
.................... }
.................... 
.................... //! i2c setup write for pcf8574
.................... void i2c_setup_write()
.................... {
....................    i2c_start();
*
0275:  BSF    03.5
0276:  BSF    11.0
0277:  BTFSC  11.0
0278:  GOTO   277
....................    i2c_write(pcf8574_addr_wr);
0279:  MOVLW  4E
027A:  MOVWF  48
027B:  BCF    03.5
027C:  CALL   14E
.................... }
.................... 
.................... //! i2c write 1byte for pcf8574
.................... void i2c_write_1byte(usi8 payload)
.................... {
....................    i2c_start();
*
01F8:  BSF    11.1
01F9:  BTFSC  11.1
01FA:  GOTO   1F9
*
0216:  BSF    11.1
0217:  BTFSC  11.1
0218:  GOTO   217
*
0235:  BSF    11.1
0236:  BTFSC  11.1
0237:  GOTO   236
*
028E:  BSF    11.1
028F:  BTFSC  11.1
0290:  GOTO   28F
....................    i2c_write(pcf8574_addr_wr);
*
01FB:  MOVLW  4E
01FC:  MOVWF  48
01FD:  BCF    03.5
01FE:  CALL   14E
*
0219:  MOVLW  4E
021A:  MOVWF  48
021B:  BCF    03.5
021C:  CALL   14E
*
0238:  MOVLW  4E
0239:  MOVWF  48
023A:  BCF    03.5
023B:  CALL   14E
*
0291:  MOVLW  4E
0292:  MOVWF  48
0293:  BCF    03.5
0294:  CALL   14E
....................    i2c_write(payload);
*
01FF:  BSF    03.5
0200:  MOVF   47,W
0201:  MOVWF  48
0202:  BCF    03.5
0203:  CALL   14E
*
021D:  BSF    03.5
021E:  MOVF   47,W
021F:  MOVWF  48
0220:  BCF    03.5
0221:  CALL   14E
*
023C:  BSF    03.5
023D:  MOVF   47,W
023E:  MOVWF  48
023F:  BCF    03.5
0240:  CALL   14E
*
0295:  BSF    03.5
0296:  MOVF   47,W
0297:  MOVWF  48
0298:  BCF    03.5
0299:  CALL   14E
....................    i2c_stop();
*
0204:  BSF    03.5
0205:  BSF    11.2
0206:  BTFSC  11.2
0207:  GOTO   206
*
0222:  BSF    03.5
0223:  BSF    11.2
0224:  BTFSC  11.2
0225:  GOTO   224
*
0241:  BSF    03.5
0242:  BSF    11.2
0243:  BTFSC  11.2
0244:  GOTO   243
*
029A:  BSF    03.5
029B:  BSF    11.2
029C:  BTFSC  11.2
029D:  GOTO   29C
.................... }
.................... 
.................... 
.................... #include <library_lcd_i2c.c>
.................... #define lcd_cols 16
.................... #define lcd_rows 2
.................... 
.................... // commands
.................... #define LCD_CLEARDISPLAY 0x01
.................... #define LCD_RETURNHOME 0x02
.................... #define LCD_ENTRYMODESET 0x04
.................... #define LCD_DISPLAYCONTROL 0x08
.................... #define LCD_CURSORSHIFT 0x10
.................... #define LCD_FUNCTIONSET 0x20
.................... #define LCD_SETCGRAMADDR 0x40
.................... #define LCD_SETDDRAMADDR 0x80
.................... 
.................... // flags for display entry mode
.................... #define LCD_ENTRYRIGHT 0x00
.................... #define LCD_ENTRYLEFT 0x02
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00
.................... 
.................... // flags for display on/off control
.................... #define LCD_DISPLAYON 0x04
.................... #define LCD_DISPLAYOFF 0x00
.................... #define LCD_CURSORON 0x02
.................... #define LCD_CURSOROFF 0x00
.................... #define LCD_BLINKON 0x01
.................... #define LCD_BLINKOFF 0x00
.................... 
.................... // flags for display/cursor shift
.................... #define LCD_DISPLAYMOVE 0x08
.................... #define LCD_CURSORMOVE 0x00
.................... #define LCD_MOVERIGHT 0x04
.................... #define LCD_MOVELEFT 0x00
.................... 
.................... // flags for function set
.................... #define LCD_8BITMODE 0x10
.................... #define LCD_4BITMODE 0x00
.................... #define LCD_2LINE 0x08
.................... #define LCD_1LINE 0x00
.................... #define LCD_5x10DOTS 0x04
.................... #define LCD_5x8DOTS 0x00
.................... 
.................... // flags for backlight control
.................... #define LCD_BACKLIGHT 0x08
.................... #define LCD_NOBACKLIGHT 0x00
.................... 
.................... #define En 0B00000100  // Enable bit
.................... #define Rw 0B00000010  // Read/Write bit
.................... #define Rs 0B00000001  // Register select bit
.................... 
.................... void write4bits(usi8 value);
.................... void expanderWrite(usi8 _data);
.................... void pulseEnable(usi8 _data);
.................... void lcd_command(usi8 value);
.................... void lcd_display();
.................... void lcd_clear();
.................... void lcd_home();
.................... void lcd_send(usi8 value, usi8 mode);
.................... void lcd_data(usi8 value);
.................... 
.................... usi8 _displayfunction;
.................... usi8 _displaycontrol;
.................... usi8 _displaymode;
.................... usi8 _numlines;
.................... usi8 _cols;
.................... usi8 _rows;
.................... usi8 _backlightval;
.................... 
.................... void lcd_setup(){
....................    _cols = lcd_cols; // 16
*
0270:  MOVLW  10
0271:  MOVWF  61
....................    _rows = lcd_rows; // 2
0272:  MOVLW  02
0273:  MOVWF  62
....................    _backlightval = LCD_NOBACKLIGHT; // back light is off
0274:  CLRF   63
....................    
....................    i2c_setup_write(); // setup i2c
....................    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
*
027D:  CLRF   5D
....................    
....................    _displayfunction |= LCD_2LINE;
027E:  BSF    5D.3
....................    _numlines = _rows; // 2
027F:  MOVF   62,W
0280:  MOVWF  60
....................    
....................    delay_ms(40);
0281:  MOVLW  28
0282:  MOVWF  7C
0283:  CALL   1DA
....................    
....................    expanderWrite(_backlightval); // back light is on
0284:  MOVF   63,W
0285:  BSF    03.5
0286:  MOVWF  45
....................    delay_ms(100);
*
029E:  MOVLW  64
029F:  MOVWF  7C
02A0:  BCF    03.5
02A1:  CALL   1DA
....................    
....................    //It is try to set use 4bit in 3 time
....................    write4bits(0x03 << 4);
02A2:  MOVLW  30
02A3:  BSF    03.5
02A4:  MOVWF  42
02A5:  BCF    03.5
02A6:  CALL   1EE
....................    delay_ms(5);
02A7:  MOVLW  05
02A8:  MOVWF  7C
02A9:  CALL   1DA
....................    
....................    write4bits(0x03 << 4);
02AA:  MOVLW  30
02AB:  BSF    03.5
02AC:  MOVWF  42
02AD:  BCF    03.5
02AE:  CALL   1EE
....................    delay_ms(5);
02AF:  MOVLW  05
02B0:  MOVWF  7C
02B1:  CALL   1DA
....................    
....................    write4bits(0x03 << 4);
02B2:  MOVLW  30
02B3:  BSF    03.5
02B4:  MOVWF  42
02B5:  BCF    03.5
02B6:  CALL   1EE
....................    delay_ms(5);
02B7:  MOVLW  05
02B8:  MOVWF  7C
02B9:  CALL   1DA
....................    
....................    write4bits(0x02 << 4); // set using 4bit for lcd16x2
02BA:  MOVLW  20
02BB:  BSF    03.5
02BC:  MOVWF  42
02BD:  BCF    03.5
02BE:  CALL   1EE
....................    
....................    lcd_command(LCD_FUNCTIONSET | _displayfunction);
02BF:  MOVF   5D,W
02C0:  IORLW  20
02C1:  MOVWF  76
02C2:  BSF    03.5
02C3:  MOVWF  3C
02C4:  BCF    03.5
02C5:  CALL   24B
....................    
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
02C6:  MOVLW  04
02C7:  MOVWF  5E
....................    lcd_display();
....................    
....................    lcd_clear();
*
02D0:  CALL   267
....................    
....................    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
02D1:  MOVLW  02
02D2:  MOVWF  5F
....................    lcd_command(LCD_ENTRYMODESET | _displaymode);
02D3:  MOVF   5F,W
02D4:  IORLW  04
02D5:  MOVWF  76
02D6:  BSF    03.5
02D7:  MOVWF  3C
02D8:  BCF    03.5
02D9:  CALL   24B
....................    
....................    lcd_home();
*
02E2:  BCF    0A.3
02E3:  BSF    0A.4
02E4:  GOTO   065 (RETURN)
.................... }
.................... 
.................... void lcd_clear(){
....................    lcd_command(LCD_CLEARDISPLAY);
*
0267:  MOVLW  01
0268:  BSF    03.5
0269:  MOVWF  3C
026A:  BCF    03.5
026B:  CALL   24B
....................    delay_ms(20);
026C:  MOVLW  14
026D:  MOVWF  7C
026E:  CALL   1DA
026F:  RETURN
.................... }
.................... 
.................... void lcd_home(){
....................    lcd_command(LCD_RETURNHOME);
*
02DA:  MOVLW  02
02DB:  BSF    03.5
02DC:  MOVWF  3C
02DD:  BCF    03.5
02DE:  CALL   24B
....................    delay_ms(20);
02DF:  MOVLW  14
02E0:  MOVWF  7C
02E1:  CALL   1DA
.................... }
.................... 
.................... void lcd_setCursor(usi8 col, usi8 row){
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
*
0311:  BSF    03.5
0312:  CLRF   37
0313:  MOVLW  40
0314:  MOVWF  38
0315:  MOVLW  14
0316:  MOVWF  39
0317:  MOVLW  54
0318:  MOVWF  3A
....................    if ( row > _numlines ) {
0319:  MOVF   36,W
031A:  BCF    03.5
031B:  SUBWF  60,W
031C:  BTFSC  03.0
031D:  GOTO   323
....................       row = _numlines-1;
031E:  MOVLW  01
031F:  SUBWF  60,W
0320:  BSF    03.5
0321:  MOVWF  36
0322:  BCF    03.5
....................    }
....................    lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
0323:  MOVLW  B7
0324:  BSF    03.5
0325:  ADDWF  36,W
0326:  MOVWF  04
0327:  BCF    03.7
0328:  MOVF   00,W
0329:  ADDWF  35,W
032A:  IORLW  80
032B:  MOVWF  3B
032C:  MOVWF  3C
032D:  BCF    03.5
032E:  CALL   24B
032F:  RETURN
.................... }
.................... 
.................... void lcd_display() {
....................    _displaycontrol |= LCD_DISPLAYON;
*
02C8:  BSF    5E.2
....................    lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
02C9:  MOVF   5E,W
02CA:  IORLW  08
02CB:  MOVWF  76
02CC:  BSF    03.5
02CD:  MOVWF  3C
02CE:  BCF    03.5
02CF:  CALL   24B
.................... }
.................... 
.................... void lcd_command(usi8 value){
....................    lcd_send(value,0);
*
024B:  BSF    03.5
024C:  MOVF   3C,W
024D:  MOVWF  3D
024E:  CLRF   3E
*
0266:  RETURN
.................... }
.................... 
.................... void lcd_data(usi8 value){
....................    lcd_send(value,Rs);
*
0330:  BSF    03.5
0331:  MOVF   38,W
0332:  MOVWF  3D
0333:  MOVLW  01
0334:  MOVWF  3E
*
034C:  RETURN
.................... }
.................... 
.................... void lcd_send(usi8 value, usi8 mode) {
*
024F:  MOVF   3D,W
0250:  ANDLW  F0
0251:  MOVWF  3F
0252:  SWAPF  3D,W
0253:  MOVWF  77
0254:  MOVLW  F0
0255:  ANDWF  77,F
0256:  MOVF   77,W
0257:  ANDLW  F0
0258:  MOVWF  40
*
0335:  MOVF   3D,W
0336:  ANDLW  F0
0337:  MOVWF  3F
0338:  SWAPF  3D,W
0339:  MOVWF  77
033A:  MOVLW  F0
033B:  ANDWF  77,F
033C:  MOVF   77,W
033D:  ANDLW  F0
033E:  MOVWF  40
....................    usi8 highnib=value&0xf0;
....................    usi8 lownib=(value<<4)&0xf0;
....................    write4bits((highnib)|mode);
*
0259:  MOVF   3F,W
025A:  IORWF  3E,W
025B:  MOVWF  41
025C:  MOVWF  42
025D:  BCF    03.5
025E:  CALL   1EE
*
033F:  MOVF   3F,W
0340:  IORWF  3E,W
0341:  MOVWF  41
0342:  MOVWF  42
0343:  BCF    03.5
0344:  CALL   1EE
....................    write4bits((lownib)|mode); 
*
025F:  BSF    03.5
0260:  MOVF   40,W
0261:  IORWF  3E,W
0262:  MOVWF  41
0263:  MOVWF  42
0264:  BCF    03.5
0265:  CALL   1EE
*
0345:  BSF    03.5
0346:  MOVF   40,W
0347:  IORWF  3E,W
0348:  MOVWF  41
0349:  MOVWF  42
034A:  BCF    03.5
034B:  CALL   1EE
.................... }
.................... 
.................... void write4bits(usi8 value) {
....................    expanderWrite(value);
*
01EE:  BSF    03.5
01EF:  MOVF   42,W
01F0:  MOVWF  45
....................    pulseEnable(value);
*
0208:  MOVF   42,W
0209:  MOVWF  43
*
0249:  BCF    03.5
024A:  RETURN
.................... }
.................... 
.................... void expanderWrite(usi8 _data){
....................    i2c_write_1byte(_data|_backlightval);
*
01F1:  MOVF   45,W
01F2:  BCF    03.5
01F3:  IORWF  63,W
01F4:  BSF    03.5
01F5:  MOVWF  46
01F6:  MOVF   46,W
01F7:  MOVWF  47
*
020F:  MOVF   45,W
0210:  BCF    03.5
0211:  IORWF  63,W
0212:  BSF    03.5
0213:  MOVWF  46
0214:  MOVF   46,W
0215:  MOVWF  47
*
022E:  MOVF   45,W
022F:  BCF    03.5
0230:  IORWF  63,W
0231:  BSF    03.5
0232:  MOVWF  46
0233:  MOVF   46,W
0234:  MOVWF  47
*
0287:  MOVF   45,W
0288:  BCF    03.5
0289:  IORWF  63,W
028A:  BSF    03.5
028B:  MOVWF  46
028C:  MOVF   46,W
028D:  MOVWF  47
.................... }
.................... 
.................... void pulseEnable(usi8 _data){
....................    expanderWrite(_data | En);
*
020A:  MOVF   43,W
020B:  IORLW  04
020C:  MOVWF  44
020D:  MOVF   44,W
020E:  MOVWF  45
....................    delay_us(1);
*
0226:  GOTO   227
0227:  GOTO   228
0228:  NOP
....................    expanderWrite(_data & ~En);
0229:  MOVF   43,W
022A:  ANDLW  FB
022B:  MOVWF  44
022C:  MOVF   44,W
022D:  MOVWF  45
....................    delay_us(50);
*
0245:  MOVLW  53
0246:  MOVWF  77
0247:  DECFSZ 77,F
0248:  GOTO   247
.................... }
.................... 
.................... void log_lcd_initialize(){
....................    lcd_setCursor(1,0);
*
03C1:  MOVLW  01
03C2:  BSF    03.5
03C3:  MOVWF  35
03C4:  CLRF   36
03C5:  BCF    03.5
03C6:  CALL   311
....................    lcd_data("Do an 1 - HKII");
03C7:  MOVLW  C0
03C8:  BSF    03.6
03C9:  MOVWF  0D
03CA:  MOVLW  00
03CB:  MOVWF  0F
03CC:  BCF    03.6
03CD:  CALL   34D
....................    lcd_setCursor(3,1);
03CE:  MOVLW  03
03CF:  BSF    03.5
03D0:  MOVWF  35
03D1:  MOVLW  01
03D2:  MOVWF  36
03D3:  BCF    03.5
03D4:  CALL   311
....................    lcd_data("SPKT-TPHCM");
03D5:  MOVLW  C8
03D6:  BSF    03.6
03D7:  MOVWF  0D
03D8:  MOVLW  00
03D9:  MOVWF  0F
03DA:  BCF    03.6
03DB:  CALL   34D
....................    delay_ms(2000);
03DC:  MOVLW  08
03DD:  MOVWF  76
03DE:  MOVLW  FA
03DF:  MOVWF  7C
03E0:  CALL   1DA
03E1:  DECFSZ 76,F
03E2:  GOTO   3DE
....................    lcd_clear();
03E3:  CALL   267
03E4:  BCF    0A.3
03E5:  BSF    0A.4
03E6:  GOTO   06B (RETURN)
.................... }
.................... 
.................... void lcd_dis_xx_yy_zz(usi8 x, usi8 y, usi8 a, usi8 b, usi8 c, bool e3, bool e2, bool e1){
....................    usi8 a_ch, a_dv, b_ch, b_dv, c_ch, c_dv;
....................    a_ch = e3 == true ? a/10 + 0x30 : 0x20; a_dv = e3 == true ? a%10 + 0x30 : 0x20;
*
0633:  BSF    03.5
0634:  DECFSZ 2C,W
0635:  GOTO   640
0636:  MOVF   29,W
0637:  MOVWF  35
0638:  MOVLW  0A
0639:  MOVWF  36
063A:  BCF    03.5
063B:  CALL   61C
063C:  MOVLW  30
063D:  ADDWF  78,W
063E:  GOTO   642
063F:  BSF    03.5
0640:  MOVLW  20
0641:  BCF    03.5
0642:  BSF    03.5
0643:  MOVWF  2F
0644:  DECFSZ 2C,W
0645:  GOTO   650
0646:  MOVF   29,W
0647:  MOVWF  35
0648:  MOVLW  0A
0649:  MOVWF  36
064A:  BCF    03.5
064B:  CALL   61C
064C:  MOVLW  30
064D:  ADDWF  77,W
064E:  GOTO   652
064F:  BSF    03.5
0650:  MOVLW  20
0651:  BCF    03.5
0652:  BSF    03.5
0653:  MOVWF  30
....................    b_ch = e2 == true ? b/10 + 0x30 : 0x20; b_dv = e2 == true ? b%10 + 0x30 : 0x20;
0654:  DECFSZ 2D,W
0655:  GOTO   660
0656:  MOVF   2A,W
0657:  MOVWF  35
0658:  MOVLW  0A
0659:  MOVWF  36
065A:  BCF    03.5
065B:  CALL   61C
065C:  MOVLW  30
065D:  ADDWF  78,W
065E:  GOTO   662
065F:  BSF    03.5
0660:  MOVLW  20
0661:  BCF    03.5
0662:  BSF    03.5
0663:  MOVWF  31
0664:  DECFSZ 2D,W
0665:  GOTO   670
0666:  MOVF   2A,W
0667:  MOVWF  35
0668:  MOVLW  0A
0669:  MOVWF  36
066A:  BCF    03.5
066B:  CALL   61C
066C:  MOVLW  30
066D:  ADDWF  77,W
066E:  GOTO   672
066F:  BSF    03.5
0670:  MOVLW  20
0671:  BCF    03.5
0672:  BSF    03.5
0673:  MOVWF  32
....................    c_ch = e1 == true ? c/10 + 0x30 : 0x20; c_dv = e1 == true ? c%10 + 0x30 : 0x20;
0674:  DECFSZ 2E,W
0675:  GOTO   680
0676:  MOVF   2B,W
0677:  MOVWF  35
0678:  MOVLW  0A
0679:  MOVWF  36
067A:  BCF    03.5
067B:  CALL   61C
067C:  MOVLW  30
067D:  ADDWF  78,W
067E:  GOTO   682
067F:  BSF    03.5
0680:  MOVLW  20
0681:  BCF    03.5
0682:  BSF    03.5
0683:  MOVWF  33
0684:  DECFSZ 2E,W
0685:  GOTO   690
0686:  MOVF   2B,W
0687:  MOVWF  35
0688:  MOVLW  0A
0689:  MOVWF  36
068A:  BCF    03.5
068B:  CALL   61C
068C:  MOVLW  30
068D:  ADDWF  77,W
068E:  GOTO   692
068F:  BSF    03.5
0690:  MOVLW  20
0691:  BCF    03.5
0692:  BSF    03.5
0693:  MOVWF  34
....................    lcd_setCursor(x, y);
0694:  MOVF   27,W
0695:  MOVWF  35
0696:  MOVF   28,W
0697:  MOVWF  36
0698:  BCF    03.5
0699:  CALL   311
....................    lcd_data(a_ch); lcd_data(a_dv); lcd_data("-");
069A:  BSF    03.5
069B:  MOVF   2F,W
069C:  MOVWF  38
069D:  BCF    03.5
069E:  CALL   330
069F:  BSF    03.5
06A0:  MOVF   30,W
06A1:  MOVWF  38
06A2:  BCF    03.5
06A3:  CALL   330
06A4:  MOVLW  CE
06A5:  BSF    03.6
06A6:  MOVWF  0D
06A7:  MOVLW  00
06A8:  MOVWF  0F
06A9:  BCF    03.6
06AA:  CALL   34D
....................    lcd_data(b_ch); lcd_data(b_dv); lcd_data("-");
06AB:  BSF    03.5
06AC:  MOVF   31,W
06AD:  MOVWF  38
06AE:  BCF    03.5
06AF:  CALL   330
06B0:  BSF    03.5
06B1:  MOVF   32,W
06B2:  MOVWF  38
06B3:  BCF    03.5
06B4:  CALL   330
06B5:  MOVLW  CF
06B6:  BSF    03.6
06B7:  MOVWF  0D
06B8:  MOVLW  00
06B9:  MOVWF  0F
06BA:  BCF    03.6
06BB:  CALL   34D
....................    lcd_data(c_ch); lcd_data(c_dv);
06BC:  BSF    03.5
06BD:  MOVF   33,W
06BE:  MOVWF  38
06BF:  BCF    03.5
06C0:  CALL   330
06C1:  BSF    03.5
06C2:  MOVF   34,W
06C3:  MOVWF  38
06C4:  BCF    03.5
06C5:  CALL   330
06C6:  RETURN
.................... }
.................... 
.................... void lcd_dis_2num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 ch, dv;
....................    lcd_setCursor(x, y);
06C7:  BSF    03.5
06C8:  MOVF   25,W
06C9:  MOVWF  35
06CA:  MOVF   26,W
06CB:  MOVWF  36
06CC:  BCF    03.5
06CD:  CALL   311
....................    ch = dt/10 + 0x30;
06CE:  BSF    03.5
06CF:  MOVF   24,W
06D0:  MOVWF  2F
06D1:  MOVF   23,W
06D2:  MOVWF  2E
06D3:  CLRF   31
06D4:  MOVLW  0A
06D5:  MOVWF  30
06D6:  BCF    03.5
06D7:  CALL   507
06D8:  MOVF   79,W
06D9:  BSF    03.5
06DA:  MOVWF  2C
06DB:  MOVF   78,W
06DC:  MOVWF  2B
06DD:  MOVLW  30
06DE:  ADDWF  2B,W
06DF:  MOVWF  29
....................    dv = dt%10 + 0x30;
06E0:  MOVF   24,W
06E1:  MOVWF  2F
06E2:  MOVF   23,W
06E3:  MOVWF  2E
06E4:  CLRF   31
06E5:  MOVLW  0A
06E6:  MOVWF  30
06E7:  BCF    03.5
06E8:  CALL   507
06E9:  MOVF   77,W
06EA:  BSF    03.5
06EB:  MOVWF  2B
06EC:  MOVF   7A,W
06ED:  MOVWF  2C
06EE:  MOVLW  30
06EF:  ADDWF  2B,W
06F0:  MOVWF  2A
....................    if(is_xvn == true) if(ch == 0x30) ch = 0x20;
06F1:  DECFSZ 27,W
06F2:  GOTO   6F9
06F3:  MOVF   29,W
06F4:  SUBLW  30
06F5:  BTFSS  03.2
06F6:  GOTO   6F9
06F7:  MOVLW  20
06F8:  MOVWF  29
....................    if(is_dot == true) lcd_data(".");
06F9:  DECFSZ 28,W
06FA:  GOTO   704
06FB:  MOVLW  D0
06FC:  BCF    03.5
06FD:  BSF    03.6
06FE:  MOVWF  0D
06FF:  MOVLW  00
0700:  MOVWF  0F
0701:  BCF    03.6
0702:  CALL   34D
0703:  BSF    03.5
....................    lcd_data(ch); lcd_data(dv);
0704:  MOVF   29,W
0705:  MOVWF  38
0706:  BCF    03.5
0707:  CALL   330
0708:  BSF    03.5
0709:  MOVF   2A,W
070A:  MOVWF  38
070B:  BCF    03.5
070C:  CALL   330
070D:  RETURN
.................... }
.................... 
.................... void lcd_dis_3num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 tr, ch, dv;
....................    lcd_setCursor(x, y); //xxx /10 -> xx 
*
073C:  MOVF   25,W
073D:  MOVWF  35
073E:  MOVF   26,W
073F:  MOVWF  36
0740:  BCF    03.5
0741:  CALL   311
....................    tr = dt/100 + 0x30; 
0742:  BSF    03.5
0743:  MOVF   24,W
0744:  MOVWF  2F
0745:  MOVF   23,W
0746:  MOVWF  2E
0747:  CLRF   31
0748:  MOVLW  64
0749:  MOVWF  30
074A:  BCF    03.5
074B:  CALL   507
074C:  MOVF   79,W
074D:  BSF    03.5
074E:  MOVWF  2D
074F:  MOVF   78,W
0750:  MOVWF  2C
0751:  MOVLW  30
0752:  ADDWF  2C,W
0753:  MOVWF  29
....................    ch = dt/10%10  + 0x30;
0754:  MOVF   24,W
0755:  MOVWF  2F
0756:  MOVF   23,W
0757:  MOVWF  2E
0758:  CLRF   31
0759:  MOVLW  0A
075A:  MOVWF  30
075B:  BCF    03.5
075C:  CALL   507
075D:  MOVF   79,W
075E:  BSF    03.5
075F:  MOVWF  2D
0760:  MOVF   78,W
0761:  MOVWF  2C
0762:  MOVF   2D,W
0763:  MOVWF  2F
0764:  MOVF   2C,W
0765:  MOVWF  2E
0766:  CLRF   31
0767:  MOVLW  0A
0768:  MOVWF  30
0769:  BCF    03.5
076A:  CALL   507
076B:  MOVF   77,W
076C:  BSF    03.5
076D:  MOVWF  2C
076E:  MOVF   7A,W
076F:  MOVWF  2D
0770:  MOVLW  30
0771:  ADDWF  2C,W
0772:  MOVWF  2A
....................    dv = dt%10     + 0x30;
0773:  MOVF   24,W
0774:  MOVWF  2F
0775:  MOVF   23,W
0776:  MOVWF  2E
0777:  CLRF   31
0778:  MOVLW  0A
0779:  MOVWF  30
077A:  BCF    03.5
077B:  CALL   507
077C:  MOVF   77,W
077D:  BSF    03.5
077E:  MOVWF  2C
077F:  MOVF   7A,W
0780:  MOVWF  2D
0781:  MOVLW  30
0782:  ADDWF  2C,W
0783:  MOVWF  2B
....................    if(is_xvn == true) if(tr == 0x30){
0784:  DECFSZ 27,W
0785:  GOTO   792
0786:  MOVF   29,W
0787:  SUBLW  30
0788:  BTFSS  03.2
0789:  GOTO   792
....................       tr = 0x20;
078A:  MOVLW  20
078B:  MOVWF  29
....................       if(ch == 0x30) ch = 0x20;
078C:  MOVF   2A,W
078D:  SUBLW  30
078E:  BTFSS  03.2
078F:  GOTO   792
0790:  MOVLW  20
0791:  MOVWF  2A
....................    }
....................    if(is_dot == true) lcd_data(".");
0792:  DECFSZ 28,W
0793:  GOTO   79D
0794:  MOVLW  D1
0795:  BCF    03.5
0796:  BSF    03.6
0797:  MOVWF  0D
0798:  MOVLW  00
0799:  MOVWF  0F
079A:  BCF    03.6
079B:  CALL   34D
079C:  BSF    03.5
....................    lcd_data(tr); lcd_data(ch); lcd_data(dv);
079D:  MOVF   29,W
079E:  MOVWF  38
079F:  BCF    03.5
07A0:  CALL   330
07A1:  BSF    03.5
07A2:  MOVF   2A,W
07A3:  MOVWF  38
07A4:  BCF    03.5
07A5:  CALL   330
07A6:  BSF    03.5
07A7:  MOVF   2B,W
07A8:  MOVWF  38
07A9:  BCF    03.5
07AA:  CALL   330
.................... }
.................... 
.................... void lcd_dis_temperature (int8 x, int8 y, usi16 ng, usi16 th){
....................    lcd_setCursor(x,y);
*
070E:  MOVF   7B,W
070F:  BSF    03.5
0710:  MOVWF  35
0711:  MOVF   7C,W
0712:  MOVWF  36
0713:  BCF    03.5
0714:  CALL   311
....................    lcd_data("ND: ");
0715:  MOVLW  D2
0716:  BSF    03.6
0717:  MOVWF  0D
0718:  MOVLW  00
0719:  MOVWF  0F
071A:  BCF    03.6
071B:  CALL   34D
....................    lcd_dis_2num_dot(ng, x + 4, y, true, false);
071C:  MOVLW  04
071D:  ADDWF  7B,W
071E:  BSF    03.5
071F:  MOVWF  22
0720:  MOVF   7E,W
0721:  MOVWF  24
0722:  MOVF   7D,W
0723:  MOVWF  23
0724:  MOVF   22,W
0725:  MOVWF  25
0726:  MOVF   7C,W
0727:  MOVWF  26
0728:  MOVLW  01
0729:  MOVWF  27
072A:  CLRF   28
072B:  BCF    03.5
072C:  CALL   6C7
....................    lcd_dis_3num_dot(th, x + 6, y, false, true);
072D:  MOVLW  06
072E:  ADDWF  7B,W
072F:  BSF    03.5
0730:  MOVWF  22
0731:  MOVF   21,W
0732:  MOVWF  24
0733:  MOVF   20,W
0734:  MOVWF  23
0735:  MOVF   22,W
0736:  MOVWF  25
0737:  MOVF   7C,W
0738:  MOVWF  26
0739:  CLRF   27
073A:  MOVLW  01
073B:  MOVWF  28
....................    lcd_data(" oC");
*
07AB:  MOVLW  D5
07AC:  BSF    03.6
07AD:  MOVWF  0D
07AE:  MOVLW  00
07AF:  MOVWF  0F
07B0:  BCF    03.6
07B1:  CALL   34D
07B2:  RETURN
.................... }
.................... 
.................... void lcd_dis_temperature_limit (int8 x, int8 y, usi16 ng){
....................    lcd_setCursor(x,y);
*
12E4:  MOVF   7B,W
12E5:  BSF    03.5
12E6:  MOVWF  35
12E7:  MOVF   7C,W
12E8:  MOVWF  36
12E9:  BCF    0A.4
12EA:  BCF    03.5
12EB:  CALL   311
12EC:  BSF    0A.4
....................    lcd_data("ND-GH: ");
12ED:  MOVLW  D7
12EE:  BSF    03.6
12EF:  MOVWF  0D
12F0:  MOVLW  00
12F1:  MOVWF  0F
12F2:  BCF    0A.4
12F3:  BCF    03.6
12F4:  CALL   34D
12F5:  BSF    0A.4
....................    lcd_dis_2num_dot(ng, x + 7, y, true, false);
12F6:  MOVLW  07
12F7:  ADDWF  7B,W
12F8:  BSF    03.5
12F9:  MOVWF  20
12FA:  MOVF   7E,W
12FB:  MOVWF  24
12FC:  MOVF   7D,W
12FD:  MOVWF  23
12FE:  MOVF   20,W
12FF:  MOVWF  25
1300:  MOVF   7C,W
1301:  MOVWF  26
1302:  MOVLW  01
1303:  MOVWF  27
1304:  CLRF   28
1305:  BCF    0A.4
1306:  BCF    03.5
1307:  CALL   6C7
1308:  BSF    0A.4
....................    lcd_data(" oC");
1309:  MOVLW  DB
130A:  BSF    03.6
130B:  MOVWF  0D
130C:  MOVLW  00
130D:  MOVWF  0F
130E:  BCF    0A.4
130F:  BCF    03.6
1310:  CALL   34D
1311:  BSF    0A.4
.................... }
.................... 
.................... #include <library_ds1307_i2c.c>
.................... #define ds13_addr_wr 0xd0
.................... #define ds13_addr_rd 0xd1
.................... 
.................... //cap nhat time: giay-phut-gio-thu-ngay-thang-nam-madk_msds
.................... usi8 time_w[9]={0x31,0x15,0x15,0x04,0x25,0x10,0x23,0x90,0x91};
*
103B:  MOVLW  31
103C:  MOVWF  64
103D:  MOVLW  15
103E:  MOVWF  65
103F:  MOVWF  66
1040:  MOVLW  04
1041:  MOVWF  67
1042:  MOVLW  25
1043:  MOVWF  68
1044:  MOVLW  10
1045:  MOVWF  69
1046:  MOVLW  23
1047:  MOVWF  6A
1048:  MOVLW  90
1049:  MOVWF  6B
104A:  MOVLW  91
104B:  MOVWF  6C
.................... usi8 time_r[9]={0x30,0x30,0x10,0x08,0x20,0x02,0x20,0x90,0x91};
104C:  MOVLW  30
104D:  MOVWF  6D
104E:  MOVWF  6E
104F:  MOVLW  10
1050:  MOVWF  6F
1051:  MOVLW  08
1052:  MOVWF  70
1053:  MOVLW  20
1054:  MOVWF  71
1055:  MOVLW  02
1056:  MOVWF  72
1057:  MOVLW  20
1058:  MOVWF  73
1059:  MOVLW  90
105A:  MOVWF  74
105B:  MOVLW  91
105C:  MOVWF  75
.................... 
.................... #define dec_giay_eat  ds1307_bcdToDec(eat_ss)
.................... #define dec_phut_eat  ds1307_bcdToDec(eat_pp)
.................... #define dec_gio_eat   ds1307_bcdToDec(eat_hh)
.................... 
.................... #define dec_giay_ds  ds1307_bcdToDec(time_r[0])
.................... #define dec_phut_ds  ds1307_bcdToDec(time_r[1])
.................... #define dec_gio_ds   ds1307_bcdToDec(time_r[2])
.................... #define dec_thu_ds   ds1307_bcdToDec(time_r[3])
.................... #define dec_ngay_ds  ds1307_bcdToDec(time_r[4])
.................... #define dec_thang_ds ds1307_bcdToDec(time_r[5])
.................... #define dec_nam_ds   ds1307_bcdToDec(time_r[6])
.................... 
.................... #define giay_ds  time_r[0]
.................... #define phut_ds  time_r[1]
.................... #define gio_ds   time_r[2]
.................... #define thu_ds   time_r[3]
.................... #define ngay_ds  time_r[4]
.................... #define thang_ds time_r[5]
.................... #define nam_ds   time_r[6]
.................... 
.................... #define ma_qd   time_w[8]
.................... #define ma_ds   time_r[8]
.................... 
.................... usi8 ds1307_decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
.................... }
.................... 
.................... usi8 ds1307_bcdToDec(usi8 val) {
....................     return ((val / 16 * 10) + (val % 16));
*
0607:  BSF    03.5
0608:  SWAPF  23,W
0609:  MOVWF  77
060A:  MOVLW  0F
060B:  ANDWF  77,F
060C:  MOVF   77,W
060D:  MOVWF  25
060E:  MOVWF  26
060F:  MOVLW  0A
0610:  MOVWF  27
0611:  BCF    03.5
0612:  CALL   5E0
0613:  MOVF   78,W
0614:  BSF    03.5
0615:  MOVWF  24
0616:  MOVF   23,W
0617:  ANDLW  0F
0618:  ADDWF  24,W
0619:  MOVWF  78
061A:  BCF    03.5
061B:  RETURN
.................... }
.................... 
.................... void ds1307_read_time(usi8 j)     
.................... {   
....................    usi8 i; 
....................    i2c_start();
*
0170:  BSF    03.5
0171:  BSF    11.0
0172:  BTFSC  11.0
0173:  GOTO   172
....................    i2c_write(ds13_addr_wr);
0174:  MOVLW  D0
0175:  MOVWF  48
0176:  BCF    03.5
0177:  CALL   14E
....................    i2c_write(0x00);                     
0178:  BSF    03.5
0179:  CLRF   48
017A:  BCF    03.5
017B:  CALL   14E
....................    i2c_start();               
017C:  BSF    03.5
017D:  BSF    11.1
017E:  BTFSC  11.1
017F:  GOTO   17E
....................    i2c_write(ds13_addr_rd);                              
0180:  MOVLW  D1
0181:  MOVWF  48
0182:  BCF    03.5
0183:  CALL   14E
....................    for(i=0;i<j;i++) time_r[i]=i2c_read();
0184:  CLRF   7C
0185:  MOVF   7B,W
0186:  SUBWF  7C,W
0187:  BTFSC  03.0
0188:  GOTO   194
0189:  MOVLW  6D
018A:  ADDWF  7C,W
018B:  MOVWF  04
018C:  BCF    03.7
018D:  MOVLW  01
018E:  MOVWF  77
018F:  CALL   160
0190:  MOVF   78,W
0191:  MOVWF  00
0192:  INCF   7C,F
0193:  GOTO   185
....................                                  
....................    i = i2c_read(0); //not ack, don't care i  
0194:  CLRF   77
0195:  CALL   160
0196:  MOVF   78,W
0197:  MOVWF  7C
....................    i2c_stop();
0198:  BSF    03.5
0199:  BSF    11.2
019A:  BTFSC  11.2
019B:  GOTO   19A
019C:  BCF    03.5
019D:  RETURN
.................... }
.................... 
.................... void ds1307_update_time(int1 sel)                 
.................... {         
....................    usi8 i;
....................    i2c_start();
*
01A7:  BSF    03.5
01A8:  BSF    11.0
01A9:  BTFSC  11.0
01AA:  GOTO   1A9
....................    i2c_write(ds13_addr_wr);
01AB:  MOVLW  D0
01AC:  MOVWF  48
01AD:  BCF    03.5
01AE:  CALL   14E
....................    i2c_write(0x00);
01AF:  BSF    03.5
01B0:  CLRF   48
01B1:  BCF    03.5
01B2:  CALL   14E
....................    for(i=0;i<9;i++)                          
01B3:  CLRF   7B
01B4:  MOVF   7B,W
01B5:  SUBLW  08
01B6:  BTFSS  03.0
01B7:  GOTO   1D2
....................    {  
....................       if(sel)  i2c_write(time_w[i]);
01B8:  MOVF   76,F
01B9:  BTFSC  03.2
01BA:  GOTO   1C6
01BB:  MOVLW  64
01BC:  ADDWF  7B,W
01BD:  MOVWF  04
01BE:  BCF    03.7
01BF:  MOVF   00,W
01C0:  MOVWF  7C
01C1:  BSF    03.5
01C2:  MOVWF  48
01C3:  BCF    03.5
01C4:  CALL   14E
01C5:  GOTO   1D0
....................       else     i2c_write(time_r[i]);
01C6:  MOVLW  6D
01C7:  ADDWF  7B,W
01C8:  MOVWF  04
01C9:  BCF    03.7
01CA:  MOVF   00,W
01CB:  MOVWF  7C
01CC:  BSF    03.5
01CD:  MOVWF  48
01CE:  BCF    03.5
01CF:  CALL   14E
01D0:  INCF   7B,F
01D1:  GOTO   1B4
....................    }                                 
....................    i2c_stop();        
01D2:  BSF    03.5
01D3:  BSF    11.2
01D4:  BTFSC  11.2
01D5:  GOTO   1D4
01D6:  BCF    03.5
.................... }  
.................... 
.................... void ds1307_setup()
.................... {                                              
....................    ds1307_read_time(9);          
*
019E:  MOVLW  09
019F:  MOVWF  7B
01A0:  CALL   170
....................    if(ma_qd!=ma_ds)
01A1:  MOVF   75,W
01A2:  SUBWF  6C,W
01A3:  BTFSC  03.2
01A4:  GOTO   1D7
....................    {
....................       ds1307_update_time(1);
01A5:  MOVLW  01
01A6:  MOVWF  76
....................    }
*
01D7:  BCF    0A.3
01D8:  BSF    0A.4
01D9:  GOTO   062 (RETURN)
.................... }
.................... 
.................... void ds1307_save_ds(usi8 dcdt,dt)                 
.................... {           
....................    i2c_start();
*
09A7:  BSF    03.5
09A8:  BSF    11.0
09A9:  BTFSC  11.0
09AA:  GOTO   1A9
....................    i2c_write(ds13_addr_wr);        
09AB:  MOVLW  D0
09AC:  MOVWF  48
09AD:  BCF    0A.3
09AE:  BCF    03.5
09AF:  CALL   14E
09B0:  BSF    0A.3
....................    i2c_write(dcdt);    
09B1:  MOVF   7B,W
09B2:  BSF    03.5
09B3:  MOVWF  48
09B4:  BCF    0A.3
09B5:  BCF    03.5
09B6:  CALL   14E
09B7:  BSF    0A.3
....................    i2c_write(dt);
09B8:  MOVF   7C,W
09B9:  BSF    03.5
09BA:  MOVWF  48
09BB:  BCF    0A.3
09BC:  BCF    03.5
09BD:  CALL   14E
09BE:  BSF    0A.3
....................    i2c_stop();
09BF:  BSF    03.5
09C0:  BSF    11.2
09C1:  BTFSC  11.2
09C2:  GOTO   1C1
09C3:  BCF    03.5
09C4:  RETURN
.................... }
.................... 
.................... #include <library_ds18b20.c>
.................... #include <touch.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                        Dallas Touch Driver                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    ////
.................... ////                                                                   ////
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  present = touch_present()   Issues a reset and returns true      ////
.................... ////                              if the touch device is there.        ////
.................... ////                                                                   ////
.................... ////  reset_pulse()               Issues a reset and waits for a       ////
.................... ////                              present pulse.                       ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef  TOUCH_C
.................... #define  TOUCH_C
.................... 
.................... #ifndef TOUCH_PIN
....................    #define TOUCH_PIN  PIN_B0
.................... #endif
.................... 
.................... #define TOUCH_PIN_LOW()    output_drive(TOUCH_PIN); output_low(TOUCH_PIN)
.................... #define TOUCH_PIN_HIGH()    output_drive(TOUCH_PIN); output_high(TOUCH_PIN)
.................... #define TOUCH_PIN_FLOAT()  output_float(TOUCH_PIN)
.................... #define TOUCH_PIN_READ()      input_state(TOUCH_PIN)
.................... 
.................... /////////////////////////////
.................... ////                     ////
.................... //// Function Prototypes ////
.................... ////                     ////
.................... /////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit();
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte();
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data);
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data);
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present();
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse();
.................... 
.................... //////////////////////////////////
.................... ////                          ////
.................... //// Function Implementations ////
.................... ////                          ////
.................... //////////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit()
.................... {
....................    int1 data;
.................... 
....................    TOUCH_PIN_LOW();
....................    delay_us(14);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    data = TOUCH_PIN_READ();
....................    delay_us(100);
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte()
.................... {
....................    BYTE i,data;
.................... 
....................    for(i=1; i <= 8; ++i)
....................       shift_right(&data, 1, touch_read_bit());
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data)
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(10);
....................    if(data)
....................    {
....................       TOUCH_PIN_HIGH();
....................       delay_us(10);
....................       if(!TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    else
....................    {
....................       TOUCH_PIN_LOW();
....................       delay_us(10);
....................       if(TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    delay_us(50);
....................    TOUCH_PIN_HIGH();
....................    delay_us(50);
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data)
.................... {
....................    BYTE i;
.................... 
....................    for(i=1; i<=8; ++i)
....................       if(!touch_write_bit(shift_right(&data, 1, 0)))
....................          return FALSE;
.................... 
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present()
.................... {
....................    BOOLEAN present;
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
.................... 
....................    if(!TOUCH_PIN_READ())
....................       return FALSE;
.................... 
....................    delay_us(65);
....................    present = !TOUCH_PIN_READ();
....................    delay_us(240);
....................    return present;
.................... }
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse()
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    while(!touch_present());
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define search_rom       0xf0
.................... #define read_rom         0x33
.................... #define match_rom        0x55
.................... #define skip_rom         0xcc
.................... #define alarm_search     0xec
.................... #define read_scratchpad  0xbe
.................... #define write_scratchpad 0x4e
.................... #define copy_scratchpad  0x48
.................... #define convert_t        0x44
.................... 
.................... bool ds18b20_start(){
....................    output_low(pin_ds18b20);
*
0478:  BCF    05.0
....................    output_drive(pin_ds18b20);
0479:  BSF    03.5
047A:  BCF    05.0
....................    delay_us(500);
047B:  MOVLW  02
047C:  MOVWF  20
047D:  MOVLW  F9
047E:  MOVWF  21
047F:  BCF    03.5
0480:  CALL   2E5
0481:  BSF    03.5
0482:  DECFSZ 20,F
0483:  GOTO   47D
....................    output_float(pin_ds18b20);
0484:  BSF    05.0
....................    delay_us(100);
0485:  MOVLW  A6
0486:  MOVWF  77
0487:  DECFSZ 77,F
0488:  GOTO   487
0489:  NOP
....................    if(!input(pin_ds18b20)){
048A:  BCF    03.5
048B:  BTFSC  05.0
048C:  GOTO   49B
....................       delay_us(400);
048D:  MOVLW  02
048E:  BSF    03.5
048F:  MOVWF  20
0490:  MOVLW  C7
0491:  MOVWF  21
0492:  BCF    03.5
0493:  CALL   2E5
0494:  BSF    03.5
0495:  DECFSZ 20,F
0496:  GOTO   490
....................       return true;
0497:  MOVLW  01
0498:  MOVWF  78
0499:  GOTO   49E
049A:  BCF    03.5
....................    }
....................    return false;
049B:  MOVLW  00
049C:  MOVWF  78
049D:  BSF    03.5
049E:  BCF    03.5
049F:  RETURN
.................... }
.................... 
.................... void ds18b20_write_bit(bool value){
....................    output_low(pin_ds18b20);
*
04B6:  BCF    03.5
04B7:  BCF    05.0
....................    output_drive(pin_ds18b20);
04B8:  BSF    03.5
04B9:  BCF    05.0
....................    delay_us(2);
04BA:  MOVLW  03
04BB:  MOVWF  77
04BC:  DECFSZ 77,F
04BD:  GOTO   4BC
....................    output_bit(pin_ds18b20, value);
04BE:  MOVF   23,F
04BF:  BTFSS  03.2
04C0:  GOTO   4C5
04C1:  BCF    03.5
04C2:  BCF    05.0
04C3:  GOTO   4C7
04C4:  BSF    03.5
04C5:  BCF    03.5
04C6:  BSF    05.0
....................    delay_us(80);
04C7:  MOVLW  85
04C8:  MOVWF  77
04C9:  DECFSZ 77,F
04CA:  GOTO   4C9
....................    output_float(pin_ds18b20);
04CB:  BSF    03.5
04CC:  BSF    05.0
....................    delay_us(2);
04CD:  MOVLW  03
04CE:  MOVWF  77
04CF:  DECFSZ 77,F
04D0:  GOTO   4CF
.................... }
.................... 
.................... void ds18b20_write_byte(int8 value){
....................    for(int8 i = 0; i < 8; i++)
*
04A0:  BSF    03.5
04A1:  CLRF   21
04A2:  MOVF   21,W
04A3:  SUBLW  07
04A4:  BTFSS  03.0
04A5:  GOTO   4D3
....................       ds18b20_write_bit(bit_test(value,i));
04A6:  MOVF   20,W
04A7:  MOVWF  77
04A8:  MOVF   21,W
04A9:  MOVWF  78
04AA:  BTFSC  03.2
04AB:  GOTO   4B0
04AC:  BCF    03.0
04AD:  RRF    77,F
04AE:  DECFSZ 78,F
04AF:  GOTO   4AC
04B0:  MOVLW  00
04B1:  BTFSC  77.0
04B2:  MOVLW  01
04B3:  MOVWF  22
04B4:  MOVF   22,W
04B5:  MOVWF  23
*
04D1:  INCF   21,F
04D2:  GOTO   4A2
04D3:  BCF    03.5
04D4:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_bit(){
....................    bool value;
....................    output_low(pin_ds18b20);
*
04DC:  BCF    03.5
04DD:  BCF    05.0
....................    output_drive(pin_ds18b20);
04DE:  BSF    03.5
04DF:  BCF    05.0
....................    delay_us(2);
04E0:  MOVLW  03
04E1:  MOVWF  77
04E2:  DECFSZ 77,F
04E3:  GOTO   4E2
....................    output_float(pin_ds18b20);
04E4:  BSF    05.0
....................    delay_us(5);
04E5:  MOVLW  08
04E6:  MOVWF  77
04E7:  DECFSZ 77,F
04E8:  GOTO   4E7
....................    value = input(pin_ds18b20);
04E9:  BCF    26.0
04EA:  BCF    03.5
04EB:  BTFSS  05.0
04EC:  GOTO   4F0
04ED:  BSF    03.5
04EE:  BSF    26.0
04EF:  BCF    03.5
....................    delay_us(100);
04F0:  MOVLW  A6
04F1:  MOVWF  77
04F2:  DECFSZ 77,F
04F3:  GOTO   4F2
04F4:  NOP
....................    return value;
04F5:  MOVLW  00
04F6:  BSF    03.5
04F7:  BTFSC  26.0
04F8:  MOVLW  01
04F9:  MOVWF  78
.................... }
.................... 
.................... int8 ds18b20_read_byte(){
*
04D5:  BSF    03.5
04D6:  CLRF   24
....................    int8 value = 0;
....................    for(int8 i = 0; i < 8; i++)
04D7:  CLRF   25
04D8:  MOVF   25,W
04D9:  SUBLW  07
04DA:  BTFSS  03.0
04DB:  GOTO   503
....................       shift_right(&value,1,ds18b20_read_bit());
*
04FA:  MOVF   78,F
04FB:  BTFSS  03.2
04FC:  GOTO   4FF
04FD:  BCF    03.0
04FE:  GOTO   500
04FF:  BSF    03.0
0500:  RRF    24,F
0501:  INCF   25,F
0502:  GOTO   4D8
....................    return value;
0503:  MOVF   24,W
0504:  MOVWF  78
0505:  BCF    03.5
0506:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_temp_c2(usi16 *raw_temp_value){
....................    if(!ds18b20_start())
*
0531:  CALL   478
0532:  MOVF   78,F
0533:  BTFSS  03.2
0534:  GOTO   538
....................       return false;
0535:  MOVLW  00
0536:  MOVWF  78
0537:  GOTO   59B
....................    ds18b20_write_byte(skip_rom);
0538:  MOVLW  CC
0539:  BSF    03.5
053A:  MOVWF  20
053B:  BCF    03.5
053C:  CALL   4A0
....................    ds18b20_write_byte(convert_t);
053D:  MOVLW  44
053E:  BSF    03.5
053F:  MOVWF  20
0540:  BCF    03.5
0541:  CALL   4A0
....................    while(ds18b20_read_byte() == 0);
0542:  CALL   4D5
0543:  MOVF   78,F
0544:  BTFSC  03.2
0545:  GOTO   542
....................    if(!ds18b20_start())
0546:  CALL   478
0547:  MOVF   78,F
0548:  BTFSS  03.2
0549:  GOTO   54D
....................       return false;
054A:  MOVLW  00
054B:  MOVWF  78
054C:  GOTO   59B
....................    ds18b20_write_byte(skip_rom);
054D:  MOVLW  CC
054E:  BSF    03.5
054F:  MOVWF  20
0550:  BCF    03.5
0551:  CALL   4A0
....................    ds18b20_write_byte(read_scratchpad);
0552:  MOVLW  BE
0553:  BSF    03.5
0554:  MOVWF  20
0555:  BCF    03.5
0556:  CALL   4A0
....................    *raw_temp_value = ds18b20_read_byte();
0557:  MOVF   7C,W
0558:  MOVWF  7A
0559:  MOVF   7B,W
055A:  BSF    03.5
055B:  MOVWF  20
055C:  MOVF   7C,W
055D:  MOVWF  21
055E:  BCF    03.5
055F:  CALL   4D5
0560:  BSF    03.5
0561:  MOVF   20,W
0562:  MOVWF  04
0563:  BCF    03.7
0564:  BTFSC  21.0
0565:  BSF    03.7
0566:  INCF   04,F
0567:  CLRF   00
0568:  DECF   04,F
0569:  MOVF   78,W
056A:  MOVWF  00
....................    *raw_temp_value |= (int16)(ds18b20_read_byte()) << 8;
056B:  MOVF   7C,W
056C:  MOVWF  7A
056D:  MOVF   7B,W
056E:  MOVWF  20
056F:  MOVF   7C,W
0570:  MOVWF  21
0571:  MOVF   20,W
0572:  MOVWF  04
0573:  BCF    03.7
0574:  BTFSC  21.0
0575:  BSF    03.7
0576:  INCF   04,F
0577:  MOVF   00,W
0578:  MOVWF  23
0579:  DECF   04,F
057A:  MOVF   00,W
057B:  MOVWF  22
057C:  BCF    03.5
057D:  CALL   4D5
057E:  BSF    03.5
057F:  CLRF   25
0580:  MOVF   78,W
0581:  MOVWF  24
0582:  MOVWF  7A
0583:  MOVLW  00
0584:  IORWF  22,W
0585:  MOVWF  77
0586:  MOVF   7A,W
0587:  IORWF  23,W
0588:  MOVWF  7A
0589:  MOVF   77,W
058A:  MOVWF  22
058B:  MOVF   7A,W
058C:  MOVWF  23
058D:  MOVF   20,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  21.0
0591:  BSF    03.7
0592:  INCF   04,F
0593:  MOVF   23,W
0594:  MOVWF  00
0595:  DECF   04,F
0596:  MOVF   22,W
0597:  MOVWF  00
....................    return true;
0598:  MOVLW  01
0599:  MOVWF  78
059A:  BCF    03.5
.................... }
.................... 
.................... void ds18b20_read_temp(){
....................    if(ds18b20_read_temp_c2(&temperature)){
*
052E:  CLRF   7C
052F:  MOVLW  3D
0530:  MOVWF  7B
*
059B:  MOVF   78,F
059C:  BTFSC  03.2
059D:  GOTO   5DE
....................       isDs18b20 = true;
059E:  BSF    2C.2
....................       dt_ng = temperature>>4;
059F:  RRF    3E,W
05A0:  MOVWF  7A
05A1:  RRF    3D,W
05A2:  MOVWF  79
05A3:  RRF    7A,F
05A4:  RRF    79,F
05A5:  RRF    7A,F
05A6:  RRF    79,F
05A7:  RRF    7A,F
05A8:  RRF    79,F
05A9:  MOVF   79,W
05AA:  MOVWF  3F
....................       tt = temperature & 0x000f;
05AB:  MOVF   3D,W
05AC:  ANDLW  0F
05AD:  MOVWF  42
05AE:  CLRF   43
....................       dt_tp = (tt*625)/10;
05AF:  MOVF   43,W
05B0:  MOVWF  7C
05B1:  MOVF   42,W
05B2:  MOVWF  7B
05B3:  MOVLW  02
05B4:  MOVWF  7E
05B5:  MOVLW  71
05B6:  MOVWF  7D
*
05CC:  MOVF   79,W
05CD:  MOVWF  7C
05CE:  MOVF   78,W
05CF:  MOVWF  7B
05D0:  MOVF   79,W
05D1:  MOVWF  2F
05D2:  MOVF   78,W
05D3:  MOVWF  2E
05D4:  CLRF   31
05D5:  MOVLW  0A
05D6:  MOVWF  30
05D7:  BCF    03.5
05D8:  CALL   507
05D9:  MOVF   79,W
05DA:  MOVWF  41
05DB:  MOVF   78,W
05DC:  MOVWF  40
....................    }
05DD:  GOTO   5DF
....................    else isDs18b20 = false;
05DE:  BCF    2C.2
05DF:  RETURN
.................... }
.................... 
.................... #include <library_change_rtc.c>
.................... 
.................... usi8 tang_or_giam_bcd(unsigned int8 x, int1 sel){
....................    usi8 y, dv, ch, v;
....................    ch = (x>>4);
*
096C:  SWAPF  7B,W
096D:  BSF    03.5
096E:  MOVWF  20
096F:  MOVLW  0F
0970:  ANDWF  20,F
....................    dv = x& 0x0f;
0971:  MOVF   7B,W
0972:  ANDLW  0F
0973:  MOVWF  7E
....................    y = ch*10 + dv;
0974:  MOVF   20,W
0975:  MOVWF  26
0976:  MOVLW  0A
0977:  MOVWF  27
0978:  BCF    0A.3
0979:  BCF    03.5
097A:  CALL   5E0
097B:  BSF    0A.3
097C:  MOVF   7E,W
097D:  ADDWF  78,W
097E:  MOVWF  7D
....................    if(sel == 0) y++;
097F:  MOVF   7C,F
0980:  BTFSS  03.2
0981:  GOTO   184
0982:  INCF   7D,F
0983:  GOTO   185
....................    else         y--;
0984:  DECF   7D,F
....................    ch = y/10; dv = y%10;
0985:  MOVF   7D,W
0986:  BSF    03.5
0987:  MOVWF  35
0988:  MOVLW  0A
0989:  MOVWF  36
098A:  BCF    0A.3
098B:  BCF    03.5
098C:  CALL   61C
098D:  BSF    0A.3
098E:  MOVF   78,W
098F:  BSF    03.5
0990:  MOVWF  20
0991:  MOVF   7D,W
0992:  MOVWF  35
0993:  MOVLW  0A
0994:  MOVWF  36
0995:  BCF    0A.3
0996:  BCF    03.5
0997:  CALL   61C
0998:  BSF    0A.3
0999:  MOVF   77,W
099A:  MOVWF  7E
....................    v = (ch<<4)|dv;
099B:  BSF    03.5
099C:  SWAPF  20,W
099D:  MOVWF  77
099E:  MOVLW  F0
099F:  ANDWF  77,F
09A0:  MOVF   77,W
09A1:  IORWF  7E,W
09A2:  MOVWF  21
....................    return v;
09A3:  MOVF   21,W
09A4:  MOVWF  78
09A5:  BCF    03.5
09A6:  RETURN
.................... }
.................... 
.................... void tat_bat_2led_chinh(){
....................    if(gt_mod == 1 || gt_mod == 4) { e_11 = ~e_11; e_22 = true; e_33 = true;}
*
086E:  DECFSZ 35,W
086F:  GOTO   071
0870:  GOTO   075
0871:  MOVF   35,W
0872:  SUBLW  04
0873:  BTFSS  03.2
0874:  GOTO   07A
0875:  MOVLW  08
0876:  XORWF  2C,F
0877:  BSF    2C.4
0878:  BSF    2C.5
0879:  GOTO   097
....................    else if(gt_mod == 2 || gt_mod == 5) { e_11 = true; e_22 = ~e_22; e_33 = true;}
087A:  MOVF   35,W
087B:  SUBLW  02
087C:  BTFSC  03.2
087D:  GOTO   082
087E:  MOVF   35,W
087F:  SUBLW  05
0880:  BTFSS  03.2
0881:  GOTO   087
0882:  BSF    2C.3
0883:  MOVLW  10
0884:  XORWF  2C,F
0885:  BSF    2C.5
0886:  GOTO   097
....................    else if(gt_mod == 3 || gt_mod == 6) { e_11 = true; e_22 = true; e_33 = ~e_33;}
0887:  MOVF   35,W
0888:  SUBLW  03
0889:  BTFSC  03.2
088A:  GOTO   08F
088B:  MOVF   35,W
088C:  SUBLW  06
088D:  BTFSS  03.2
088E:  GOTO   094
088F:  BSF    2C.3
0890:  BSF    2C.4
0891:  MOVLW  20
0892:  XORWF  2C,F
0893:  GOTO   097
....................    else { e_11 = true; e_22 = true; e_33 = true;}
0894:  BSF    2C.3
0895:  BSF    2C.4
0896:  BSF    2C.5
.................... }
.................... 
.................... void giai_ma_gpg_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_ds,dec_phut_ds,dec_giay_ds,e_33, e_22, e_11);
*
089C:  MOVF   6F,W
089D:  BSF    03.5
089E:  MOVWF  23
089F:  BCF    0A.3
08A0:  BCF    03.5
08A1:  CALL   607
08A2:  BSF    0A.3
08A3:  MOVF   78,W
08A4:  BSF    03.5
08A5:  MOVWF  20
08A6:  BCF    03.5
08A7:  MOVF   6E,W
08A8:  BSF    03.5
08A9:  MOVWF  23
08AA:  BCF    0A.3
08AB:  BCF    03.5
08AC:  CALL   607
08AD:  BSF    0A.3
08AE:  MOVF   78,W
08AF:  BSF    03.5
08B0:  MOVWF  21
08B1:  BCF    03.5
08B2:  MOVF   6D,W
08B3:  BSF    03.5
08B4:  MOVWF  23
08B5:  BCF    0A.3
08B6:  BCF    03.5
08B7:  CALL   607
08B8:  BSF    0A.3
08B9:  MOVF   78,W
08BA:  BSF    03.5
08BB:  MOVWF  22
08BC:  MOVLW  00
08BD:  BCF    03.5
08BE:  BTFSC  2C.5
08BF:  MOVLW  01
08C0:  BSF    03.5
08C1:  MOVWF  23
08C2:  MOVLW  00
08C3:  BCF    03.5
08C4:  BTFSC  2C.4
08C5:  MOVLW  01
08C6:  BSF    03.5
08C7:  MOVWF  24
08C8:  MOVLW  00
08C9:  BCF    03.5
08CA:  BTFSC  2C.3
08CB:  MOVLW  01
08CC:  BSF    03.5
08CD:  MOVWF  25
08CE:  MOVLW  04
08CF:  MOVWF  27
08D0:  MOVLW  01
08D1:  MOVWF  28
08D2:  MOVF   20,W
08D3:  MOVWF  29
08D4:  MOVF   21,W
08D5:  MOVWF  2A
08D6:  MOVF   22,W
08D7:  MOVWF  2B
08D8:  MOVF   23,W
08D9:  MOVWF  2C
08DA:  MOVF   24,W
08DB:  MOVWF  2D
08DC:  MOVF   25,W
08DD:  MOVWF  2E
08DE:  BCF    0A.3
08DF:  BCF    03.5
08E0:  CALL   633
08E1:  BSF    0A.3
08E2:  RETURN
.................... }
.................... 
.................... void giai_ma_ntn_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_ngay_ds,dec_thang_ds,dec_nam_ds,e_33, e_22, e_11);
08E3:  MOVF   71,W
08E4:  BSF    03.5
08E5:  MOVWF  23
08E6:  BCF    0A.3
08E7:  BCF    03.5
08E8:  CALL   607
08E9:  BSF    0A.3
08EA:  MOVF   78,W
08EB:  BSF    03.5
08EC:  MOVWF  20
08ED:  MOVF   72,W
08EE:  MOVWF  23
08EF:  BCF    0A.3
08F0:  BCF    03.5
08F1:  CALL   607
08F2:  BSF    0A.3
08F3:  MOVF   78,W
08F4:  BSF    03.5
08F5:  MOVWF  21
08F6:  MOVF   73,W
08F7:  MOVWF  23
08F8:  BCF    0A.3
08F9:  BCF    03.5
08FA:  CALL   607
08FB:  BSF    0A.3
08FC:  MOVF   78,W
08FD:  BSF    03.5
08FE:  MOVWF  22
08FF:  MOVLW  00
0900:  BCF    03.5
0901:  BTFSC  2C.5
0902:  MOVLW  01
0903:  BSF    03.5
0904:  MOVWF  23
0905:  MOVLW  00
0906:  BCF    03.5
0907:  BTFSC  2C.4
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  24
090B:  MOVLW  00
090C:  BCF    03.5
090D:  BTFSC  2C.3
090E:  MOVLW  01
090F:  BSF    03.5
0910:  MOVWF  25
0911:  MOVLW  04
0912:  MOVWF  27
0913:  MOVLW  01
0914:  MOVWF  28
0915:  MOVF   20,W
0916:  MOVWF  29
0917:  MOVF   21,W
0918:  MOVWF  2A
0919:  MOVF   22,W
091A:  MOVWF  2B
091B:  MOVF   23,W
091C:  MOVWF  2C
091D:  MOVF   24,W
091E:  MOVWF  2D
091F:  MOVF   25,W
0920:  MOVWF  2E
0921:  BCF    0A.3
0922:  BCF    03.5
0923:  CALL   633
0924:  BSF    0A.3
0925:  RETURN
.................... }
.................... 
.................... void giai_ma_thu_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,0x00,dec_thu_ds,0x00,0, e_22, 0);
0926:  MOVF   70,W
0927:  BSF    03.5
0928:  MOVWF  23
0929:  BCF    0A.3
092A:  BCF    03.5
092B:  CALL   607
092C:  BSF    0A.3
092D:  MOVF   78,W
092E:  MOVWF  7B
092F:  MOVLW  00
0930:  BTFSC  2C.4
0931:  MOVLW  01
0932:  MOVWF  7C
0933:  MOVLW  04
0934:  BSF    03.5
0935:  MOVWF  27
0936:  MOVLW  01
0937:  MOVWF  28
0938:  CLRF   29
0939:  MOVF   78,W
093A:  MOVWF  2A
093B:  CLRF   2B
093C:  CLRF   2C
093D:  MOVF   7C,W
093E:  MOVWF  2D
093F:  CLRF   2E
0940:  BCF    0A.3
0941:  BCF    03.5
0942:  CALL   633
0943:  BSF    0A.3
0944:  RETURN
.................... }
.................... 
.................... void giai_ma_gpg_ntn_thu_lcd(){
....................    if(gt_mod == 0){
0945:  MOVF   35,F
0946:  BTFSS  03.2
0947:  GOTO   157
....................       if(tt_ht == 0 || tt_ht == 1) giai_ma_gpg_lcd();
0948:  MOVF   34,F
0949:  BTFSC  03.2
094A:  GOTO   14D
094B:  DECFSZ 34,W
094C:  GOTO   14E
094D:  CALL   09C
....................       if(tt_ht == 2) giai_ma_ntn_lcd();
094E:  MOVF   34,W
094F:  SUBLW  02
0950:  BTFSC  03.2
0951:  CALL   0E3
....................       if(tt_ht == 3) giai_ma_thu_lcd();
0952:  MOVF   34,W
0953:  SUBLW  03
0954:  BTFSC  03.2
0955:  CALL   126
....................    }
0956:  GOTO   16B
....................    else{
....................       if(gt_mod < 4)       giai_ma_gpg_lcd();
0957:  BTFSC  35.7
0958:  GOTO   15D
0959:  MOVF   35,W
095A:  SUBLW  03
095B:  BTFSS  03.0
095C:  GOTO   15F
095D:  CALL   09C
095E:  GOTO   16B
....................       else if(gt_mod < 7)  giai_ma_ntn_lcd();
095F:  BTFSC  35.7
0960:  GOTO   165
0961:  MOVF   35,W
0962:  SUBLW  06
0963:  BTFSS  03.0
0964:  GOTO   167
0965:  CALL   0E3
0966:  GOTO   16B
....................       else if(gt_mod == 7) giai_ma_thu_lcd();
0967:  MOVF   35,W
0968:  SUBLW  07
0969:  BTFSC  03.2
096A:  CALL   126
....................    }
096B:  RETURN
.................... }
.................... 
.................... void xu_ly_choptat(){
....................    if(gt_mod != 0){
*
086B:  MOVF   35,F
086C:  BTFSC  03.2
086D:  GOTO   098
....................       tat_bat_2led_chinh();
....................    }
*
0897:  GOTO   09B
....................    else { e_11 = true; e_22 = true; e_33 = true;}
0898:  BSF    2C.3
0899:  BSF    2C.4
089A:  BSF    2C.5
089B:  RETURN
....................    
.................... }
.................... 
.................... void phim_chon_hthi_mode(){
....................    if(tick_btn(2, bt3)){
*
1340:  MOVLW  02
1341:  MOVWF  76
1342:  MOVLW  33
1343:  MOVWF  7B
1344:  BCF    0A.4
1345:  CALL   7D1
1346:  BSF    0A.4
1347:  MOVF   78,F
1348:  BTFSC  03.2
1349:  GOTO   371
....................       tt_ht = 1;
134A:  MOVLW  01
134B:  MOVWF  34
....................       if(tt_ht == 1){
134C:  DECFSZ 34,W
134D:  GOTO   36B
....................          gt_mod++;
134E:  INCF   35,F
....................          if(gt_mod < 4) tt_ht = 1;
134F:  BTFSC  35.7
1350:  GOTO   355
1351:  MOVF   35,W
1352:  SUBLW  03
1353:  BTFSS  03.0
1354:  GOTO   358
1355:  MOVLW  01
1356:  MOVWF  34
1357:  GOTO   36B
....................          else if(gt_mod < 7) tt_ht = 2;
1358:  BTFSC  35.7
1359:  GOTO   35E
135A:  MOVF   35,W
135B:  SUBLW  06
135C:  BTFSS  03.0
135D:  GOTO   361
135E:  MOVLW  02
135F:  MOVWF  34
1360:  GOTO   36B
....................          else if(gt_mod == 7) tt_ht = 3;
1361:  MOVF   35,W
1362:  SUBLW  07
1363:  BTFSS  03.2
1364:  GOTO   368
1365:  MOVLW  03
1366:  MOVWF  34
1367:  GOTO   36B
....................          else{
....................             gt_mod = 0;
1368:  CLRF   35
....................             tt_ht = 0;
1369:  CLRF   34
....................             countLevel = 0;
136A:  CLRF   3A
....................          }
....................       }
....................       tg_chinh = 0;
136B:  CLRF   36
....................       giai_ma_gpg_ntn_thu_lcd();
136C:  BCF    0A.4
136D:  BSF    0A.3
136E:  CALL   145
136F:  BSF    0A.4
1370:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay(){
....................    if(giay_ds == 0x59) giay_ds = 0;
*
138D:  MOVF   6D,W
138E:  SUBLW  59
138F:  BTFSS  03.2
1390:  GOTO   393
1391:  CLRF   6D
1392:  GOTO   39D
....................    else giay_ds = tang_or_giam_bcd(giay_ds, tang);
1393:  MOVF   6D,W
1394:  MOVWF  7B
1395:  CLRF   7C
1396:  BCF    0A.4
1397:  BSF    0A.3
1398:  CALL   16C
1399:  BSF    0A.4
139A:  BCF    0A.3
139B:  MOVF   78,W
139C:  MOVWF  6D
....................    ds1307_save_ds(0,giay_ds);
139D:  CLRF   7B
139E:  MOVF   6D,W
139F:  MOVWF  7C
13A0:  BCF    0A.4
13A1:  BSF    0A.3
13A2:  CALL   1A7
13A3:  BSF    0A.4
13A4:  BCF    0A.3
.................... }
.................... void tang_phut(){
....................    if(phut_ds == 0x59) phut_ds = 0;
*
13A6:  MOVF   6E,W
13A7:  SUBLW  59
13A8:  BTFSS  03.2
13A9:  GOTO   3AC
13AA:  CLRF   6E
13AB:  GOTO   3B6
....................    else phut_ds = tang_or_giam_bcd(phut_ds, tang);
13AC:  MOVF   6E,W
13AD:  MOVWF  7B
13AE:  CLRF   7C
13AF:  BCF    0A.4
13B0:  BSF    0A.3
13B1:  CALL   16C
13B2:  BSF    0A.4
13B3:  BCF    0A.3
13B4:  MOVF   78,W
13B5:  MOVWF  6E
....................    ds1307_save_ds(1,phut_ds);
13B6:  MOVLW  01
13B7:  MOVWF  7B
13B8:  MOVF   6E,W
13B9:  MOVWF  7C
13BA:  BCF    0A.4
13BB:  BSF    0A.3
13BC:  CALL   1A7
13BD:  BSF    0A.4
13BE:  BCF    0A.3
.................... }
.................... void tang_gio(){
....................    if(gio_ds == 0x23) gio_ds = 0;
*
13C0:  MOVF   6F,W
13C1:  SUBLW  23
13C2:  BTFSS  03.2
13C3:  GOTO   3C6
13C4:  CLRF   6F
13C5:  GOTO   3D0
....................    else gio_ds = tang_or_giam_bcd(gio_ds, tang);
13C6:  MOVF   6F,W
13C7:  MOVWF  7B
13C8:  CLRF   7C
13C9:  BCF    0A.4
13CA:  BSF    0A.3
13CB:  CALL   16C
13CC:  BSF    0A.4
13CD:  BCF    0A.3
13CE:  MOVF   78,W
13CF:  MOVWF  6F
....................    ds1307_save_ds(2,gio_ds);
13D0:  MOVLW  02
13D1:  MOVWF  7B
13D2:  MOVF   6F,W
13D3:  MOVWF  7C
13D4:  BCF    0A.4
13D5:  BSF    0A.3
13D6:  CALL   1A7
13D7:  BSF    0A.4
13D8:  BCF    0A.3
.................... }
.................... void chinh_tang_gpg(){
....................    switch(gt_mod){
*
1382:  MOVF   35,W
1383:  XORLW  01
1384:  BTFSC  03.2
1385:  GOTO   38D
1386:  XORLW  03
1387:  BTFSC  03.2
1388:  GOTO   3A6
1389:  XORLW  01
138A:  BTFSC  03.2
138B:  GOTO   3C0
138C:  GOTO   3DA
....................       case 1:
....................          tang_giay();
....................          break;
*
13A5:  GOTO   3DB
....................       case 2:
....................          tang_phut();
....................          break;
*
13BF:  GOTO   3DB
....................       case 3:
....................          tang_gio();
....................          break;
*
13D9:  GOTO   3DB
....................       default: break;
13DA:  GOTO   3DB
....................    }
.................... }
.................... void tang_nam(){
....................    if(nam_ds == 0x99) nam_ds = 0;
*
13ED:  MOVF   73,W
13EE:  SUBLW  99
13EF:  BTFSS  03.2
13F0:  GOTO   3F3
13F1:  CLRF   73
13F2:  GOTO   3FD
....................    else nam_ds = tang_or_giam_bcd(nam_ds, tang);
13F3:  MOVF   73,W
13F4:  MOVWF  7B
13F5:  CLRF   7C
13F6:  BCF    0A.4
13F7:  BSF    0A.3
13F8:  CALL   16C
13F9:  BSF    0A.4
13FA:  BCF    0A.3
13FB:  MOVF   78,W
13FC:  MOVWF  73
....................    ds1307_save_ds(6,nam_ds);
13FD:  MOVLW  06
13FE:  MOVWF  7B
13FF:  MOVF   73,W
1400:  MOVWF  7C
1401:  BCF    0A.4
1402:  BSF    0A.3
1403:  CALL   1A7
1404:  BSF    0A.4
1405:  BCF    0A.3
.................... }
.................... void tang_thang(){
....................    if(thang_ds == 0x12) thang_ds = 1;
*
1407:  MOVF   72,W
1408:  SUBLW  12
1409:  BTFSS  03.2
140A:  GOTO   40E
140B:  MOVLW  01
140C:  MOVWF  72
140D:  GOTO   418
....................    else thang_ds = tang_or_giam_bcd(thang_ds, tang);
140E:  MOVF   72,W
140F:  MOVWF  7B
1410:  CLRF   7C
1411:  BCF    0A.4
1412:  BSF    0A.3
1413:  CALL   16C
1414:  BSF    0A.4
1415:  BCF    0A.3
1416:  MOVF   78,W
1417:  MOVWF  72
....................    ds1307_save_ds(5,thang_ds);
1418:  MOVLW  05
1419:  MOVWF  7B
141A:  MOVF   72,W
141B:  MOVWF  7C
141C:  BCF    0A.4
141D:  BSF    0A.3
141E:  CALL   1A7
141F:  BSF    0A.4
1420:  BCF    0A.3
.................... }
.................... void tang_ngay(){
....................    if(ngay_ds == 0x31) ngay_ds = 1;
*
1422:  MOVF   71,W
1423:  SUBLW  31
1424:  BTFSS  03.2
1425:  GOTO   429
1426:  MOVLW  01
1427:  MOVWF  71
1428:  GOTO   433
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, tang);
1429:  MOVF   71,W
142A:  MOVWF  7B
142B:  CLRF   7C
142C:  BCF    0A.4
142D:  BSF    0A.3
142E:  CALL   16C
142F:  BSF    0A.4
1430:  BCF    0A.3
1431:  MOVF   78,W
1432:  MOVWF  71
....................    ds1307_save_ds(4,ngay_ds);
1433:  MOVLW  04
1434:  MOVWF  7B
1435:  MOVF   71,W
1436:  MOVWF  7C
1437:  BCF    0A.4
1438:  BSF    0A.3
1439:  CALL   1A7
143A:  BSF    0A.4
143B:  BCF    0A.3
.................... }
.................... void chinh_tang_ntn(){
....................    switch(gt_mod){
*
13E2:  MOVF   35,W
13E3:  XORLW  04
13E4:  BTFSC  03.2
13E5:  GOTO   3ED
13E6:  XORLW  01
13E7:  BTFSC  03.2
13E8:  GOTO   407
13E9:  XORLW  03
13EA:  BTFSC  03.2
13EB:  GOTO   422
13EC:  GOTO   43D
....................       case 4:
....................          tang_nam();
....................          break;
*
1406:  GOTO   43E
....................       case 5:
....................          tang_thang();
....................          break;
*
1421:  GOTO   43E
....................       case 6:
....................          tang_ngay();
....................          break;
*
143C:  GOTO   43E
....................       default: break;
143D:  GOTO   43E
....................    }
.................... }
.................... void chinh_tang_thu(){
....................    if(thu_ds == 8) thu_ds = 2;
*
1443:  MOVF   70,W
1444:  SUBLW  08
1445:  BTFSS  03.2
1446:  GOTO   44A
1447:  MOVLW  02
1448:  MOVWF  70
1449:  GOTO   44B
....................    else thu_ds++;
144A:  INCF   70,F
....................    ds1307_save_ds(3,thu_ds);
144B:  MOVLW  03
144C:  MOVWF  7B
144D:  MOVF   70,W
144E:  MOVWF  7C
144F:  BCF    0A.4
1450:  BSF    0A.3
1451:  CALL   1A7
1452:  BSF    0A.4
1453:  BCF    0A.3
.................... }
.................... 
.................... void phim_up(){
....................    if(tick_btn(1, bt1)){
*
1371:  MOVLW  01
1372:  MOVWF  76
1373:  MOVLW  31
1374:  MOVWF  7B
1375:  BCF    0A.4
1376:  CALL   7D1
1377:  BSF    0A.4
1378:  MOVF   78,F
1379:  BTFSC  03.2
137A:  GOTO   45C
....................       tg_chinh = 0;
137B:  CLRF   36
....................       if(gt_mod<4) chinh_tang_gpg();
137C:  BTFSC  35.7
137D:  GOTO   382
137E:  MOVF   35,W
137F:  SUBLW  03
1380:  BTFSS  03.0
1381:  GOTO   3DC
*
13DB:  GOTO   454
....................       else if(gt_mod<7) chinh_tang_ntn();
13DC:  BTFSC  35.7
13DD:  GOTO   3E2
13DE:  MOVF   35,W
13DF:  SUBLW  06
13E0:  BTFSS  03.0
13E1:  GOTO   43F
*
143E:  GOTO   454
....................       else if(gt_mod==7) chinh_tang_thu();
143F:  MOVF   35,W
1440:  SUBLW  07
1441:  BTFSS  03.2
1442:  GOTO   454
....................       e_11 = true; e_22 = true; e_33 = true;
*
1454:  BSF    2C.3
1455:  BSF    2C.4
1456:  BSF    2C.5
....................       giai_ma_gpg_ntn_thu_lcd();
1457:  BCF    0A.4
1458:  BSF    0A.3
1459:  CALL   145
145A:  BSF    0A.4
145B:  BCF    0A.3
....................    }
.................... }
.................... void giam_giay(){
....................    if(giay_ds == 0) giay_ds = 0x59;
*
1478:  MOVF   6D,F
1479:  BTFSS  03.2
147A:  GOTO   47E
147B:  MOVLW  59
147C:  MOVWF  6D
147D:  GOTO   489
....................    else giay_ds = tang_or_giam_bcd(giay_ds,giam);
147E:  MOVF   6D,W
147F:  MOVWF  7B
1480:  MOVLW  01
1481:  MOVWF  7C
1482:  BCF    0A.4
1483:  BSF    0A.3
1484:  CALL   16C
1485:  BSF    0A.4
1486:  BCF    0A.3
1487:  MOVF   78,W
1488:  MOVWF  6D
....................    ds1307_save_ds(0,giay_ds);
1489:  CLRF   7B
148A:  MOVF   6D,W
148B:  MOVWF  7C
148C:  BCF    0A.4
148D:  BSF    0A.3
148E:  CALL   1A7
148F:  BSF    0A.4
1490:  BCF    0A.3
.................... }
.................... void giam_phut(){
....................    if(phut_ds == 0) phut_ds = 0x59;
*
1492:  MOVF   6E,F
1493:  BTFSS  03.2
1494:  GOTO   498
1495:  MOVLW  59
1496:  MOVWF  6E
1497:  GOTO   4A3
....................    else phut_ds = tang_or_giam_bcd(phut_ds,giam);
1498:  MOVF   6E,W
1499:  MOVWF  7B
149A:  MOVLW  01
149B:  MOVWF  7C
149C:  BCF    0A.4
149D:  BSF    0A.3
149E:  CALL   16C
149F:  BSF    0A.4
14A0:  BCF    0A.3
14A1:  MOVF   78,W
14A2:  MOVWF  6E
....................    ds1307_save_ds(1,phut_ds);
14A3:  MOVLW  01
14A4:  MOVWF  7B
14A5:  MOVF   6E,W
14A6:  MOVWF  7C
14A7:  BCF    0A.4
14A8:  BSF    0A.3
14A9:  CALL   1A7
14AA:  BSF    0A.4
14AB:  BCF    0A.3
.................... }
.................... void giam_gio(){
....................    if(gio_ds == 0) gio_ds = 0x23;
*
14AD:  MOVF   6F,F
14AE:  BTFSS  03.2
14AF:  GOTO   4B3
14B0:  MOVLW  23
14B1:  MOVWF  6F
14B2:  GOTO   4BE
....................    else gio_ds = tang_or_giam_bcd(gio_ds,giam);
14B3:  MOVF   6F,W
14B4:  MOVWF  7B
14B5:  MOVLW  01
14B6:  MOVWF  7C
14B7:  BCF    0A.4
14B8:  BSF    0A.3
14B9:  CALL   16C
14BA:  BSF    0A.4
14BB:  BCF    0A.3
14BC:  MOVF   78,W
14BD:  MOVWF  6F
....................    ds1307_save_ds(2,gio_ds);
14BE:  MOVLW  02
14BF:  MOVWF  7B
14C0:  MOVF   6F,W
14C1:  MOVWF  7C
14C2:  BCF    0A.4
14C3:  BSF    0A.3
14C4:  CALL   1A7
14C5:  BSF    0A.4
14C6:  BCF    0A.3
.................... }
.................... void chinh_giam_gpg(){
....................    switch(gt_mod){
*
146D:  MOVF   35,W
146E:  XORLW  01
146F:  BTFSC  03.2
1470:  GOTO   478
1471:  XORLW  03
1472:  BTFSC  03.2
1473:  GOTO   492
1474:  XORLW  01
1475:  BTFSC  03.2
1476:  GOTO   4AD
1477:  GOTO   4C8
....................       case 1:
....................          giam_giay();
....................          break;
*
1491:  GOTO   4C9
....................       case 2:
....................          giam_phut();
....................          break;
*
14AC:  GOTO   4C9
....................       case 3:
....................          giam_gio();
....................          break;
*
14C7:  GOTO   4C9
....................       default: break;
14C8:  GOTO   4C9
....................    }
.................... }
.................... void giam_nam(){
....................    if(nam_ds == 0x0) nam_ds = 0x99;
*
14DB:  MOVF   73,F
14DC:  BTFSS  03.2
14DD:  GOTO   4E1
14DE:  MOVLW  99
14DF:  MOVWF  73
14E0:  GOTO   4EC
....................    else nam_ds = tang_or_giam_bcd(nam_ds, giam);
14E1:  MOVF   73,W
14E2:  MOVWF  7B
14E3:  MOVLW  01
14E4:  MOVWF  7C
14E5:  BCF    0A.4
14E6:  BSF    0A.3
14E7:  CALL   16C
14E8:  BSF    0A.4
14E9:  BCF    0A.3
14EA:  MOVF   78,W
14EB:  MOVWF  73
....................    ds1307_save_ds(6,nam_ds);
14EC:  MOVLW  06
14ED:  MOVWF  7B
14EE:  MOVF   73,W
14EF:  MOVWF  7C
14F0:  BCF    0A.4
14F1:  BSF    0A.3
14F2:  CALL   1A7
14F3:  BSF    0A.4
14F4:  BCF    0A.3
.................... }
.................... void giam_thang(){
....................    if(thang_ds == 0x1) thang_ds = 12;
*
14F6:  DECFSZ 72,W
14F7:  GOTO   4FB
14F8:  MOVLW  0C
14F9:  MOVWF  72
14FA:  GOTO   506
....................    else thang_ds = tang_or_giam_bcd(thang_ds, giam);
14FB:  MOVF   72,W
14FC:  MOVWF  7B
14FD:  MOVLW  01
14FE:  MOVWF  7C
14FF:  BCF    0A.4
1500:  BSF    0A.3
1501:  CALL   16C
1502:  BSF    0A.4
1503:  BCF    0A.3
1504:  MOVF   78,W
1505:  MOVWF  72
....................    ds1307_save_ds(5,thang_ds);
1506:  MOVLW  05
1507:  MOVWF  7B
1508:  MOVF   72,W
1509:  MOVWF  7C
150A:  BCF    0A.4
150B:  BSF    0A.3
150C:  CALL   1A7
150D:  BSF    0A.4
150E:  BCF    0A.3
.................... }
.................... void giam_ngay(){
....................    if(ngay_ds == 0x1) ngay_ds = 21;
*
1510:  DECFSZ 71,W
1511:  GOTO   515
1512:  MOVLW  15
1513:  MOVWF  71
1514:  GOTO   520
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, giam);
1515:  MOVF   71,W
1516:  MOVWF  7B
1517:  MOVLW  01
1518:  MOVWF  7C
1519:  BCF    0A.4
151A:  BSF    0A.3
151B:  CALL   16C
151C:  BSF    0A.4
151D:  BCF    0A.3
151E:  MOVF   78,W
151F:  MOVWF  71
....................    ds1307_save_ds(4,ngay_ds);
1520:  MOVLW  04
1521:  MOVWF  7B
1522:  MOVF   71,W
1523:  MOVWF  7C
1524:  BCF    0A.4
1525:  BSF    0A.3
1526:  CALL   1A7
1527:  BSF    0A.4
1528:  BCF    0A.3
.................... }
.................... void chinh_giam_ntn(){
....................    switch(gt_mod){
*
14D0:  MOVF   35,W
14D1:  XORLW  01
14D2:  BTFSC  03.2
14D3:  GOTO   4DB
14D4:  XORLW  03
14D5:  BTFSC  03.2
14D6:  GOTO   4F6
14D7:  XORLW  01
14D8:  BTFSC  03.2
14D9:  GOTO   510
14DA:  GOTO   52A
....................       case 1:
....................          giam_nam();
....................          break;
*
14F5:  GOTO   52B
....................       case 2:
....................          giam_thang();
....................          break;
*
150F:  GOTO   52B
....................       case 3:
....................          giam_ngay();
....................          break;
*
1529:  GOTO   52B
....................       default: break;
152A:  GOTO   52B
....................    }
.................... }
.................... void chinh_giam_thu(){
....................    if(thu_ds == 2) thu_ds = 8;
*
1530:  MOVF   70,W
1531:  SUBLW  02
1532:  BTFSS  03.2
1533:  GOTO   537
1534:  MOVLW  08
1535:  MOVWF  70
1536:  GOTO   538
....................    else thu_ds--;
1537:  DECF   70,F
....................    ds1307_save_ds(3,thu_ds);
1538:  MOVLW  03
1539:  MOVWF  7B
153A:  MOVF   70,W
153B:  MOVWF  7C
153C:  BCF    0A.4
153D:  BSF    0A.3
153E:  CALL   1A7
153F:  BSF    0A.4
1540:  BCF    0A.3
.................... }
.................... void phim_dw(){
....................    if(tick_btn(1, bt2)){
*
145C:  MOVLW  01
145D:  MOVWF  76
145E:  MOVLW  32
145F:  MOVWF  7B
1460:  BCF    0A.4
1461:  CALL   7D1
1462:  BSF    0A.4
1463:  MOVF   78,F
1464:  BTFSC  03.2
1465:  GOTO   549
....................       tg_chinh = 0;
1466:  CLRF   36
....................       if(gt_mod<4) chinh_giam_gpg();
1467:  BTFSC  35.7
1468:  GOTO   46D
1469:  MOVF   35,W
146A:  SUBLW  03
146B:  BTFSS  03.0
146C:  GOTO   4CA
*
14C9:  GOTO   541
....................       else if(gt_mod<7) chinh_giam_ntn();
14CA:  BTFSC  35.7
14CB:  GOTO   4D0
14CC:  MOVF   35,W
14CD:  SUBLW  06
14CE:  BTFSS  03.0
14CF:  GOTO   52C
*
152B:  GOTO   541
....................       else if(gt_mod==7) chinh_giam_thu();
152C:  MOVF   35,W
152D:  SUBLW  07
152E:  BTFSS  03.2
152F:  GOTO   541
....................       e_11 = true; e_22 = true; e_33 = true;
*
1541:  BSF    2C.3
1542:  BSF    2C.4
1543:  BSF    2C.5
....................       giai_ma_gpg_ntn_thu_lcd();
1544:  BCF    0A.4
1545:  BSF    0A.3
1546:  CALL   145
1547:  BSF    0A.4
1548:  BCF    0A.3
....................    }
.................... }
.................... void log_mode(){
....................    lcd_setCursor(0, 1);
*
1567:  BSF    03.5
1568:  CLRF   35
1569:  MOVLW  01
156A:  MOVWF  36
156B:  BCF    0A.4
156C:  BCF    03.5
156D:  CALL   311
156E:  BSF    0A.4
....................    if(tt_ht == 0) lcd_data(" N ");
156F:  MOVF   34,F
1570:  BTFSS  03.2
1571:  GOTO   57C
1572:  MOVLW  DD
1573:  BSF    03.6
1574:  MOVWF  0D
1575:  MOVLW  00
1576:  MOVWF  0F
1577:  BCF    0A.4
1578:  BCF    03.6
1579:  CALL   34D
157A:  BSF    0A.4
157B:  GOTO   5A3
....................    else if(tt_ht == 1) lcd_data("GPG");
157C:  DECFSZ 34,W
157D:  GOTO   588
157E:  MOVLW  DF
157F:  BSF    03.6
1580:  MOVWF  0D
1581:  MOVLW  00
1582:  MOVWF  0F
1583:  BCF    0A.4
1584:  BCF    03.6
1585:  CALL   34D
1586:  BSF    0A.4
1587:  GOTO   5A3
....................    else if(tt_ht == 2) lcd_data("NTN");
1588:  MOVF   34,W
1589:  SUBLW  02
158A:  BTFSS  03.2
158B:  GOTO   596
158C:  MOVLW  E1
158D:  BSF    03.6
158E:  MOVWF  0D
158F:  MOVLW  00
1590:  MOVWF  0F
1591:  BCF    0A.4
1592:  BCF    03.6
1593:  CALL   34D
1594:  BSF    0A.4
1595:  GOTO   5A3
....................    else if(tt_ht == 3) lcd_data(" T ");
1596:  MOVF   34,W
1597:  SUBLW  03
1598:  BTFSS  03.2
1599:  GOTO   5A3
159A:  MOVLW  E3
159B:  BSF    03.6
159C:  MOVWF  0D
159D:  MOVLW  00
159E:  MOVWF  0F
159F:  BCF    0A.4
15A0:  BCF    03.6
15A1:  CALL   34D
15A2:  BSF    0A.4
....................    lcd_setCursor(13, 1);
15A3:  MOVLW  0D
15A4:  BSF    03.5
15A5:  MOVWF  35
15A6:  MOVLW  01
15A7:  MOVWF  36
15A8:  BCF    0A.4
15A9:  BCF    03.5
15AA:  CALL   311
15AB:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
15AC:  MOVLW  30
15AD:  ADDWF  35,W
15AE:  MOVWF  76
15AF:  BSF    03.5
15B0:  MOVWF  38
15B1:  BCF    0A.4
15B2:  BCF    03.5
15B3:  CALL   330
15B4:  BSF    0A.4
....................    if(gt_mod != 0){
15B5:  MOVF   35,F
15B6:  BTFSC  03.2
15B7:  GOTO   5DD
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
15B8:  MOVF   36,W
15B9:  MOVWF  7B
15BA:  MOVLW  0A
15BB:  MOVWF  7C
15BC:  BCF    0A.4
15BD:  BSF    0A.3
15BE:  CALL   1C5
15BF:  BSF    0A.4
15C0:  BCF    0A.3
15C1:  MOVLW  30
15C2:  ADDWF  78,W
15C3:  MOVWF  76
15C4:  BSF    03.5
15C5:  MOVWF  38
15C6:  BCF    0A.4
15C7:  BCF    03.5
15C8:  CALL   330
15C9:  BSF    0A.4
15CA:  MOVF   36,W
15CB:  MOVWF  7B
15CC:  MOVLW  0A
15CD:  MOVWF  7C
15CE:  BCF    0A.4
15CF:  BSF    0A.3
15D0:  CALL   1C5
15D1:  BSF    0A.4
15D2:  BCF    0A.3
15D3:  MOVLW  30
15D4:  ADDWF  77,W
15D5:  MOVWF  76
15D6:  BSF    03.5
15D7:  MOVWF  38
15D8:  BCF    0A.4
15D9:  BCF    03.5
15DA:  CALL   330
15DB:  BSF    0A.4
....................    }
15DC:  GOTO   5E6
....................    else
....................       lcd_data("__");
15DD:  MOVLW  E5
15DE:  BSF    03.6
15DF:  MOVWF  0D
15E0:  MOVLW  00
15E1:  MOVWF  0F
15E2:  BCF    0A.4
15E3:  BCF    03.6
15E4:  CALL   34D
15E5:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_change_alarm_eat.c>
.................... void giai_ma_gpg_alarm_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_eat,dec_phut_eat,dec_giay_eat,e_33, e_22, e_11);
*
09EA:  MOVF   37,W
09EB:  BSF    03.5
09EC:  MOVWF  23
09ED:  BCF    0A.3
09EE:  BCF    03.5
09EF:  CALL   607
09F0:  BSF    0A.3
09F1:  MOVF   78,W
09F2:  BSF    03.5
09F3:  MOVWF  20
09F4:  BCF    03.5
09F5:  MOVF   38,W
09F6:  BSF    03.5
09F7:  MOVWF  23
09F8:  BCF    0A.3
09F9:  BCF    03.5
09FA:  CALL   607
09FB:  BSF    0A.3
09FC:  MOVF   78,W
09FD:  BSF    03.5
09FE:  MOVWF  21
09FF:  BCF    03.5
0A00:  MOVF   39,W
0A01:  BSF    03.5
0A02:  MOVWF  23
0A03:  BCF    0A.3
0A04:  BCF    03.5
0A05:  CALL   607
0A06:  BSF    0A.3
0A07:  MOVF   78,W
0A08:  BSF    03.5
0A09:  MOVWF  22
0A0A:  MOVLW  00
0A0B:  BCF    03.5
0A0C:  BTFSC  2C.5
0A0D:  MOVLW  01
0A0E:  BSF    03.5
0A0F:  MOVWF  23
0A10:  MOVLW  00
0A11:  BCF    03.5
0A12:  BTFSC  2C.4
0A13:  MOVLW  01
0A14:  BSF    03.5
0A15:  MOVWF  24
0A16:  MOVLW  00
0A17:  BCF    03.5
0A18:  BTFSC  2C.3
0A19:  MOVLW  01
0A1A:  BSF    03.5
0A1B:  MOVWF  25
0A1C:  MOVLW  04
0A1D:  MOVWF  27
0A1E:  MOVLW  01
0A1F:  MOVWF  28
0A20:  MOVF   20,W
0A21:  MOVWF  29
0A22:  MOVF   21,W
0A23:  MOVWF  2A
0A24:  MOVF   22,W
0A25:  MOVWF  2B
0A26:  MOVF   23,W
0A27:  MOVWF  2C
0A28:  MOVF   24,W
0A29:  MOVWF  2D
0A2A:  MOVF   25,W
0A2B:  MOVWF  2E
0A2C:  BCF    0A.3
0A2D:  BCF    03.5
0A2E:  CALL   633
0A2F:  BSF    0A.3
0A30:  RETURN
.................... }
.................... void phim_chon_mode_alarm(){
....................    if(tick_btn(2, bt3)){
*
1604:  MOVLW  02
1605:  MOVWF  76
1606:  MOVLW  33
1607:  MOVWF  7B
1608:  BCF    0A.4
1609:  CALL   7D1
160A:  BSF    0A.4
160B:  MOVF   78,F
160C:  BTFSC  03.2
160D:  GOTO   61E
....................       if(gt_mod < 3) gt_mod++;
160E:  BTFSC  35.7
160F:  GOTO   614
1610:  MOVF   35,W
1611:  SUBLW  02
1612:  BTFSS  03.0
1613:  GOTO   616
1614:  INCF   35,F
1615:  GOTO   618
....................       else{
....................          gt_mod = 0;
1616:  CLRF   35
....................          countLevel = 0;
1617:  CLRF   3A
....................       }
....................       tg_chinh = 0;
1618:  CLRF   36
....................       giai_ma_gpg_alarm_lcd();
1619:  BCF    0A.4
161A:  BSF    0A.3
161B:  CALL   1EA
161C:  BSF    0A.4
161D:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay_eat(){
....................    if(eat_ss == 0x59) eat_ss = 0x00;
*
1634:  MOVF   39,W
1635:  SUBLW  59
1636:  BTFSS  03.2
1637:  GOTO   63A
1638:  CLRF   39
1639:  GOTO   644
....................    else eat_ss = tang_or_giam_bcd(eat_ss, tang);
163A:  MOVF   39,W
163B:  MOVWF  7B
163C:  CLRF   7C
163D:  BCF    0A.4
163E:  BSF    0A.3
163F:  CALL   16C
1640:  BSF    0A.4
1641:  BCF    0A.3
1642:  MOVF   78,W
1643:  MOVWF  39
.................... }
.................... void tang_phut_eat(){
....................    if(eat_pp == 0x59) eat_pp = 0x00;
*
1645:  MOVF   38,W
1646:  SUBLW  59
1647:  BTFSS  03.2
1648:  GOTO   64B
1649:  CLRF   38
164A:  GOTO   655
....................    else eat_pp = tang_or_giam_bcd(eat_pp, tang);
164B:  MOVF   38,W
164C:  MOVWF  7B
164D:  CLRF   7C
164E:  BCF    0A.4
164F:  BSF    0A.3
1650:  CALL   16C
1651:  BSF    0A.4
1652:  BCF    0A.3
1653:  MOVF   78,W
1654:  MOVWF  38
.................... }
.................... void tang_gio_eat(){
....................    if(eat_hh == 0x23) eat_hh = 0x00;
*
1656:  MOVF   37,W
1657:  SUBLW  23
1658:  BTFSS  03.2
1659:  GOTO   65C
165A:  CLRF   37
165B:  GOTO   666
....................    else eat_hh = tang_or_giam_bcd(eat_hh, tang);
165C:  MOVF   37,W
165D:  MOVWF  7B
165E:  CLRF   7C
165F:  BCF    0A.4
1660:  BSF    0A.3
1661:  CALL   16C
1662:  BSF    0A.4
1663:  BCF    0A.3
1664:  MOVF   78,W
1665:  MOVWF  37
.................... }
.................... void chinh_tang_gpg_eat(){
....................    switch(gt_mod){
*
1629:  MOVF   35,W
162A:  XORLW  01
162B:  BTFSC  03.2
162C:  GOTO   634
162D:  XORLW  03
162E:  BTFSC  03.2
162F:  GOTO   645
1630:  XORLW  01
1631:  BTFSC  03.2
1632:  GOTO   656
1633:  GOTO   667
....................       case 1:
....................          tang_giay_eat();
....................          break;
*
1644:  GOTO   668
....................       case 2:
....................          tang_phut_eat();
....................          break;
*
1655:  GOTO   668
....................       case 3:
....................          tang_gio_eat();
....................          break;
*
1666:  GOTO   668
....................       default: break;
1667:  GOTO   668
....................    }
.................... }
.................... 
.................... void phim_up_eat(){
....................    if(tick_btn(1, bt1)){
*
161E:  MOVLW  01
161F:  MOVWF  76
1620:  MOVLW  31
1621:  MOVWF  7B
1622:  BCF    0A.4
1623:  CALL   7D1
1624:  BSF    0A.4
1625:  MOVF   78,F
1626:  BTFSC  03.2
1627:  GOTO   670
....................       tg_chinh = 0;
1628:  CLRF   36
....................       chinh_tang_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
1668:  BSF    2C.3
1669:  BSF    2C.4
166A:  BSF    2C.5
....................       giai_ma_gpg_alarm_lcd();
166B:  BCF    0A.4
166C:  BSF    0A.3
166D:  CALL   1EA
166E:  BSF    0A.4
166F:  BCF    0A.3
....................    }
.................... }
.................... 
.................... void giam_giay_eat(){
....................    if(eat_ss == 0) eat_ss = 0x59;
*
1686:  MOVF   39,F
1687:  BTFSS  03.2
1688:  GOTO   68C
1689:  MOVLW  59
168A:  MOVWF  39
168B:  GOTO   697
....................    else eat_ss = tang_or_giam_bcd(eat_ss,giam);
168C:  MOVF   39,W
168D:  MOVWF  7B
168E:  MOVLW  01
168F:  MOVWF  7C
1690:  BCF    0A.4
1691:  BSF    0A.3
1692:  CALL   16C
1693:  BSF    0A.4
1694:  BCF    0A.3
1695:  MOVF   78,W
1696:  MOVWF  39
.................... }
.................... void giam_phut_eat(){
....................    if(eat_pp == 0) eat_pp = 0x59;
*
1698:  MOVF   38,F
1699:  BTFSS  03.2
169A:  GOTO   69E
169B:  MOVLW  59
169C:  MOVWF  38
169D:  GOTO   6A9
....................    else eat_pp = tang_or_giam_bcd(eat_pp,giam);
169E:  MOVF   38,W
169F:  MOVWF  7B
16A0:  MOVLW  01
16A1:  MOVWF  7C
16A2:  BCF    0A.4
16A3:  BSF    0A.3
16A4:  CALL   16C
16A5:  BSF    0A.4
16A6:  BCF    0A.3
16A7:  MOVF   78,W
16A8:  MOVWF  38
.................... }
.................... void giam_gio_eat(){
....................    if(eat_hh == 0) eat_hh = 0x23;
*
16AA:  MOVF   37,F
16AB:  BTFSS  03.2
16AC:  GOTO   6B0
16AD:  MOVLW  23
16AE:  MOVWF  37
16AF:  GOTO   6BB
....................    else eat_hh = tang_or_giam_bcd(eat_hh,giam);
16B0:  MOVF   37,W
16B1:  MOVWF  7B
16B2:  MOVLW  01
16B3:  MOVWF  7C
16B4:  BCF    0A.4
16B5:  BSF    0A.3
16B6:  CALL   16C
16B7:  BSF    0A.4
16B8:  BCF    0A.3
16B9:  MOVF   78,W
16BA:  MOVWF  37
.................... }
.................... void chinh_giam_gpg_eat(){
....................    switch(gt_mod){
*
167B:  MOVF   35,W
167C:  XORLW  01
167D:  BTFSC  03.2
167E:  GOTO   686
167F:  XORLW  03
1680:  BTFSC  03.2
1681:  GOTO   698
1682:  XORLW  01
1683:  BTFSC  03.2
1684:  GOTO   6AA
1685:  GOTO   6BC
....................       case 1:
....................          giam_giay_eat();
....................          break;
*
1697:  GOTO   6BD
....................       case 2:
....................          giam_phut_eat();
....................          break;
*
16A9:  GOTO   6BD
....................       case 3:
....................          giam_gio_eat();
....................          break;
*
16BB:  GOTO   6BD
....................       default: break;
16BC:  GOTO   6BD
....................    }
.................... }
.................... void phim_dw_eat(){
....................    if(tick_btn(1, bt2)){
*
1670:  MOVLW  01
1671:  MOVWF  76
1672:  MOVLW  32
1673:  MOVWF  7B
1674:  BCF    0A.4
1675:  CALL   7D1
1676:  BSF    0A.4
1677:  MOVF   78,F
1678:  BTFSC  03.2
1679:  GOTO   6C5
....................       tg_chinh = 0;
167A:  CLRF   36
....................       chinh_giam_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
16BD:  BSF    2C.3
16BE:  BSF    2C.4
16BF:  BSF    2C.5
....................       giai_ma_gpg_alarm_lcd();
16C0:  BCF    0A.4
16C1:  BSF    0A.3
16C2:  CALL   1EA
16C3:  BSF    0A.4
16C4:  BCF    0A.3
....................    }
.................... }
.................... void log_mode_alarm(){
....................    lcd_setCursor(13, 1);
*
16DC:  MOVLW  0D
16DD:  BSF    03.5
16DE:  MOVWF  35
16DF:  MOVLW  01
16E0:  MOVWF  36
16E1:  BCF    0A.4
16E2:  BCF    03.5
16E3:  CALL   311
16E4:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
16E5:  MOVLW  30
16E6:  ADDWF  35,W
16E7:  MOVWF  7B
16E8:  BSF    03.5
16E9:  MOVWF  38
16EA:  BCF    0A.4
16EB:  BCF    03.5
16EC:  CALL   330
16ED:  BSF    0A.4
....................    if(gt_mod != 0){
16EE:  MOVF   35,F
16EF:  BTFSC  03.2
16F0:  GOTO   716
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
16F1:  MOVF   36,W
16F2:  MOVWF  7B
16F3:  MOVLW  0A
16F4:  MOVWF  7C
16F5:  BCF    0A.4
16F6:  BSF    0A.3
16F7:  CALL   1C5
16F8:  BSF    0A.4
16F9:  BCF    0A.3
16FA:  MOVLW  30
16FB:  ADDWF  78,W
16FC:  MOVWF  7B
16FD:  BSF    03.5
16FE:  MOVWF  38
16FF:  BCF    0A.4
1700:  BCF    03.5
1701:  CALL   330
1702:  BSF    0A.4
1703:  MOVF   36,W
1704:  MOVWF  7B
1705:  MOVLW  0A
1706:  MOVWF  7C
1707:  BCF    0A.4
1708:  BSF    0A.3
1709:  CALL   1C5
170A:  BSF    0A.4
170B:  BCF    0A.3
170C:  MOVLW  30
170D:  ADDWF  77,W
170E:  MOVWF  7B
170F:  BSF    03.5
1710:  MOVWF  38
1711:  BCF    0A.4
1712:  BCF    03.5
1713:  CALL   330
1714:  BSF    0A.4
....................    }
1715:  GOTO   71F
....................    else
....................       lcd_data("__");
1716:  MOVLW  E7
1717:  BSF    03.6
1718:  MOVWF  0D
1719:  MOVLW  00
171A:  MOVWF  0F
171B:  BCF    0A.4
171C:  BCF    03.6
171D:  CALL   34D
171E:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_control_chiller.c>
.................... void control_temperature(int8 nd_ss, int8 gh){
....................    if(nd_ss > gh){
*
111C:  MOVF   76,W
111D:  SUBWF  7B,W
111E:  BTFSC  03.0
111F:  GOTO   123
....................    // water is hot
....................       output_bit(pinDLCold, 1);
1120:  BSF    08.6
....................       output_bit(pinDLHot,  0);
1121:  BCF    08.7
....................    }
1122:  GOTO   125
....................    else{
....................    // water is cold
....................       output_bit(pinDLCold, 0);
1123:  BCF    08.6
....................       output_bit(pinDLHot,  1);
1124:  BSF    08.7
....................    }
.................... }
.................... 
.................... void servo_degree_0(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
02F6:  CLRF   7B
02F7:  MOVF   7B,W
02F8:  SUBLW  31
02F9:  BTFSS  03.0
02FA:  GOTO   310
....................       output_bit(pinServo, 1);
02FB:  BSF    07.1
....................       Delay_us(800); // pulse of 800us
02FC:  MOVLW  04
02FD:  MOVWF  7C
02FE:  MOVLW  C7
02FF:  BSF    03.5
0300:  MOVWF  21
0301:  BCF    03.5
0302:  CALL   2E5
0303:  DECFSZ 7C,F
0304:  GOTO   2FE
....................       output_bit(pinServo, 0);
0305:  BCF    07.1
....................       Delay_us(19200);
0306:  MOVLW  13
0307:  MOVWF  7C
0308:  CALL   1DA
0309:  MOVLW  C8
030A:  BSF    03.5
030B:  MOVWF  21
030C:  BCF    03.5
030D:  CALL   2E5
030E:  INCF   7B,F
030F:  GOTO   2F7
....................    }
0310:  RETURN
.................... }
.................... 
.................... void servo_degree_90(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
1164:  CLRF   76
1165:  MOVF   76,W
1166:  SUBLW  31
1167:  BTFSS  03.0
1168:  GOTO   18D
....................       output_bit(pinServo, 1);
1169:  BSF    07.1
....................       Delay_us(1500); // pulse of 1500us
116A:  MOVLW  01
116B:  MOVWF  7C
116C:  BCF    0A.4
116D:  CALL   1DA
116E:  BSF    0A.4
116F:  MOVLW  02
1170:  MOVWF  7B
1171:  MOVLW  F9
1172:  BSF    03.5
1173:  MOVWF  21
1174:  BCF    0A.4
1175:  BCF    03.5
1176:  CALL   2E5
1177:  BSF    0A.4
1178:  DECFSZ 7B,F
1179:  GOTO   171
....................       output_bit(pinServo, 0);
117A:  BCF    07.1
....................       Delay_us(18500);
117B:  MOVLW  12
117C:  MOVWF  7C
117D:  BCF    0A.4
117E:  CALL   1DA
117F:  BSF    0A.4
1180:  MOVLW  02
1181:  MOVWF  7B
1182:  MOVLW  F9
1183:  BSF    03.5
1184:  MOVWF  21
1185:  BCF    0A.4
1186:  BCF    03.5
1187:  CALL   2E5
1188:  BSF    0A.4
1189:  DECFSZ 7B,F
118A:  GOTO   182
118B:  INCF   76,F
118C:  GOTO   165
....................    }
.................... }
.................... 
.................... void servo_degree_180(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
....................       output_bit(pinServo, 1);
....................       Delay_us(2200); // pulse of 2200us
....................       output_bit(pinServo, 0);
....................       Delay_us(17800);
....................    }
.................... }
.................... 
.................... void control_servo(){
....................    if(dec_gio_ds == dec_gio_eat && dec_phut_ds == dec_phut_eat && dec_giay_ds == dec_giay_eat){
*
1125:  MOVF   6F,W
1126:  BSF    03.5
1127:  MOVWF  23
1128:  BCF    0A.4
1129:  BCF    03.5
112A:  CALL   607
112B:  BSF    0A.4
112C:  MOVF   78,W
112D:  MOVWF  7B
112E:  MOVF   37,W
112F:  BSF    03.5
1130:  MOVWF  23
1131:  BCF    0A.4
1132:  BCF    03.5
1133:  CALL   607
1134:  BSF    0A.4
1135:  MOVF   78,W
1136:  SUBWF  7B,W
1137:  BTFSS  03.2
1138:  GOTO   162
1139:  MOVF   6E,W
113A:  BSF    03.5
113B:  MOVWF  23
113C:  BCF    0A.4
113D:  BCF    03.5
113E:  CALL   607
113F:  BSF    0A.4
1140:  MOVF   78,W
1141:  MOVWF  7B
1142:  MOVF   38,W
1143:  BSF    03.5
1144:  MOVWF  23
1145:  BCF    0A.4
1146:  BCF    03.5
1147:  CALL   607
1148:  BSF    0A.4
1149:  MOVF   78,W
114A:  SUBWF  7B,W
114B:  BTFSS  03.2
114C:  GOTO   162
114D:  MOVF   6D,W
114E:  BSF    03.5
114F:  MOVWF  23
1150:  BCF    0A.4
1151:  BCF    03.5
1152:  CALL   607
1153:  BSF    0A.4
1154:  MOVF   78,W
1155:  MOVWF  7B
1156:  MOVF   39,W
1157:  BSF    03.5
1158:  MOVWF  23
1159:  BCF    0A.4
115A:  BCF    03.5
115B:  CALL   607
115C:  BSF    0A.4
115D:  MOVF   78,W
115E:  SUBWF  7B,W
115F:  BTFSS  03.2
1160:  GOTO   162
....................       flag_servo = true;
1161:  BSF    2C.6
....................    }
....................    if(flag_servo){
1162:  BTFSS  2C.6
1163:  GOTO   18E
....................       servo_degree_90();
....................    }
*
118D:  GOTO   191
....................    else{
....................       servo_degree_0();
118E:  BCF    0A.4
118F:  CALL   2F6
1190:  BSF    0A.4
....................    }
.................... }
.................... 
.................... 
.................... #include <library_menu.c>
.................... 
.................... void menu(){
....................    if (push_btn(false,bt0)) countLevel++;
*
1075:  CLRF   76
1076:  MOVLW  30
1077:  MOVWF  7B
*
10AF:  MOVF   78,F
10B0:  BTFSC  03.2
10B1:  GOTO   0B3
10B2:  INCF   3A,F
.................... 
....................    if (countLevel >= maxLevel) countLevel = 0;
10B3:  MOVF   3A,W
10B4:  SUBLW  05
10B5:  BTFSC  03.0
10B6:  GOTO   0B8
10B7:  CLRF   3A
....................    
....................    if(countLevel != countLevelRev){
10B8:  MOVF   3B,W
10B9:  SUBWF  3A,W
10BA:  BTFSC  03.2
10BB:  GOTO   0C1
....................       countLevelRev = countLevel;
10BC:  MOVF   3A,W
10BD:  MOVWF  3B
....................       lcd_clear();
10BE:  BCF    0A.4
10BF:  CALL   267
10C0:  BSF    0A.4
....................    }
....................    
....................    switch(countLevel){
10C1:  MOVF   3A,W
10C2:  BTFSC  03.2
10C3:  GOTO   0D1
10C4:  XORLW  01
10C5:  BTFSC  03.2
10C6:  GOTO   2B7
10C7:  XORLW  03
10C8:  BTFSC  03.2
10C9:  GOTO   31E
10CA:  XORLW  01
10CB:  BTFSC  03.2
10CC:  GOTO   5E7
10CD:  XORLW  07
10CE:  BTFSC  03.2
10CF:  GOTO   720
10D0:  GOTO   756
....................       case 0:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
10D1:  MOVLW  08
10D2:  MOVWF  7B
10D3:  BCF    0A.4
10D4:  CALL   170
10D5:  BSF    0A.4
.................... 
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
10D6:  BCF    0A.4
10D7:  CALL   52E
10D8:  BSF    0A.4
.................... 
.................... //! display info rtc and temperature for user
....................          lcd_dis_xx_yy_zz(4,0,dec_gio_ds,dec_phut_ds,dec_giay_ds,1,1,1);
10D9:  MOVF   6F,W
10DA:  BSF    03.5
10DB:  MOVWF  23
10DC:  BCF    0A.4
10DD:  BCF    03.5
10DE:  CALL   607
10DF:  BSF    0A.4
10E0:  MOVF   78,W
10E1:  MOVWF  7B
10E2:  MOVF   6E,W
10E3:  BSF    03.5
10E4:  MOVWF  23
10E5:  BCF    0A.4
10E6:  BCF    03.5
10E7:  CALL   607
10E8:  BSF    0A.4
10E9:  MOVF   78,W
10EA:  MOVWF  7C
10EB:  MOVF   6D,W
10EC:  BSF    03.5
10ED:  MOVWF  23
10EE:  BCF    0A.4
10EF:  BCF    03.5
10F0:  CALL   607
10F1:  BSF    0A.4
10F2:  MOVF   78,W
10F3:  MOVWF  7D
10F4:  MOVLW  04
10F5:  BSF    03.5
10F6:  MOVWF  27
10F7:  CLRF   28
10F8:  MOVF   7B,W
10F9:  MOVWF  29
10FA:  MOVF   7C,W
10FB:  MOVWF  2A
10FC:  MOVF   78,W
10FD:  MOVWF  2B
10FE:  MOVLW  01
10FF:  MOVWF  2C
1100:  MOVWF  2D
1101:  MOVWF  2E
1102:  BCF    0A.4
1103:  BCF    03.5
1104:  CALL   633
1105:  BSF    0A.4
....................          lcd_dis_temperature(2,1,dt_ng,dt_tp);
1106:  MOVLW  02
1107:  MOVWF  7B
1108:  MOVLW  01
1109:  MOVWF  7C
110A:  CLRF   7E
110B:  MOVF   3F,W
110C:  MOVWF  7D
110D:  MOVF   41,W
110E:  BSF    03.5
110F:  MOVWF  21
1110:  BCF    03.5
1111:  MOVF   40,W
1112:  BSF    03.5
1113:  MOVWF  20
1114:  BCF    0A.4
1115:  BCF    03.5
1116:  CALL   70E
1117:  BSF    0A.4
.................... 
.................... //! control delay and servo
....................          control_temperature(dt_ng,limitTemperature);
1118:  MOVF   3F,W
1119:  MOVWF  76
111A:  MOVF   2D,W
111B:  MOVWF  7B
....................          control_servo();
....................          
....................          handle_uart();
....................          
....................          if(flag_10s == true){
*
1226:  BTFSS  2C.1
1227:  GOTO   2B6
....................             flag_10s = false;
1228:  BCF    2C.1
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:rt:", dt_ng);
1229:  MOVLW  E9
122A:  BSF    03.6
122B:  MOVWF  0D
122C:  MOVLW  00
122D:  MOVWF  0F
122E:  BCF    0A.4
122F:  BCF    03.6
1230:  CALL   3E7
1231:  BSF    0A.4
1232:  MOVF   3F,W
1233:  MOVWF  7E
1234:  MOVLW  18
1235:  BSF    03.5
1236:  MOVWF  20
1237:  BCF    0A.4
1238:  BSF    0A.3
1239:  BCF    03.5
123A:  CALL   000
123B:  BSF    0A.4
123C:  BCF    0A.3
123D:  MOVLW  0D
123E:  BTFSS  0C.4
123F:  GOTO   23E
1240:  MOVWF  19
1241:  MOVLW  0A
1242:  BTFSS  0C.4
1243:  GOTO   242
1244:  MOVWF  19
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:lt:", limitTemperature);
1245:  MOVLW  ED
1246:  BSF    03.6
1247:  MOVWF  0D
1248:  MOVLW  00
1249:  MOVWF  0F
124A:  BCF    0A.4
124B:  BCF    03.6
124C:  CALL   3E7
124D:  BSF    0A.4
124E:  MOVF   2D,W
124F:  MOVWF  7E
1250:  MOVLW  18
1251:  BSF    03.5
1252:  MOVWF  20
1253:  BCF    0A.4
1254:  BSF    0A.3
1255:  BCF    03.5
1256:  CALL   000
1257:  BSF    0A.4
1258:  BCF    0A.3
1259:  MOVLW  0D
125A:  BTFSS  0C.4
125B:  GOTO   25A
125C:  MOVWF  19
125D:  MOVLW  0A
125E:  BTFSS  0C.4
125F:  GOTO   25E
1260:  MOVWF  19
....................             fprintf(UART_STREAM, "%s%d-%d-%d\r\n", "dt:ra:", dec_gio_eat, dec_phut_eat, dec_giay_eat);
1261:  MOVF   37,W
1262:  BSF    03.5
1263:  MOVWF  23
1264:  BCF    0A.4
1265:  BCF    03.5
1266:  CALL   607
1267:  BSF    0A.4
1268:  MOVF   78,W
1269:  MOVWF  7B
126A:  MOVF   38,W
126B:  BSF    03.5
126C:  MOVWF  23
126D:  BCF    0A.4
126E:  BCF    03.5
126F:  CALL   607
1270:  BSF    0A.4
1271:  MOVF   78,W
1272:  MOVWF  7C
1273:  MOVF   39,W
1274:  BSF    03.5
1275:  MOVWF  23
1276:  BCF    0A.4
1277:  BCF    03.5
1278:  CALL   607
1279:  BSF    0A.4
127A:  MOVF   78,W
127B:  MOVWF  7D
127C:  MOVLW  F1
127D:  BSF    03.6
127E:  MOVWF  0D
127F:  MOVLW  00
1280:  MOVWF  0F
1281:  BCF    0A.4
1282:  BCF    03.6
1283:  CALL   3E7
1284:  BSF    0A.4
1285:  MOVF   7B,W
1286:  MOVWF  7E
1287:  MOVLW  18
1288:  BSF    03.5
1289:  MOVWF  20
128A:  BCF    0A.4
128B:  BSF    0A.3
128C:  BCF    03.5
128D:  CALL   000
128E:  BSF    0A.4
128F:  BCF    0A.3
1290:  MOVLW  2D
1291:  BTFSS  0C.4
1292:  GOTO   291
1293:  MOVWF  19
1294:  MOVF   7C,W
1295:  MOVWF  7E
1296:  MOVLW  18
1297:  BSF    03.5
1298:  MOVWF  20
1299:  BCF    0A.4
129A:  BSF    0A.3
129B:  BCF    03.5
129C:  CALL   000
129D:  BSF    0A.4
129E:  BCF    0A.3
129F:  MOVLW  2D
12A0:  BTFSS  0C.4
12A1:  GOTO   2A0
12A2:  MOVWF  19
12A3:  MOVF   7D,W
12A4:  MOVWF  7E
12A5:  MOVLW  18
12A6:  BSF    03.5
12A7:  MOVWF  20
12A8:  BCF    0A.4
12A9:  BSF    0A.3
12AA:  BCF    03.5
12AB:  CALL   000
12AC:  BSF    0A.4
12AD:  BCF    0A.3
12AE:  MOVLW  0D
12AF:  BTFSS  0C.4
12B0:  GOTO   2AF
12B1:  MOVWF  19
12B2:  MOVLW  0A
12B3:  BTFSS  0C.4
12B4:  GOTO   2B3
12B5:  MOVWF  19
....................          }
....................          break;
12B6:  GOTO   784
....................       case 1:
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
12B7:  BCF    0A.4
12B8:  CALL   52E
12B9:  BSF    0A.4
.................... 
.................... //! change limit temperature
....................          limitTemperature += tick_btn(1,bt2);
12BA:  MOVLW  01
12BB:  MOVWF  76
12BC:  MOVLW  32
12BD:  MOVWF  7B
12BE:  BCF    0A.4
12BF:  CALL   7D1
12C0:  BSF    0A.4
12C1:  MOVF   78,W
12C2:  ADDWF  2D,F
....................          limitTemperature -= tick_btn(1,bt1);
12C3:  MOVLW  01
12C4:  MOVWF  76
12C5:  MOVLW  31
12C6:  MOVWF  7B
12C7:  BCF    0A.4
12C8:  CALL   7D1
12C9:  BSF    0A.4
12CA:  MOVF   78,W
12CB:  SUBWF  2D,F
.................... 
.................... //! display info temperature limit and sensor
....................          lcd_dis_temperature(2,0,dt_ng,dt_tp);
12CC:  MOVLW  02
12CD:  MOVWF  7B
12CE:  CLRF   7C
12CF:  CLRF   7E
12D0:  MOVF   3F,W
12D1:  MOVWF  7D
12D2:  MOVF   41,W
12D3:  BSF    03.5
12D4:  MOVWF  21
12D5:  BCF    03.5
12D6:  MOVF   40,W
12D7:  BSF    03.5
12D8:  MOVWF  20
12D9:  BCF    0A.4
12DA:  BCF    03.5
12DB:  CALL   70E
12DC:  BSF    0A.4
....................          lcd_dis_temperature_limit(2,1,limitTemperature);
12DD:  MOVLW  02
12DE:  MOVWF  7B
12DF:  MOVLW  01
12E0:  MOVWF  7C
12E1:  CLRF   7E
12E2:  MOVF   2D,W
12E3:  MOVWF  7D
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
*
1312:  MOVLW  01
1313:  MOVWF  76
1314:  MOVLW  33
1315:  MOVWF  7B
1316:  BCF    0A.4
1317:  CALL   7D1
1318:  BSF    0A.4
1319:  MOVF   78,F
131A:  BTFSC  03.2
131B:  GOTO   31D
131C:  CLRF   3A
....................          
....................          break;
131D:  GOTO   784
....................       case 2:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
131E:  MOVLW  08
131F:  MOVWF  7B
1320:  BCF    0A.4
1321:  CALL   170
1322:  BSF    0A.4
.................... 
.................... //!
....................          lcd_setCursor(1,0);
1323:  MOVLW  01
1324:  BSF    03.5
1325:  MOVWF  35
1326:  CLRF   36
1327:  BCF    0A.4
1328:  BCF    03.5
1329:  CALL   311
132A:  BSF    0A.4
....................          lcd_data("cai dat dong ho");
132B:  MOVLW  F5
132C:  BSF    03.6
132D:  MOVWF  0D
132E:  MOVLW  00
132F:  MOVWF  0F
1330:  BCF    0A.4
1331:  BCF    03.6
1332:  CALL   34D
1333:  BSF    0A.4
....................          if(bdn < 5){
1334:  MOVF   33,W
1335:  SUBLW  04
1336:  BTFSS  03.0
1337:  GOTO   54A
....................             if(gt_mod != 0) xu_ly_choptat();
1338:  MOVF   35,F
1339:  BTFSC  03.2
133A:  GOTO   340
133B:  BCF    0A.4
133C:  BSF    0A.3
133D:  CALL   06B
133E:  BSF    0A.4
133F:  BCF    0A.3
....................             phim_chon_hthi_mode();
....................             phim_up();
....................             phim_dw();
....................          }
*
1549:  GOTO   562
....................          else if(bdn >= 10){
154A:  MOVF   33,W
154B:  SUBLW  09
154C:  BTFSC  03.0
154D:  GOTO   562
....................             bdn = 0;
154E:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
154F:  BTFSC  36.7
1550:  GOTO   555
1551:  MOVF   36,W
1552:  SUBLW  13
1553:  BTFSS  03.0
1554:  GOTO   557
1555:  INCF   36,F
1556:  GOTO   55C
....................             else{
....................                gt_mod = 0; tt_ht = 0;
1557:  CLRF   35
1558:  CLRF   34
....................                e_11 = true; e_22 = true; e_33 = true;
1559:  BSF    2C.3
155A:  BSF    2C.4
155B:  BSF    2C.5
....................             }
....................             if(giay_tam!=giay_ds){
155C:  MOVF   6D,W
155D:  SUBWF  32,W
155E:  BTFSC  03.2
155F:  GOTO   562
....................                giay_tam = giay_ds;
1560:  MOVF   6D,W
1561:  MOVWF  32
....................             }
....................          }
....................          giai_ma_gpg_ntn_thu_lcd();
1562:  BCF    0A.4
1563:  BSF    0A.3
1564:  CALL   145
1565:  BSF    0A.4
1566:  BCF    0A.3
....................          log_mode();
....................          break;
*
15E6:  GOTO   784
....................       case 3:
....................          lcd_setCursor(1,0);
15E7:  MOVLW  01
15E8:  BSF    03.5
15E9:  MOVWF  35
15EA:  CLRF   36
15EB:  BCF    0A.4
15EC:  BCF    03.5
15ED:  CALL   311
15EE:  BSF    0A.4
....................          lcd_data("t/g cho ca an");
15EF:  MOVLW  FD
15F0:  BSF    03.6
15F1:  MOVWF  0D
15F2:  MOVLW  00
15F3:  MOVWF  0F
15F4:  BCF    0A.4
15F5:  BCF    03.6
15F6:  CALL   34D
15F7:  BSF    0A.4
....................          if(bdn < 5){
15F8:  MOVF   33,W
15F9:  SUBLW  04
15FA:  BTFSS  03.0
15FB:  GOTO   6C6
....................             if(gt_mod != 0) xu_ly_choptat();
15FC:  MOVF   35,F
15FD:  BTFSC  03.2
15FE:  GOTO   604
15FF:  BCF    0A.4
1600:  BSF    0A.3
1601:  CALL   06B
1602:  BSF    0A.4
1603:  BCF    0A.3
....................             phim_chon_mode_alarm();
....................             phim_up_eat();
....................             phim_dw_eat();
....................          }
*
16C5:  GOTO   6D7
....................          else if(bdn >= 10){
16C6:  MOVF   33,W
16C7:  SUBLW  09
16C8:  BTFSC  03.0
16C9:  GOTO   6D7
....................             bdn = 0;
16CA:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
16CB:  BTFSC  36.7
16CC:  GOTO   6D1
16CD:  MOVF   36,W
16CE:  SUBLW  13
16CF:  BTFSS  03.0
16D0:  GOTO   6D3
16D1:  INCF   36,F
16D2:  GOTO   6D7
....................             else{
....................                gt_mod = 0;
16D3:  CLRF   35
....................                e_11 = true; e_22 = true; e_33 = true;
16D4:  BSF    2C.3
16D5:  BSF    2C.4
16D6:  BSF    2C.5
....................             }
....................          }
....................          giai_ma_gpg_alarm_lcd();
16D7:  BCF    0A.4
16D8:  BSF    0A.3
16D9:  CALL   1EA
16DA:  BSF    0A.4
16DB:  BCF    0A.3
....................          log_mode_alarm();
....................          break;
*
171F:  GOTO   784
....................       case 4:
....................          lcd_setCursor(1,0);
1720:  MOVLW  01
1721:  BSF    03.5
1722:  MOVWF  35
1723:  CLRF   36
1724:  BCF    0A.4
1725:  BCF    03.5
1726:  CALL   311
1727:  BSF    0A.4
....................          lcd_data("check com esp");
1728:  MOVLW  04
1729:  BSF    03.6
172A:  MOVWF  0D
172B:  MOVLW  01
172C:  MOVWF  0F
172D:  BCF    0A.4
172E:  BCF    03.6
172F:  CALL   34D
1730:  BSF    0A.4
....................          lcd_setCursor(1,1);
1731:  MOVLW  01
1732:  BSF    03.5
1733:  MOVWF  35
1734:  MOVWF  36
1735:  BCF    0A.4
1736:  BCF    03.5
1737:  CALL   311
1738:  BSF    0A.4
....................          lcd_data(indexComplete + 0x30);
1739:  MOVLW  30
173A:  ADDWF  58,W
173B:  MOVWF  7B
173C:  BSF    03.5
173D:  MOVWF  38
173E:  BCF    0A.4
173F:  BCF    03.5
1740:  CALL   330
1741:  BSF    0A.4
....................          if (stringComplete) {
1742:  MOVF   57,F
1743:  BTFSC  03.2
1744:  GOTO   74A
....................             stringComplete = 0;
1745:  CLRF   57
....................             index = 0;
1746:  CLRF   56
....................             lcd_clear();
1747:  BCF    0A.4
1748:  CALL   267
1749:  BSF    0A.4
.................... 
.................... //!            if(!strncmp(ledon, receivedString, 2)){
.................... //!               output_bit(ledTest,1);
.................... //!            }
.................... //!            else{
.................... //!               output_bit(ledTest,0);
.................... //!            }
....................          }
....................          if(tick_btn(1,bt3)) countLevel = 0;
174A:  MOVLW  01
174B:  MOVWF  76
174C:  MOVLW  33
174D:  MOVWF  7B
174E:  BCF    0A.4
174F:  CALL   7D1
1750:  BSF    0A.4
1751:  MOVF   78,F
1752:  BTFSC  03.2
1753:  GOTO   755
1754:  CLRF   3A
....................          break;
1755:  GOTO   784
....................       default:
....................          lcd_setCursor(2,0);
1756:  MOVLW  02
1757:  BSF    03.5
1758:  MOVWF  35
1759:  CLRF   36
175A:  BCF    0A.4
175B:  BCF    03.5
175C:  CALL   311
175D:  BSF    0A.4
....................          lcd_data("Information");
175E:  MOVLW  0B
175F:  BSF    03.6
1760:  MOVWF  0D
1761:  MOVLW  01
1762:  MOVWF  0F
1763:  BCF    0A.4
1764:  BCF    03.6
1765:  CALL   34D
1766:  BSF    0A.4
....................          lcd_setCursor(0,1);
1767:  BSF    03.5
1768:  CLRF   35
1769:  MOVLW  01
176A:  MOVWF  36
176B:  BCF    0A.4
176C:  BCF    03.5
176D:  CALL   311
176E:  BSF    0A.4
....................          lcd_data("Version: V1.0.0");
176F:  MOVLW  11
1770:  BSF    03.6
1771:  MOVWF  0D
1772:  MOVLW  01
1773:  MOVWF  0F
1774:  BCF    0A.4
1775:  BCF    03.6
1776:  CALL   34D
1777:  BSF    0A.4
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
1778:  MOVLW  01
1779:  MOVWF  76
177A:  MOVLW  33
177B:  MOVWF  7B
177C:  BCF    0A.4
177D:  CALL   7D1
177E:  BSF    0A.4
177F:  MOVF   78,F
1780:  BTFSC  03.2
1781:  GOTO   783
1782:  CLRF   3A
....................          break;
1783:  GOTO   784
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void loop(){
.................... //! function to access for change limit temperature, change time for time rtc, change time clock for eat fish, check com with esp, log version sys
....................    menu();
.................... }
.................... 
.................... void main(){
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2B
1005:  BSF    2B.3
1006:  MOVF   2B,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2B.4
100B:  MOVF   2B,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  31
100F:  MOVWF  13
1010:  MOVLW  28
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    14.7
1015:  BCF    14.6
1016:  MOVLW  81
1017:  MOVWF  19
1018:  MOVLW  A6
1019:  MOVWF  18
101A:  MOVLW  90
101B:  BCF    03.5
101C:  MOVWF  18
101D:  BCF    2C.0
101E:  BCF    2C.1
101F:  BCF    2C.2
1020:  MOVLW  19
1021:  MOVWF  2D
1022:  CLRF   34
1023:  CLRF   35
1024:  CLRF   36
1025:  CLRF   3A
1026:  CLRF   3B
1027:  CLRF   3C
1028:  CLRF   56
1029:  CLRF   57
102A:  CLRF   58
102B:  CLRF   5A
102C:  CLRF   59
102D:  CLRF   5B
102E:  CLRF   5C
102F:  BSF    03.5
1030:  BSF    1F.0
1031:  BSF    1F.1
1032:  BSF    1F.2
1033:  BCF    1F.3
1034:  MOVLW  07
1035:  MOVWF  1C
1036:  BCF    03.7
.................... 
.................... //! setup enviroments
....................    setup_initialize();
*
105D:  BCF    0A.4
105E:  GOTO   125
105F:  BSF    0A.4
....................    
.................... //! setup ds1307 rtc
....................    ds1307_setup();
1060:  BCF    0A.4
1061:  GOTO   19E
1062:  BSF    0A.4
.................... 
.................... //! setup lcd display
....................    lcd_setup();
1063:  BCF    0A.4
1064:  GOTO   270
1065:  BSF    0A.4
.................... 
.................... //! setup servo initialize is 0 degree
....................    servo_degree_0();
1066:  BCF    0A.4
1067:  CALL   2F6
1068:  BSF    0A.4
.................... 
.................... //! display info include: name project and name university
....................    log_lcd_initialize();
1069:  BCF    0A.4
106A:  GOTO   3C1
106B:  BSF    0A.4
....................    
....................    printf("Hello from PIC16F877A!");
106C:  MOVLW  19
106D:  BSF    03.6
106E:  MOVWF  0D
106F:  MOVLW  01
1070:  MOVWF  0F
1071:  BCF    0A.4
1072:  BCF    03.6
1073:  CALL   3E7
1074:  BSF    0A.4
....................    
....................    while(true){
.................... //! loop function is function suport in process of system
....................       loop();
*
1784:  GOTO   075
....................    }
.................... }
1785:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
