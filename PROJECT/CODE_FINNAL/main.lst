CCS PCM C Compiler, Version 5.115, 43599               18-Jun-24 09:23

               Filename:   E:\STUDY\HKII-2023-2024\DO_AN_1\PROJECT\CODE_FINNAL\main.lst

               ROM used:   4568 words (56%)
                           Largest free fragment is 2048
               RAM used:   92 (25%) at main() level
                           141 (38%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   05A
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   090
.................... #include <library_project.c>
.................... /*
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
....................                        SU PHAM KY THUAT - TP.HCM
....................  DO AN 1 - HIEU CHINH NHIET DO HO CA VA CHO CA AN TU DONG - KET NOI ESP
.................... 
....................    THANH VIEN:
....................       VO MINH THUAN   - 21161366
....................       LE QUANG THUONG - 21161367
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... */
.................... #include <define_pic16f.c>
.................... //! config mode to operation of pic16f877a
.................... #include <16f877a.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
008C:  DATA F3,39
008D:  DATA BA,37
008E:  DATA EB,06
008F:  DATA 0A,00
*
00DE:  DATA C4,37
00DF:  DATA A0,30
00E0:  DATA 6E,10
00E1:  DATA 31,10
00E2:  DATA 2D,10
00E3:  DATA C8,25
00E4:  DATA C9,24
00E5:  DATA 00,00
00E6:  DATA 53,28
00E7:  DATA 4B,2A
00E8:  DATA 2D,2A
00E9:  DATA 50,24
00EA:  DATA C3,26
00EB:  DATA 00,00
00EC:  DATA 2D,00
00ED:  DATA 2D,00
00EE:  DATA 2E,00
00EF:  DATA 2E,00
00F0:  DATA 4E,22
00F1:  DATA 3A,10
00F2:  DATA 00,01
00F3:  DATA A0,37
00F4:  DATA 43,00
00F5:  DATA 4E,22
00F6:  DATA AD,23
00F7:  DATA 48,1D
00F8:  DATA 20,00
00F9:  DATA A0,37
00FA:  DATA 43,00
00FB:  DATA 20,27
00FC:  DATA 20,00
00FD:  DATA 47,28
00FE:  DATA 47,00
00FF:  DATA 4E,2A
0100:  DATA 4E,00
0101:  DATA 20,2A
0102:  DATA 20,00
0103:  DATA DF,2F
0104:  DATA 00,00
0105:  DATA DF,2F
0106:  DATA 00,00
0107:  DATA 64,3A
0108:  DATA 3A,39
0109:  DATA 74,1D
010A:  DATA 00,10
010B:  DATA 64,3A
010C:  DATA 3A,36
010D:  DATA 74,1D
010E:  DATA 00,01
010F:  DATA 64,3A
0110:  DATA 3A,39
0111:  DATA 61,1D
0112:  DATA 00,01
0113:  DATA E3,30
0114:  DATA 69,10
0115:  DATA E4,30
0116:  DATA 74,10
0117:  DATA E4,37
0118:  DATA EE,33
0119:  DATA 20,34
011A:  DATA 6F,00
011B:  DATA F4,17
011C:  DATA 67,10
011D:  DATA 63,34
011E:  DATA 6F,10
011F:  DATA E3,30
0120:  DATA A0,30
0121:  DATA 6E,00
0122:  DATA 63,34
0123:  DATA E5,31
0124:  DATA 6B,10
0125:  DATA E3,37
0126:  DATA 6D,10
0127:  DATA E5,39
0128:  DATA 70,00
0129:  DATA 49,37
012A:  DATA E6,37
012B:  DATA F2,36
012C:  DATA 61,3A
012D:  DATA E9,37
012E:  DATA 6E,00
012F:  DATA D6,32
0130:  DATA F2,39
0131:  DATA E9,37
0132:  DATA 6E,1D
0133:  DATA 20,2B
0134:  DATA 31,17
0135:  DATA 30,17
0136:  DATA 30,00
0137:  DATA C8,32
0138:  DATA 6C,36
0139:  DATA 6F,10
013A:  DATA 66,39
013B:  DATA EF,36
013C:  DATA 20,28
013D:  DATA C9,21
013E:  DATA 31,1B
013F:  DATA 46,1C
0140:  DATA B7,1B
0141:  DATA C1,10
0142:  DATA 0D,05
0143:  DATA 00,00
*
036C:  MOVF   0B,W
036D:  BSF    03.5
036E:  MOVWF  34
036F:  BCF    03.5
0370:  BCF    0B.7
0371:  BSF    03.5
0372:  BSF    03.6
0373:  BSF    0C.7
0374:  BSF    0C.0
0375:  NOP
0376:  NOP
0377:  BCF    03.6
0378:  BTFSS  34.7
0379:  GOTO   37D
037A:  BCF    03.5
037B:  BSF    0B.7
037C:  BSF    03.5
037D:  BCF    03.5
037E:  BSF    03.6
037F:  MOVF   0C,W
0380:  ANDLW  7F
0381:  BTFSC  03.2
0382:  GOTO   3DE
0383:  BSF    03.5
0384:  BCF    03.6
0385:  MOVWF  34
0386:  BCF    03.5
0387:  BSF    03.6
0388:  MOVF   0D,W
0389:  BSF    03.5
038A:  BCF    03.6
038B:  MOVWF  35
038C:  BCF    03.5
038D:  BSF    03.6
038E:  MOVF   0F,W
038F:  BSF    03.5
0390:  BCF    03.6
0391:  MOVWF  36
0392:  MOVF   34,W
0393:  MOVWF  37
0394:  BCF    03.5
0395:  CALL   34F
0396:  BSF    03.5
0397:  MOVF   35,W
0398:  BCF    03.5
0399:  BSF    03.6
039A:  MOVWF  0D
039B:  BSF    03.5
039C:  BCF    03.6
039D:  MOVF   36,W
039E:  BCF    03.5
039F:  BSF    03.6
03A0:  MOVWF  0F
03A1:  BCF    03.6
03A2:  MOVF   0B,W
03A3:  BSF    03.5
03A4:  MOVWF  37
03A5:  BCF    03.5
03A6:  BCF    0B.7
03A7:  BSF    03.5
03A8:  BSF    03.6
03A9:  BSF    0C.7
03AA:  BSF    0C.0
03AB:  NOP
03AC:  NOP
03AD:  BCF    03.6
03AE:  BTFSS  37.7
03AF:  GOTO   3B3
03B0:  BCF    03.5
03B1:  BSF    0B.7
03B2:  BSF    03.5
03B3:  BCF    03.5
03B4:  BSF    03.6
03B5:  RLF    0C,W
03B6:  RLF    0E,W
03B7:  ANDLW  7F
03B8:  BTFSC  03.2
03B9:  GOTO   3DE
03BA:  BSF    03.5
03BB:  BCF    03.6
03BC:  MOVWF  34
03BD:  BCF    03.5
03BE:  BSF    03.6
03BF:  MOVF   0D,W
03C0:  BSF    03.5
03C1:  BCF    03.6
03C2:  MOVWF  35
03C3:  BCF    03.5
03C4:  BSF    03.6
03C5:  MOVF   0F,W
03C6:  BSF    03.5
03C7:  BCF    03.6
03C8:  MOVWF  36
03C9:  MOVF   34,W
03CA:  MOVWF  37
03CB:  BCF    03.5
03CC:  CALL   34F
03CD:  BSF    03.5
03CE:  MOVF   35,W
03CF:  BCF    03.5
03D0:  BSF    03.6
03D1:  MOVWF  0D
03D2:  BSF    03.5
03D3:  BCF    03.6
03D4:  MOVF   36,W
03D5:  BCF    03.5
03D6:  BSF    03.6
03D7:  MOVWF  0F
03D8:  INCF   0D,F
03D9:  BTFSC  03.2
03DA:  INCF   0F,F
03DB:  BCF    03.6
03DC:  GOTO   36C
03DD:  BSF    03.6
03DE:  BCF    03.6
03DF:  RETURN
*
0406:  MOVF   0B,W
0407:  BSF    03.5
0408:  MOVWF  20
0409:  BCF    03.5
040A:  BCF    0B.7
040B:  BSF    03.5
040C:  BSF    03.6
040D:  BSF    0C.7
040E:  BSF    0C.0
040F:  NOP
0410:  NOP
0411:  BCF    03.6
0412:  BTFSS  20.7
0413:  GOTO   417
0414:  BCF    03.5
0415:  BSF    0B.7
0416:  BSF    03.5
0417:  BCF    03.5
0418:  BSF    03.6
0419:  MOVF   0C,W
041A:  ANDLW  7F
041B:  BTFSC  03.2
041C:  GOTO   47A
041D:  BSF    03.5
041E:  BCF    03.6
041F:  MOVWF  20
0420:  BCF    03.5
0421:  BSF    03.6
0422:  MOVF   0D,W
0423:  BSF    03.5
0424:  BCF    03.6
0425:  MOVWF  21
0426:  BCF    03.5
0427:  BSF    03.6
0428:  MOVF   0F,W
0429:  BSF    03.5
042A:  BCF    03.6
042B:  MOVWF  22
042C:  MOVF   20,W
042D:  BCF    03.5
042E:  BTFSS  0C.4
042F:  GOTO   42E
0430:  MOVWF  19
0431:  BSF    03.5
0432:  MOVF   21,W
0433:  BCF    03.5
0434:  BSF    03.6
0435:  MOVWF  0D
0436:  BSF    03.5
0437:  BCF    03.6
0438:  MOVF   22,W
0439:  BCF    03.5
043A:  BSF    03.6
043B:  MOVWF  0F
043C:  BCF    03.6
043D:  MOVF   0B,W
043E:  BSF    03.5
043F:  MOVWF  23
0440:  BCF    03.5
0441:  BCF    0B.7
0442:  BSF    03.5
0443:  BSF    03.6
0444:  BSF    0C.7
0445:  BSF    0C.0
0446:  NOP
0447:  NOP
0448:  BCF    03.6
0449:  BTFSS  23.7
044A:  GOTO   44E
044B:  BCF    03.5
044C:  BSF    0B.7
044D:  BSF    03.5
044E:  BCF    03.5
044F:  BSF    03.6
0450:  RLF    0C,W
0451:  RLF    0E,W
0452:  ANDLW  7F
0453:  BTFSC  03.2
0454:  GOTO   47A
0455:  BSF    03.5
0456:  BCF    03.6
0457:  MOVWF  20
0458:  BCF    03.5
0459:  BSF    03.6
045A:  MOVF   0D,W
045B:  BSF    03.5
045C:  BCF    03.6
045D:  MOVWF  21
045E:  BCF    03.5
045F:  BSF    03.6
0460:  MOVF   0F,W
0461:  BSF    03.5
0462:  BCF    03.6
0463:  MOVWF  22
0464:  MOVF   20,W
0465:  BCF    03.5
0466:  BTFSS  0C.4
0467:  GOTO   466
0468:  MOVWF  19
0469:  BSF    03.5
046A:  MOVF   21,W
046B:  BCF    03.5
046C:  BSF    03.6
046D:  MOVWF  0D
046E:  BSF    03.5
046F:  BCF    03.6
0470:  MOVF   22,W
0471:  BCF    03.5
0472:  BSF    03.6
0473:  MOVWF  0F
0474:  INCF   0D,F
0475:  BTFSC  03.2
0476:  INCF   0F,F
0477:  BCF    03.6
0478:  GOTO   406
0479:  BSF    03.6
047A:  BCF    03.6
047B:  RETURN
047C:  MOVF   7D,W
047D:  ANDLW  07
047E:  MOVWF  77
047F:  RRF    7D,W
0480:  MOVWF  78
0481:  RRF    78,F
0482:  RRF    78,F
0483:  MOVLW  1F
0484:  ANDWF  78,F
0485:  MOVF   78,W
0486:  BSF    03.5
0487:  ADDWF  20,W
0488:  MOVWF  04
0489:  BCF    03.7
048A:  BTFSC  21.0
048B:  BSF    03.7
048C:  MOVF   00,W
048D:  MOVWF  78
048E:  INCF   77,F
048F:  GOTO   491
0490:  RRF    78,F
0491:  DECFSZ 77,F
0492:  GOTO   490
0493:  MOVLW  01
0494:  ANDWF  78,F
0495:  BCF    03.5
0496:  RETURN
*
0526:  CLRF   78
0527:  CLRF   79
0528:  CLRF   77
0529:  CLRF   7A
052A:  BSF    03.5
052B:  MOVF   31,W
052C:  BTFSS  03.2
052D:  GOTO   531
052E:  MOVF   30,W
052F:  BTFSC  03.2
0530:  GOTO   54B
0531:  MOVLW  10
0532:  MOVWF  32
0533:  BCF    03.0
0534:  RLF    2E,F
0535:  RLF    2F,F
0536:  RLF    77,F
0537:  RLF    7A,F
0538:  MOVF   31,W
0539:  SUBWF  7A,W
053A:  BTFSS  03.2
053B:  GOTO   53E
053C:  MOVF   30,W
053D:  SUBWF  77,W
053E:  BTFSS  03.0
053F:  GOTO   547
0540:  MOVF   30,W
0541:  SUBWF  77,F
0542:  BTFSS  03.0
0543:  DECF   7A,F
0544:  MOVF   31,W
0545:  SUBWF  7A,F
0546:  BSF    03.0
0547:  RLF    78,F
0548:  RLF    79,F
0549:  DECFSZ 32,F
054A:  GOTO   533
054B:  BCF    03.5
054C:  RETURN
*
05D6:  MOVLW  10
05D7:  BSF    03.5
05D8:  MOVWF  20
05D9:  CLRF   77
05DA:  CLRF   7A
05DB:  RRF    7C,F
05DC:  RRF    7B,F
05DD:  BTFSS  03.0
05DE:  GOTO   5E5
05DF:  MOVF   7D,W
05E0:  ADDWF  77,F
05E1:  BTFSC  03.0
05E2:  INCF   7A,F
05E3:  MOVF   7E,W
05E4:  ADDWF  7A,F
05E5:  RRF    7A,F
05E6:  RRF    77,F
05E7:  RRF    79,F
05E8:  RRF    78,F
05E9:  DECFSZ 20,F
05EA:  GOTO   5DB
*
05FF:  CLRF   77
0600:  CLRF   78
0601:  BSF    03.5
0602:  MOVF   25,W
0603:  BCF    03.0
0604:  BTFSC  26.0
0605:  ADDWF  77,F
0606:  RRF    77,F
0607:  RRF    78,F
0608:  BTFSC  26.1
0609:  ADDWF  77,F
060A:  RRF    77,F
060B:  RRF    78,F
060C:  BTFSC  26.2
060D:  ADDWF  77,F
060E:  RRF    77,F
060F:  RRF    78,F
0610:  BTFSC  26.3
0611:  ADDWF  77,F
0612:  RRF    77,F
0613:  RRF    78,F
0614:  BTFSC  26.4
0615:  ADDWF  77,F
0616:  RRF    77,F
0617:  RRF    78,F
0618:  BTFSC  26.5
0619:  ADDWF  77,F
061A:  RRF    77,F
061B:  RRF    78,F
061C:  BTFSC  26.6
061D:  ADDWF  77,F
061E:  RRF    77,F
061F:  RRF    78,F
0620:  BTFSC  26.7
0621:  ADDWF  77,F
0622:  RRF    77,F
0623:  RRF    78,F
0624:  BCF    03.5
0625:  RETURN
*
063B:  BSF    03.5
063C:  MOVF   35,W
063D:  CLRF   78
063E:  SUBWF  34,W
063F:  BTFSC  03.0
0640:  GOTO   644
0641:  MOVF   34,W
0642:  MOVWF  77
0643:  GOTO   650
0644:  CLRF   77
0645:  MOVLW  08
0646:  MOVWF  36
0647:  RLF    34,F
0648:  RLF    77,F
0649:  MOVF   35,W
064A:  SUBWF  77,W
064B:  BTFSC  03.0
064C:  MOVWF  77
064D:  RLF    78,F
064E:  DECFSZ 36,F
064F:  GOTO   647
0650:  BCF    03.5
0651:  RETURN
*
0800:  MOVLW  20
0801:  BSF    03.5
0802:  BTFSS  20.4
0803:  MOVLW  30
0804:  MOVWF  21
0805:  MOVF   7E,W
0806:  MOVWF  77
0807:  BTFSS  7E.7
0808:  GOTO   011
0809:  COMF   77,F
080A:  INCF   77,F
080B:  MOVF   77,W
080C:  MOVWF  7E
080D:  MOVLW  2D
080E:  MOVWF  21
080F:  BSF    20.7
0810:  BSF    20.0
0811:  MOVF   7E,W
0812:  MOVWF  34
0813:  MOVLW  64
0814:  MOVWF  35
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   63B
0818:  BSF    0A.3
0819:  MOVF   77,W
081A:  MOVWF  7E
081B:  MOVLW  30
081C:  ADDWF  78,W
081D:  BSF    03.5
081E:  MOVWF  22
081F:  MOVF   7E,W
0820:  MOVWF  34
0821:  MOVLW  0A
0822:  MOVWF  35
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   63B
0826:  BSF    0A.3
0827:  MOVLW  30
0828:  ADDWF  77,W
0829:  BSF    03.5
082A:  MOVWF  24
082B:  MOVLW  30
082C:  ADDWF  78,W
082D:  MOVWF  23
082E:  MOVF   21,W
082F:  MOVWF  77
0830:  MOVLW  30
0831:  SUBWF  22,W
0832:  BTFSC  03.2
0833:  GOTO   038
0834:  BSF    20.1
0835:  BTFSC  20.7
0836:  BSF    20.2
0837:  GOTO   04C
0838:  MOVF   21,W
0839:  MOVWF  22
083A:  MOVLW  20
083B:  MOVWF  21
083C:  MOVLW  30
083D:  SUBWF  23,W
083E:  BTFSC  03.2
083F:  GOTO   044
0840:  BSF    20.0
0841:  BTFSC  20.7
0842:  BSF    20.1
0843:  GOTO   04C
0844:  BTFSS  03.2
0845:  BSF    20.0
0846:  BTFSS  03.2
0847:  GOTO   04C
0848:  MOVF   22,W
0849:  MOVWF  23
084A:  MOVLW  20
084B:  MOVWF  22
084C:  BTFSC  20.2
084D:  GOTO   053
084E:  BTFSC  20.1
084F:  GOTO   059
0850:  BTFSC  20.0
0851:  GOTO   05F
0852:  GOTO   065
0853:  MOVF   21,W
0854:  BCF    03.5
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
0858:  BSF    03.5
0859:  MOVF   22,W
085A:  BCF    03.5
085B:  BTFSS  0C.4
085C:  GOTO   05B
085D:  MOVWF  19
085E:  BSF    03.5
085F:  MOVF   23,W
0860:  BCF    03.5
0861:  BTFSS  0C.4
0862:  GOTO   061
0863:  MOVWF  19
0864:  BSF    03.5
0865:  MOVF   24,W
0866:  BCF    03.5
0867:  BTFSS  0C.4
0868:  GOTO   067
0869:  MOVWF  19
086A:  RETURN
*
09E0:  MOVF   7B,W
09E1:  XORWF  7C,W
09E2:  ANDLW  80
09E3:  MOVWF  7E
09E4:  BTFSS  7B.7
09E5:  GOTO   1E8
09E6:  COMF   7B,F
09E7:  INCF   7B,F
09E8:  BTFSS  7C.7
09E9:  GOTO   1EC
09EA:  COMF   7C,F
09EB:  INCF   7C,F
09EC:  MOVF   7C,W
09ED:  CLRF   78
09EE:  SUBWF  7B,W
09EF:  BTFSC  03.0
09F0:  GOTO   1F4
09F1:  MOVF   7B,W
09F2:  MOVWF  77
09F3:  GOTO   200
09F4:  CLRF   77
09F5:  MOVLW  08
09F6:  MOVWF  7D
09F7:  RLF    7B,F
09F8:  RLF    77,F
09F9:  MOVF   7C,W
09FA:  SUBWF  77,W
09FB:  BTFSC  03.0
09FC:  MOVWF  77
09FD:  RLF    78,F
09FE:  DECFSZ 7D,F
09FF:  GOTO   1F7
0A00:  BTFSS  7E.7
0A01:  GOTO   204
0A02:  COMF   78,F
0A03:  INCF   78,F
0A04:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses   hs, nowdt, put, noprotect, nolvp
.................... #use     delay(clock=20MHz) 
*
01F9:  MOVLW  7C
01FA:  MOVWF  04
01FB:  BCF    03.7
01FC:  MOVF   00,W
01FD:  BTFSC  03.2
01FE:  GOTO   20C
01FF:  MOVLW  06
0200:  MOVWF  78
0201:  CLRF   77
0202:  DECFSZ 77,F
0203:  GOTO   202
0204:  DECFSZ 78,F
0205:  GOTO   201
0206:  MOVLW  7B
0207:  MOVWF  77
0208:  DECFSZ 77,F
0209:  GOTO   208
020A:  DECFSZ 00,F
020B:  GOTO   1FF
020C:  RETURN
*
0304:  MOVLW  03
0305:  BSF    03.5
0306:  SUBWF  21,F
0307:  BTFSS  03.0
0308:  GOTO   313
0309:  MOVLW  A1
030A:  MOVWF  04
030B:  BCF    03.7
030C:  MOVF   00,W
030D:  BTFSC  03.2
030E:  GOTO   313
030F:  GOTO   311
0310:  GOTO   311
0311:  DECFSZ 00,F
0312:  GOTO   310
0313:  BCF    03.5
0314:  RETURN
.................... #use     i2c(master,slow,sda=pin_c4,scl=pin_c3)
*
016D:  BCF    14.7
016E:  BCF    0C.3
016F:  BSF    03.5
0170:  MOVF   47,W
0171:  BCF    03.5
0172:  MOVWF  13
0173:  MOVLW  02
0174:  BTFSC  14.7
0175:  GOTO   17D
0176:  BSF    03.5
0177:  BTFSC  14.2
0178:  GOTO   177
0179:  MOVLW  00
017A:  BTFSC  11.6
017B:  MOVLW  01
017C:  BCF    03.5
017D:  MOVWF  78
017E:  RETURN
017F:  BCF    14.6
0180:  BSF    03.5
0181:  BSF    11.3
0182:  BTFSC  11.3
0183:  GOTO   182
0184:  BTFSC  77.0
0185:  BCF    11.5
0186:  BTFSS  77.0
0187:  BSF    11.5
0188:  BSF    11.4
0189:  BTFSC  11.4
018A:  GOTO   189
018B:  BCF    03.5
018C:  MOVF   13,W
018D:  MOVWF  78
018E:  RETURN
.................... #use     rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits = 8, stream=UART_STREAM)
.................... #use fast_io(C)
.................... #use fast_io(D)
.................... #use fast_io(E)
.................... #use fast_io(B)
.................... #use fast_io(A)
.................... 
.................... //! define name again to user
.................... #define usi8  unsigned int8
.................... #define usi16 unsigned int16
.................... #define usi32 unsigned int32
.................... #define si8   signed   int8
.................... #define si16  signed   int16
.................... #define si32  signed   int32
.................... #define bool int1
.................... 
.................... //! define variables
.................... bool flag_10ms = false;
.................... bool flag_10s = false;
.................... bool flag_13s = false;
.................... bool flag_16s = false;
.................... bool isDs18b20 = false;
.................... 
.................... usi8 limitTemperature = 25;
.................... 
.................... usi16 tick_10ms;
.................... usi16 tick_100ms;
.................... 
.................... usi8 giay_tam, bdn, tt_ht = 0;
.................... si8 gt_mod = 0, tg_chinh = 0;
.................... 
.................... bool e_11, e_22, e_33;
.................... 
.................... usi8 eat_hh, eat_pp, eat_ss;
.................... 
.................... #define maxLevel 6
.................... 
.................... usi8 countLevel = 0;
.................... usi8 countLevelRev = 0;
.................... 
.................... bool flag_servo;
.................... usi8 count_servo = 0;
.................... 
.................... #define tang false
.................... #define giam true
.................... 
.................... //! define available for ds18b20
.................... usi16 temperature;
.................... usi8 dt_ng;
.................... usi16 dt_tp;
.................... usi16 tt;
.................... 
.................... //! define button to use
.................... #ifndef bt0
.................... #define bt0    pin_b0
.................... #endif
.................... 
.................... #ifndef bt1
.................... #define bt1    pin_b1
.................... #endif
.................... 
.................... #ifndef bt2
.................... #define bt2    pin_b2
.................... #endif
.................... 
.................... #ifndef bt3
.................... #define bt3    pin_b3
.................... #endif
.................... 
.................... //! define pin sensors
.................... #define pin_ds18b20 pin_a0
.................... 
.................... //! define pin controls
.................... #ifndef pinServo
.................... #define pinServo    pin_c1
.................... #endif
.................... 
.................... #ifndef pinDLCold
.................... #define pinDLCold     pin_d6
.................... #endif
.................... 
.................... #ifndef pinDLHot
.................... #define pinDLHot      pin_d7
.................... #endif
.................... 
.................... #ifndef ledTest
.................... #define ledTest       pin_b5
.................... #endif
.................... 
.................... #include <library_uart.c>
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
1039:  BCF    03.5
103A:  CLRF   45
103B:  CLRF   46
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... //! define buffer size is 16 byte
.................... #define BUFFER_SIZE 16
.................... 
.................... //! define available for uart buffer
.................... char receivedString[BUFFER_SIZE]="";
103C:  CLRF   47
.................... volatile unsigned int index = 0;
.................... volatile int stringComplete = 0;
.................... volatile unsigned int indexComplete = 0;
.................... 
.................... #int_rda
.................... void read_uart(){
....................    if(kbhit()){
*
005A:  BTFSS  0C.5
005B:  GOTO   086
.................... //!   Read the received character
....................       char receivedChar = getch();  
005C:  BTFSS  0C.5
005D:  GOTO   05C
005E:  MOVF   1A,W
005F:  BSF    03.5
0060:  MOVWF  4A
....................        
....................        if (receivedChar == '\r' || receivedChar == '\n') {
0061:  MOVF   4A,W
0062:  SUBLW  0D
0063:  BTFSC  03.2
0064:  GOTO   069
0065:  MOVF   4A,W
0066:  SUBLW  0A
0067:  BTFSS  03.2
0068:  GOTO   075
.................... //!        End of string (carriage return detected)
....................            receivedString[index] = '\0';  // Null-terminate the string
0069:  MOVLW  47
006A:  BCF    03.5
006B:  ADDWF  57,W
006C:  MOVWF  04
006D:  BCF    03.7
006E:  CLRF   00
....................            indexComplete = index;
006F:  MOVF   57,W
0070:  MOVWF  59
....................            stringComplete = 1;  // Set the flag to indicate string reception complete
0071:  MOVLW  01
0072:  MOVWF  58
....................        } else {
0073:  GOTO   086
0074:  BSF    03.5
....................           // Store the received character
....................            if (index < BUFFER_SIZE - 1) {
0075:  BCF    03.5
0076:  MOVF   57,W
0077:  SUBLW  0E
0078:  BTFSS  03.0
0079:  GOTO   084
....................                receivedString[index++] = receivedChar;
007A:  MOVF   57,W
007B:  INCF   57,F
007C:  ADDLW  47
007D:  MOVWF  04
007E:  BCF    03.7
007F:  BSF    03.5
0080:  MOVF   4A,W
0081:  MOVWF  00
....................            } else {
0082:  GOTO   087
0083:  BCF    03.5
....................                // Handle buffer overflow
....................                index = BUFFER_SIZE - 1;  // Prevent overflow
0084:  MOVLW  0F
0085:  MOVWF  57
0086:  BSF    03.5
....................            }
....................        }
....................    }
0087:  BCF    03.5
0088:  BCF    0C.5
0089:  BCF    0A.3
008A:  BCF    0A.4
008B:  GOTO   033
.................... }
.................... 
.................... usi8 decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
*
07DF:  MOVF   7C,W
07E0:  BSF    03.5
07E1:  MOVWF  34
07E2:  MOVLW  0A
07E3:  MOVWF  35
07E4:  BCF    03.5
07E5:  CALL   63B
07E6:  SWAPF  78,W
07E7:  MOVWF  7D
07E8:  MOVLW  F0
07E9:  ANDWF  7D,F
07EA:  MOVF   7C,W
07EB:  BSF    03.5
07EC:  MOVWF  34
07ED:  MOVLW  0A
07EE:  MOVWF  35
07EF:  BCF    03.5
07F0:  CALL   63B
07F1:  MOVF   77,W
07F2:  ADDWF  7D,W
07F3:  MOVWF  78
07F4:  RETURN
.................... }
.................... 
.................... void send_ok(){
....................    output_bit(ledTest,1);
*
07D2:  BSF    06.5
....................    delay_ms(100);
07D3:  MOVLW  64
07D4:  MOVWF  7C
07D5:  CALL   1F9
....................    output_bit(ledTest,0);
07D6:  BCF    06.5
....................    printf("ss:ok\r\n");
07D7:  MOVLW  8C
07D8:  BSF    03.6
07D9:  MOVWF  0D
07DA:  MOVLW  00
07DB:  MOVWF  0F
07DC:  BCF    03.6
07DD:  CALL   406
07DE:  RETURN
.................... }
.................... 
.................... void handle_uart(){
....................    if (stringComplete) {
*
1193:  MOVF   58,F
1194:  BTFSC  03.2
1195:  GOTO   223
....................       stringComplete = 0;
1196:  CLRF   58
....................       index = 0;
1197:  CLRF   57
....................       indexComplete = 0;
1198:  CLRF   59
....................       if(receivedString[0] == 's' && receivedString[1] == 't' && receivedString[2] == ':'){
1199:  MOVF   47,W
119A:  SUBLW  73
119B:  BTFSS  03.2
119C:  GOTO   1B8
119D:  MOVF   48,W
119E:  SUBLW  74
119F:  BTFSS  03.2
11A0:  GOTO   1B8
11A1:  MOVF   49,W
11A2:  SUBLW  3A
11A3:  BTFSS  03.2
11A4:  GOTO   1B8
.................... //!      Header for changing temperature found
.................... //!      frame "st:23"
....................          limitTemperature = ((receivedString[3] - '0') * 10) + (receivedString[4] - '0');
11A5:  MOVLW  30
11A6:  SUBWF  4A,W
11A7:  MOVWF  7C
11A8:  BSF    03.5
11A9:  MOVWF  25
11AA:  MOVLW  0A
11AB:  MOVWF  26
11AC:  BCF    0A.4
11AD:  BCF    03.5
11AE:  CALL   5FF
11AF:  BSF    0A.4
11B0:  MOVLW  30
11B1:  SUBWF  4B,W
11B2:  ADDWF  78,W
11B3:  MOVWF  2D
....................          send_ok();
11B4:  BCF    0A.4
11B5:  CALL   7D2
11B6:  BSF    0A.4
....................       }
11B7:  GOTO   223
....................       else if(receivedString[0] == 's' && receivedString[1] == 'a' && receivedString[2] == ':'){
11B8:  MOVF   47,W
11B9:  SUBLW  73
11BA:  BTFSS  03.2
11BB:  GOTO   213
11BC:  MOVF   48,W
11BD:  SUBLW  61
11BE:  BTFSS  03.2
11BF:  GOTO   213
11C0:  MOVF   49,W
11C1:  SUBLW  3A
11C2:  BTFSS  03.2
11C3:  GOTO   213
.................... //!      Header for changing alarm settings found
.................... //!      frame "sa:gpg:11-11-11"
....................          if(receivedString[3] == 'g' && receivedString[4] == 'p' && receivedString[5] == 'g'){
11C4:  MOVF   4A,W
11C5:  SUBLW  67
11C6:  BTFSS  03.2
11C7:  GOTO   212
11C8:  MOVF   4B,W
11C9:  SUBLW  70
11CA:  BTFSS  03.2
11CB:  GOTO   212
11CC:  MOVF   4C,W
11CD:  SUBLW  67
11CE:  BTFSS  03.2
11CF:  GOTO   212
....................             // Address for changing gpg alarm settings found
....................             eat_hh = decToBcd((receivedString[7] - '0') * 10) + (receivedString[8] - '0');
11D0:  MOVLW  30
11D1:  SUBWF  4E,W
11D2:  MOVWF  7C
11D3:  BSF    03.5
11D4:  MOVWF  25
11D5:  MOVLW  0A
11D6:  MOVWF  26
11D7:  BCF    0A.4
11D8:  BCF    03.5
11D9:  CALL   5FF
11DA:  BSF    0A.4
11DB:  MOVF   78,W
11DC:  MOVWF  7B
11DD:  MOVWF  7C
11DE:  BCF    0A.4
11DF:  CALL   7DF
11E0:  BSF    0A.4
11E1:  MOVLW  30
11E2:  SUBWF  4F,W
11E3:  ADDWF  78,W
11E4:  MOVWF  37
....................             eat_pp = decToBcd((receivedString[10] - '0') * 10) + (receivedString[11] - '0');
11E5:  MOVLW  30
11E6:  SUBWF  51,W
11E7:  MOVWF  7C
11E8:  BSF    03.5
11E9:  MOVWF  25
11EA:  MOVLW  0A
11EB:  MOVWF  26
11EC:  BCF    0A.4
11ED:  BCF    03.5
11EE:  CALL   5FF
11EF:  BSF    0A.4
11F0:  MOVF   78,W
11F1:  MOVWF  7B
11F2:  MOVWF  7C
11F3:  BCF    0A.4
11F4:  CALL   7DF
11F5:  BSF    0A.4
11F6:  MOVLW  30
11F7:  SUBWF  52,W
11F8:  ADDWF  78,W
11F9:  MOVWF  38
....................             eat_ss = decToBcd((receivedString[13] - '0') * 10) + (receivedString[14] - '0');
11FA:  MOVLW  30
11FB:  SUBWF  54,W
11FC:  MOVWF  7C
11FD:  BSF    03.5
11FE:  MOVWF  25
11FF:  MOVLW  0A
1200:  MOVWF  26
1201:  BCF    0A.4
1202:  BCF    03.5
1203:  CALL   5FF
1204:  BSF    0A.4
1205:  MOVF   78,W
1206:  MOVWF  7B
1207:  MOVWF  7C
1208:  BCF    0A.4
1209:  CALL   7DF
120A:  BSF    0A.4
120B:  MOVLW  30
120C:  SUBWF  55,W
120D:  ADDWF  78,W
120E:  MOVWF  39
....................             send_ok();
120F:  BCF    0A.4
1210:  CALL   7D2
1211:  BSF    0A.4
....................          }
....................       }
1212:  GOTO   223
....................       else if(receivedString[0] == 'c' && receivedString[1] == 's' && receivedString[2] == ':'){
1213:  MOVF   47,W
1214:  SUBLW  63
1215:  BTFSS  03.2
1216:  GOTO   223
1217:  MOVF   48,W
1218:  SUBLW  73
1219:  BTFSS  03.2
121A:  GOTO   223
121B:  MOVF   49,W
121C:  SUBLW  3A
121D:  BTFSS  03.2
121E:  GOTO   223
.................... //!      Header for controling servo manual
.................... //!      frame "cs:1" -> servo on    
.................... //!      frame "cs:0" -> servo off
.................... //!         flag_servo = receivedString[3] - '0';
....................          flag_servo = 1;
121F:  BSF    3C.0
....................          send_ok();
1220:  BCF    0A.4
1221:  CALL   7D2
1222:  BSF    0A.4
....................       }
....................    }  
.................... }
.................... 
.................... 
.................... 
.................... #int_timer1
.................... void interrupt_timer1()
.................... {
....................    set_timer1(59285);
*
0090:  CLRF   0E
0091:  MOVLW  E7
0092:  MOVWF  0F
0093:  MOVLW  95
0094:  MOVWF  0E
0095:  NOP
....................    
....................    flag_10ms = !flag_10ms;
0096:  MOVLW  01
0097:  XORWF  2C,F
.................... 
....................    tick_10ms++;
0098:  INCF   2E,F
0099:  BTFSC  03.2
009A:  INCF   2F,F
.................... 
.................... //! when tick_10ms >= 10 --> 100ms
....................    if(tick_10ms >= 10){
009B:  MOVF   2F,F
009C:  BTFSS  03.2
009D:  GOTO   0A2
009E:  MOVF   2E,W
009F:  SUBLW  09
00A0:  BTFSC  03.0
00A1:  GOTO   0DA
....................       bdn++;
00A2:  INCF   33,F
....................       tick_10ms = 0;
00A3:  CLRF   2F
00A4:  CLRF   2E
....................       
....................       if(tick_100ms < 200) tick_100ms++;
00A5:  MOVF   31,F
00A6:  BTFSS  03.2
00A7:  GOTO   0B0
00A8:  MOVF   30,W
00A9:  SUBLW  C7
00AA:  BTFSS  03.0
00AB:  GOTO   0B0
00AC:  INCF   30,F
00AD:  BTFSC  03.2
00AE:  INCF   31,F
00AF:  GOTO   0B2
....................       else tick_100ms = 0;
00B0:  CLRF   31
00B1:  CLRF   30
....................       
....................       if (tick_100ms == 100 || tick_100ms == 200){
00B2:  MOVF   30,W
00B3:  SUBLW  64
00B4:  BTFSS  03.2
00B5:  GOTO   0B9
00B6:  MOVF   31,F
00B7:  BTFSC  03.2
00B8:  GOTO   0BF
00B9:  MOVF   30,W
00BA:  SUBLW  C8
00BB:  BTFSS  03.2
00BC:  GOTO   0C0
00BD:  MOVF   31,F
00BE:  BTFSC  03.2
....................          flag_10s = true;
00BF:  BSF    2C.1
....................       }
....................       if (tick_100ms == 130){
00C0:  MOVF   30,W
00C1:  SUBLW  82
00C2:  BTFSS  03.2
00C3:  GOTO   0C7
00C4:  MOVF   31,F
00C5:  BTFSC  03.2
....................          flag_13s = true;
00C6:  BSF    2C.2
....................       }
....................       if (tick_100ms == 160){
00C7:  MOVF   30,W
00C8:  SUBLW  A0
00C9:  BTFSS  03.2
00CA:  GOTO   0CE
00CB:  MOVF   31,F
00CC:  BTFSC  03.2
....................          flag_16s = true;
00CD:  BSF    2C.3
....................       }
.................... //! disable flag servo on --> flag_servo >> false
....................       if(flag_servo == true){
00CE:  BTFSS  3C.0
00CF:  GOTO   0D9
....................          if(count_servo < 100) count_servo++; // 10s
00D0:  MOVF   3D,W
00D1:  SUBLW  63
00D2:  BTFSS  03.0
00D3:  GOTO   0D6
00D4:  INCF   3D,F
00D5:  GOTO   0D8
....................          else{
....................             count_servo = 0;
00D6:  CLRF   3D
....................             flag_servo = false;
00D7:  BCF    3C.0
....................          }
....................       }
00D8:  GOTO   0DA
....................       else flag_servo = 0;
00D9:  BCF    3C.0
....................    }
00DA:  BCF    0C.0
00DB:  BCF    0A.3
00DC:  BCF    0A.4
00DD:  GOTO   033
.................... }
.................... 
.................... void setup_initialize(){
.................... //! set up timer 1 to timer count is 10ms of one cycle
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);
*
0144:  MOVLW  B5
0145:  MOVWF  10
....................    set_timer1(59286);
0146:  CLRF   0E
0147:  MOVLW  E7
0148:  MOVWF  0F
0149:  MOVLW  96
014A:  MOVWF  0E
014B:  NOP
.................... 
.................... //! enable interrupt timer 1 and read data uart
....................    enable_interrupts(global);
014C:  MOVLW  C0
014D:  IORWF  0B,F
....................    enable_interrupts(int_timer1);
014E:  BSF    03.5
014F:  BSF    0C.0
....................    enable_interrupts(int_rda);
0150:  BSF    0C.5
.................... 
.................... 
.................... //! setup mode for all gpio of pic16f877a
....................    set_tris_a(0xff);
0151:  MOVLW  FF
0152:  MOVWF  05
....................    set_tris_b(0xdf);
0153:  MOVLW  DF
0154:  MOVWF  06
....................    set_tris_d(0x00); //output_d(0x00);
0155:  MOVLW  00
0156:  MOVWF  08
....................    set_tris_e(0x00); //output_e(0x00);
0157:  BCF    09.0
0158:  BCF    09.1
0159:  BCF    09.2
....................    set_tris_c(0x98); //output_c(0x98);
015A:  MOVLW  98
015B:  MOVWF  07
....................  
.................... //! setup variable initialize
....................    flag_10ms = false;
015C:  BCF    03.5
015D:  BCF    2C.0
....................    flag_10s  = false;
015E:  BCF    2C.1
....................    isDs18b20 = false;
015F:  BCF    2C.4
....................    
....................    limitTemperature = 25;
0160:  MOVLW  19
0161:  MOVWF  2D
....................    
....................    e_11 = true; e_22 = true; e_33 = true;
0162:  BSF    2C.5
0163:  BSF    2C.6
0164:  BSF    2C.7
....................    
....................    eat_hh = 0x09; eat_pp = 0x30; eat_ss = 0x30;
0165:  MOVLW  09
0166:  MOVWF  37
0167:  MOVLW  30
0168:  MOVWF  38
0169:  MOVWF  39
016A:  BCF    0A.3
016B:  BSF    0A.4
016C:  GOTO   061 (RETURN)
.................... }
.................... 
.................... #include <library_button.c>
.................... //! button place
.................... //! bt3 - bt2 - bt1 - bt0
.................... 
.................... usi8 countPush = 0;
.................... usi8 countTick = 0;
.................... 
.................... bool push_btn(bool isRelease, usi8 pin){
.................... //! isRelease == 0 --> push button is hold
.................... //! isRelease == 1 --> push button is release
....................    if(!input(pin)){
*
107A:  MOVF   7C,W
107B:  MOVWF  7D
107C:  BSF    03.5
107D:  CLRF   21
107E:  CLRF   20
107F:  BCF    0A.4
1080:  BCF    03.5
1081:  CALL   47C
1082:  BSF    0A.4
1083:  BTFSC  78.0
1084:  GOTO   0AF
....................       if(flag_10ms == true) countPush++;
1085:  BTFSS  2C.0
1086:  GOTO   088
1087:  INCF   5C,F
.................... //! check if countPush == 2 (20ms) --> debound button
....................       if(countPush >= 1){
1088:  MOVF   5C,W
1089:  SUBLW  00
108A:  BTFSC  03.0
108B:  GOTO   0AC
....................          if(!input(pin)){
108C:  MOVF   7C,W
108D:  MOVWF  7D
108E:  BSF    03.5
108F:  CLRF   21
1090:  CLRF   20
1091:  BCF    0A.4
1092:  BCF    03.5
1093:  CALL   47C
1094:  BSF    0A.4
1095:  BTFSC  78.0
1096:  GOTO   0A9
....................             if(isRelease == false) while(!input(pin));
1097:  MOVF   7B,F
1098:  BTFSS  03.2
1099:  GOTO   0A5
109A:  MOVF   7C,W
109B:  MOVWF  7D
109C:  BSF    03.5
109D:  CLRF   21
109E:  CLRF   20
109F:  BCF    0A.4
10A0:  BCF    03.5
10A1:  CALL   47C
10A2:  BSF    0A.4
10A3:  BTFSS  78.0
10A4:  GOTO   09A
....................             countPush = 0;
10A5:  CLRF   5C
....................             return true;
10A6:  MOVLW  01
10A7:  MOVWF  78
10A8:  GOTO   0B1
....................          }
....................          return false;
10A9:  MOVLW  00
10AA:  MOVWF  78
10AB:  GOTO   0B1
....................       }
....................       return false;
10AC:  MOVLW  00
10AD:  MOVWF  78
10AE:  GOTO   0B1
....................    }
.................... //!   countPush = 0;
....................    return false;
10AF:  MOVLW  00
10B0:  MOVWF  78
.................... }
.................... 
.................... bool tick_btn(usi8 delay, usi8 pin){
.................... //! dl is time delay that compute with 10ms for dl is 1
....................    if(!input(pin)){
*
086B:  MOVF   7C,W
086C:  MOVWF  7D
086D:  BSF    03.5
086E:  CLRF   21
086F:  CLRF   20
0870:  BCF    0A.3
0871:  BCF    03.5
0872:  CALL   47C
0873:  BSF    0A.3
0874:  BTFSC  78.0
0875:  GOTO   083
....................       if(flag_10ms == true) countTick++;
0876:  BTFSC  2C.0
0877:  INCF   5D,F
.................... //! check if countTick >= delay (delay * 10ms) --> time delay wanna to tick rising signal
....................       if(countTick >= delay){
0878:  MOVF   7B,W
0879:  SUBWF  5D,W
087A:  BTFSS  03.0
087B:  GOTO   080
....................          countTick = 0;
087C:  CLRF   5D
....................          return true;
087D:  MOVLW  01
087E:  MOVWF  78
087F:  GOTO   085
....................       }
....................       return false;
0880:  MOVLW  00
0881:  MOVWF  78
0882:  GOTO   085
....................    }
.................... //!   countTick = 0;
....................    return false;
0883:  MOVLW  00
0884:  MOVWF  78
0885:  RETURN
.................... }
.................... 
.................... #include <library_i2c.c>
.................... #define pcf8574_addr_wr 0x4E // 0b01001110
.................... #define pcf8574_addr_rd 0x4F // 0b01001111
.................... 
.................... //! i2c reset
.................... void i2c_reset()
.................... {
....................    i2c_start();
....................    i2c_stop();
.................... }
.................... 
.................... //! i2c setup write for pcf8574
.................... void i2c_setup_write()
.................... {
....................    i2c_start();
*
0294:  BSF    03.5
0295:  BSF    11.0
0296:  BTFSC  11.0
0297:  GOTO   296
....................    i2c_write(pcf8574_addr_wr);
0298:  MOVLW  4E
0299:  MOVWF  47
029A:  BCF    03.5
029B:  CALL   16D
.................... }
.................... 
.................... //! i2c write 1byte for pcf8574
.................... void i2c_write_1byte(usi8 payload)
.................... {
....................    i2c_start();
*
0217:  BSF    11.1
0218:  BTFSC  11.1
0219:  GOTO   218
*
0235:  BSF    11.1
0236:  BTFSC  11.1
0237:  GOTO   236
*
0254:  BSF    11.1
0255:  BTFSC  11.1
0256:  GOTO   255
*
02AD:  BSF    11.1
02AE:  BTFSC  11.1
02AF:  GOTO   2AE
....................    i2c_write(pcf8574_addr_wr);
*
021A:  MOVLW  4E
021B:  MOVWF  47
021C:  BCF    03.5
021D:  CALL   16D
*
0238:  MOVLW  4E
0239:  MOVWF  47
023A:  BCF    03.5
023B:  CALL   16D
*
0257:  MOVLW  4E
0258:  MOVWF  47
0259:  BCF    03.5
025A:  CALL   16D
*
02B0:  MOVLW  4E
02B1:  MOVWF  47
02B2:  BCF    03.5
02B3:  CALL   16D
....................    i2c_write(payload);
*
021E:  BSF    03.5
021F:  MOVF   46,W
0220:  MOVWF  47
0221:  BCF    03.5
0222:  CALL   16D
*
023C:  BSF    03.5
023D:  MOVF   46,W
023E:  MOVWF  47
023F:  BCF    03.5
0240:  CALL   16D
*
025B:  BSF    03.5
025C:  MOVF   46,W
025D:  MOVWF  47
025E:  BCF    03.5
025F:  CALL   16D
*
02B4:  BSF    03.5
02B5:  MOVF   46,W
02B6:  MOVWF  47
02B7:  BCF    03.5
02B8:  CALL   16D
....................    i2c_stop();
*
0223:  BSF    03.5
0224:  BSF    11.2
0225:  BTFSC  11.2
0226:  GOTO   225
*
0241:  BSF    03.5
0242:  BSF    11.2
0243:  BTFSC  11.2
0244:  GOTO   243
*
0260:  BSF    03.5
0261:  BSF    11.2
0262:  BTFSC  11.2
0263:  GOTO   262
*
02B9:  BSF    03.5
02BA:  BSF    11.2
02BB:  BTFSC  11.2
02BC:  GOTO   2BB
.................... }
.................... 
.................... 
.................... #include <library_lcd_i2c.c>
.................... #define lcd_cols 16
.................... #define lcd_rows 2
.................... 
.................... // commands
.................... #define LCD_CLEARDISPLAY 0x01
.................... #define LCD_RETURNHOME 0x02
.................... #define LCD_ENTRYMODESET 0x04
.................... #define LCD_DISPLAYCONTROL 0x08
.................... #define LCD_CURSORSHIFT 0x10
.................... #define LCD_FUNCTIONSET 0x20
.................... #define LCD_SETCGRAMADDR 0x40
.................... #define LCD_SETDDRAMADDR 0x80
.................... 
.................... // flags for display entry mode
.................... #define LCD_ENTRYRIGHT 0x00
.................... #define LCD_ENTRYLEFT 0x02
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00
.................... 
.................... // flags for display on/off control
.................... #define LCD_DISPLAYON 0x04
.................... #define LCD_DISPLAYOFF 0x00
.................... #define LCD_CURSORON 0x02
.................... #define LCD_CURSOROFF 0x00
.................... #define LCD_BLINKON 0x01
.................... #define LCD_BLINKOFF 0x00
.................... 
.................... // flags for display/cursor shift
.................... #define LCD_DISPLAYMOVE 0x08
.................... #define LCD_CURSORMOVE 0x00
.................... #define LCD_MOVERIGHT 0x04
.................... #define LCD_MOVELEFT 0x00
.................... 
.................... // flags for function set
.................... #define LCD_8BITMODE 0x10
.................... #define LCD_4BITMODE 0x00
.................... #define LCD_2LINE 0x08
.................... #define LCD_1LINE 0x00
.................... #define LCD_5x10DOTS 0x04
.................... #define LCD_5x8DOTS 0x00
.................... 
.................... // flags for backlight control
.................... #define LCD_BACKLIGHT 0x08
.................... #define LCD_NOBACKLIGHT 0x00
.................... 
.................... #define En 0B00000100  // Enable bit
.................... #define Rw 0B00000010  // Read/Write bit
.................... #define Rs 0B00000001  // Register select bit
.................... 
.................... void write4bits(usi8 value);
.................... void expanderWrite(usi8 _data);
.................... void pulseEnable(usi8 _data);
.................... void lcd_command(usi8 value);
.................... void lcd_display();
.................... void lcd_clear();
.................... void lcd_home();
.................... void lcd_send(usi8 value, usi8 mode);
.................... void lcd_data(usi8 value);
.................... 
.................... usi8 _displayfunction;
.................... usi8 _displaycontrol;
.................... usi8 _displaymode;
.................... usi8 _numlines;
.................... usi8 _cols;
.................... usi8 _rows;
.................... usi8 _backlightval;
.................... 
.................... void lcd_setup(){
....................    _cols = lcd_cols; // 16
*
028F:  MOVLW  10
0290:  MOVWF  62
....................    _rows = lcd_rows; // 2
0291:  MOVLW  02
0292:  MOVWF  63
....................    _backlightval = LCD_NOBACKLIGHT; // back light is off
0293:  CLRF   64
....................    
....................    i2c_setup_write(); // setup i2c
....................    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
*
029C:  CLRF   5E
....................    
....................    _displayfunction |= LCD_2LINE;
029D:  BSF    5E.3
....................    _numlines = _rows; // 2
029E:  MOVF   63,W
029F:  MOVWF  61
....................    
....................    delay_ms(40);
02A0:  MOVLW  28
02A1:  MOVWF  7C
02A2:  CALL   1F9
....................    
....................    expanderWrite(_backlightval); // back light is on
02A3:  MOVF   64,W
02A4:  BSF    03.5
02A5:  MOVWF  44
....................    delay_ms(100);
*
02BD:  MOVLW  64
02BE:  MOVWF  7C
02BF:  BCF    03.5
02C0:  CALL   1F9
....................    
....................    //It is try to set use 4bit in 3 time
....................    write4bits(0x03 << 4);
02C1:  MOVLW  30
02C2:  BSF    03.5
02C3:  MOVWF  41
02C4:  BCF    03.5
02C5:  CALL   20D
....................    delay_ms(5);
02C6:  MOVLW  05
02C7:  MOVWF  7C
02C8:  CALL   1F9
....................    
....................    write4bits(0x03 << 4);
02C9:  MOVLW  30
02CA:  BSF    03.5
02CB:  MOVWF  41
02CC:  BCF    03.5
02CD:  CALL   20D
....................    delay_ms(5);
02CE:  MOVLW  05
02CF:  MOVWF  7C
02D0:  CALL   1F9
....................    
....................    write4bits(0x03 << 4);
02D1:  MOVLW  30
02D2:  BSF    03.5
02D3:  MOVWF  41
02D4:  BCF    03.5
02D5:  CALL   20D
....................    delay_ms(5);
02D6:  MOVLW  05
02D7:  MOVWF  7C
02D8:  CALL   1F9
....................    
....................    write4bits(0x02 << 4); // set using 4bit for lcd16x2
02D9:  MOVLW  20
02DA:  BSF    03.5
02DB:  MOVWF  41
02DC:  BCF    03.5
02DD:  CALL   20D
....................    
....................    lcd_command(LCD_FUNCTIONSET | _displayfunction);
02DE:  MOVF   5E,W
02DF:  IORLW  20
02E0:  MOVWF  7B
02E1:  BSF    03.5
02E2:  MOVWF  3B
02E3:  BCF    03.5
02E4:  CALL   26A
....................    
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
02E5:  MOVLW  04
02E6:  MOVWF  5F
....................    lcd_display();
....................    
....................    lcd_clear();
*
02EF:  CALL   286
....................    
....................    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
02F0:  MOVLW  02
02F1:  MOVWF  60
....................    lcd_command(LCD_ENTRYMODESET | _displaymode);
02F2:  MOVF   60,W
02F3:  IORLW  04
02F4:  MOVWF  7B
02F5:  BSF    03.5
02F6:  MOVWF  3B
02F7:  BCF    03.5
02F8:  CALL   26A
....................    
....................    lcd_home();
*
0301:  BCF    0A.3
0302:  BSF    0A.4
0303:  GOTO   067 (RETURN)
.................... }
.................... 
.................... void lcd_clear(){
....................    lcd_command(LCD_CLEARDISPLAY);
*
0286:  MOVLW  01
0287:  BSF    03.5
0288:  MOVWF  3B
0289:  BCF    03.5
028A:  CALL   26A
....................    delay_ms(20);
028B:  MOVLW  14
028C:  MOVWF  7C
028D:  CALL   1F9
028E:  RETURN
.................... }
.................... 
.................... void lcd_home(){
....................    lcd_command(LCD_RETURNHOME);
*
02F9:  MOVLW  02
02FA:  BSF    03.5
02FB:  MOVWF  3B
02FC:  BCF    03.5
02FD:  CALL   26A
....................    delay_ms(20);
02FE:  MOVLW  14
02FF:  MOVWF  7C
0300:  CALL   1F9
.................... }
.................... 
.................... void lcd_setCursor(usi8 col, usi8 row){
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
*
0330:  BSF    03.5
0331:  CLRF   36
0332:  MOVLW  40
0333:  MOVWF  37
0334:  MOVLW  14
0335:  MOVWF  38
0336:  MOVLW  54
0337:  MOVWF  39
....................    if ( row > _numlines ) {
0338:  MOVF   35,W
0339:  BCF    03.5
033A:  SUBWF  61,W
033B:  BTFSC  03.0
033C:  GOTO   342
....................       row = _numlines-1;
033D:  MOVLW  01
033E:  SUBWF  61,W
033F:  BSF    03.5
0340:  MOVWF  35
0341:  BCF    03.5
....................    }
....................    lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
0342:  MOVLW  B6
0343:  BSF    03.5
0344:  ADDWF  35,W
0345:  MOVWF  04
0346:  BCF    03.7
0347:  MOVF   00,W
0348:  ADDWF  34,W
0349:  IORLW  80
034A:  MOVWF  3A
034B:  MOVWF  3B
034C:  BCF    03.5
034D:  CALL   26A
034E:  RETURN
.................... }
.................... 
.................... void lcd_display() {
....................    _displaycontrol |= LCD_DISPLAYON;
*
02E7:  BSF    5F.2
....................    lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
02E8:  MOVF   5F,W
02E9:  IORLW  08
02EA:  MOVWF  7B
02EB:  BSF    03.5
02EC:  MOVWF  3B
02ED:  BCF    03.5
02EE:  CALL   26A
.................... }
.................... 
.................... void lcd_command(usi8 value){
....................    lcd_send(value,0);
*
026A:  BSF    03.5
026B:  MOVF   3B,W
026C:  MOVWF  3C
026D:  CLRF   3D
*
0285:  RETURN
.................... }
.................... 
.................... void lcd_data(usi8 value){
....................    lcd_send(value,Rs);
*
034F:  BSF    03.5
0350:  MOVF   37,W
0351:  MOVWF  3C
0352:  MOVLW  01
0353:  MOVWF  3D
*
036B:  RETURN
.................... }
.................... 
.................... void lcd_send(usi8 value, usi8 mode) {
*
026E:  MOVF   3C,W
026F:  ANDLW  F0
0270:  MOVWF  3E
0271:  SWAPF  3C,W
0272:  MOVWF  77
0273:  MOVLW  F0
0274:  ANDWF  77,F
0275:  MOVF   77,W
0276:  ANDLW  F0
0277:  MOVWF  3F
*
0354:  MOVF   3C,W
0355:  ANDLW  F0
0356:  MOVWF  3E
0357:  SWAPF  3C,W
0358:  MOVWF  77
0359:  MOVLW  F0
035A:  ANDWF  77,F
035B:  MOVF   77,W
035C:  ANDLW  F0
035D:  MOVWF  3F
....................    usi8 highnib=value&0xf0;
....................    usi8 lownib=(value<<4)&0xf0;
....................    write4bits((highnib)|mode);
*
0278:  MOVF   3E,W
0279:  IORWF  3D,W
027A:  MOVWF  40
027B:  MOVWF  41
027C:  BCF    03.5
027D:  CALL   20D
*
035E:  MOVF   3E,W
035F:  IORWF  3D,W
0360:  MOVWF  40
0361:  MOVWF  41
0362:  BCF    03.5
0363:  CALL   20D
....................    write4bits((lownib)|mode); 
*
027E:  BSF    03.5
027F:  MOVF   3F,W
0280:  IORWF  3D,W
0281:  MOVWF  40
0282:  MOVWF  41
0283:  BCF    03.5
0284:  CALL   20D
*
0364:  BSF    03.5
0365:  MOVF   3F,W
0366:  IORWF  3D,W
0367:  MOVWF  40
0368:  MOVWF  41
0369:  BCF    03.5
036A:  CALL   20D
.................... }
.................... 
.................... void write4bits(usi8 value) {
....................    expanderWrite(value);
*
020D:  BSF    03.5
020E:  MOVF   41,W
020F:  MOVWF  44
....................    pulseEnable(value);
*
0227:  MOVF   41,W
0228:  MOVWF  42
*
0268:  BCF    03.5
0269:  RETURN
.................... }
.................... 
.................... void expanderWrite(usi8 _data){
....................    i2c_write_1byte(_data|_backlightval);
*
0210:  MOVF   44,W
0211:  BCF    03.5
0212:  IORWF  64,W
0213:  BSF    03.5
0214:  MOVWF  45
0215:  MOVF   45,W
0216:  MOVWF  46
*
022E:  MOVF   44,W
022F:  BCF    03.5
0230:  IORWF  64,W
0231:  BSF    03.5
0232:  MOVWF  45
0233:  MOVF   45,W
0234:  MOVWF  46
*
024D:  MOVF   44,W
024E:  BCF    03.5
024F:  IORWF  64,W
0250:  BSF    03.5
0251:  MOVWF  45
0252:  MOVF   45,W
0253:  MOVWF  46
*
02A6:  MOVF   44,W
02A7:  BCF    03.5
02A8:  IORWF  64,W
02A9:  BSF    03.5
02AA:  MOVWF  45
02AB:  MOVF   45,W
02AC:  MOVWF  46
.................... }
.................... 
.................... void pulseEnable(usi8 _data){
....................    expanderWrite(_data | En);
*
0229:  MOVF   42,W
022A:  IORLW  04
022B:  MOVWF  43
022C:  MOVF   43,W
022D:  MOVWF  44
....................    delay_us(1);
*
0245:  GOTO   246
0246:  GOTO   247
0247:  NOP
....................    expanderWrite(_data & ~En);
0248:  MOVF   42,W
0249:  ANDLW  FB
024A:  MOVWF  43
024B:  MOVF   43,W
024C:  MOVWF  44
....................    delay_us(50);
*
0264:  MOVLW  53
0265:  MOVWF  77
0266:  DECFSZ 77,F
0267:  GOTO   266
.................... }
.................... 
.................... void log_lcd_initialize(){
....................    lcd_setCursor(1,0);
*
03E0:  MOVLW  01
03E1:  BSF    03.5
03E2:  MOVWF  34
03E3:  CLRF   35
03E4:  BCF    03.5
03E5:  CALL   330
....................    lcd_data("Do an 1 - HKII");
03E6:  MOVLW  DE
03E7:  BSF    03.6
03E8:  MOVWF  0D
03E9:  MOVLW  00
03EA:  MOVWF  0F
03EB:  BCF    03.6
03EC:  CALL   36C
....................    lcd_setCursor(3,1);
03ED:  MOVLW  03
03EE:  BSF    03.5
03EF:  MOVWF  34
03F0:  MOVLW  01
03F1:  MOVWF  35
03F2:  BCF    03.5
03F3:  CALL   330
....................    lcd_data("SPKT-TPHCM");
03F4:  MOVLW  E6
03F5:  BSF    03.6
03F6:  MOVWF  0D
03F7:  MOVLW  00
03F8:  MOVWF  0F
03F9:  BCF    03.6
03FA:  CALL   36C
....................    delay_ms(2000);
03FB:  MOVLW  08
03FC:  MOVWF  7B
03FD:  MOVLW  FA
03FE:  MOVWF  7C
03FF:  CALL   1F9
0400:  DECFSZ 7B,F
0401:  GOTO   3FD
....................    lcd_clear();
0402:  CALL   286
0403:  BCF    0A.3
0404:  BSF    0A.4
0405:  GOTO   06D (RETURN)
.................... }
.................... 
.................... void lcd_dis_xx_yy_zz(usi8 x, usi8 y, usi8 a, usi8 b, usi8 c, bool e3, bool e2, bool e1){
....................    usi8 a_ch, a_dv, b_ch, b_dv, c_ch, c_dv;
....................    a_ch = e3 == true ? a/10 + 0x30 : 0x20; a_dv = e3 == true ? a%10 + 0x30 : 0x20;
*
0652:  BSF    03.5
0653:  DECFSZ 2B,W
0654:  GOTO   65F
0655:  MOVF   28,W
0656:  MOVWF  34
0657:  MOVLW  0A
0658:  MOVWF  35
0659:  BCF    03.5
065A:  CALL   63B
065B:  MOVLW  30
065C:  ADDWF  78,W
065D:  GOTO   661
065E:  BSF    03.5
065F:  MOVLW  20
0660:  BCF    03.5
0661:  BSF    03.5
0662:  MOVWF  2E
0663:  DECFSZ 2B,W
0664:  GOTO   66F
0665:  MOVF   28,W
0666:  MOVWF  34
0667:  MOVLW  0A
0668:  MOVWF  35
0669:  BCF    03.5
066A:  CALL   63B
066B:  MOVLW  30
066C:  ADDWF  77,W
066D:  GOTO   671
066E:  BSF    03.5
066F:  MOVLW  20
0670:  BCF    03.5
0671:  BSF    03.5
0672:  MOVWF  2F
....................    b_ch = e2 == true ? b/10 + 0x30 : 0x20; b_dv = e2 == true ? b%10 + 0x30 : 0x20;
0673:  DECFSZ 2C,W
0674:  GOTO   67F
0675:  MOVF   29,W
0676:  MOVWF  34
0677:  MOVLW  0A
0678:  MOVWF  35
0679:  BCF    03.5
067A:  CALL   63B
067B:  MOVLW  30
067C:  ADDWF  78,W
067D:  GOTO   681
067E:  BSF    03.5
067F:  MOVLW  20
0680:  BCF    03.5
0681:  BSF    03.5
0682:  MOVWF  30
0683:  DECFSZ 2C,W
0684:  GOTO   68F
0685:  MOVF   29,W
0686:  MOVWF  34
0687:  MOVLW  0A
0688:  MOVWF  35
0689:  BCF    03.5
068A:  CALL   63B
068B:  MOVLW  30
068C:  ADDWF  77,W
068D:  GOTO   691
068E:  BSF    03.5
068F:  MOVLW  20
0690:  BCF    03.5
0691:  BSF    03.5
0692:  MOVWF  31
....................    c_ch = e1 == true ? c/10 + 0x30 : 0x20; c_dv = e1 == true ? c%10 + 0x30 : 0x20;
0693:  DECFSZ 2D,W
0694:  GOTO   69F
0695:  MOVF   2A,W
0696:  MOVWF  34
0697:  MOVLW  0A
0698:  MOVWF  35
0699:  BCF    03.5
069A:  CALL   63B
069B:  MOVLW  30
069C:  ADDWF  78,W
069D:  GOTO   6A1
069E:  BSF    03.5
069F:  MOVLW  20
06A0:  BCF    03.5
06A1:  BSF    03.5
06A2:  MOVWF  32
06A3:  DECFSZ 2D,W
06A4:  GOTO   6AF
06A5:  MOVF   2A,W
06A6:  MOVWF  34
06A7:  MOVLW  0A
06A8:  MOVWF  35
06A9:  BCF    03.5
06AA:  CALL   63B
06AB:  MOVLW  30
06AC:  ADDWF  77,W
06AD:  GOTO   6B1
06AE:  BSF    03.5
06AF:  MOVLW  20
06B0:  BCF    03.5
06B1:  BSF    03.5
06B2:  MOVWF  33
....................    lcd_setCursor(x, y);
06B3:  MOVF   26,W
06B4:  MOVWF  34
06B5:  MOVF   27,W
06B6:  MOVWF  35
06B7:  BCF    03.5
06B8:  CALL   330
....................    lcd_data(a_ch); lcd_data(a_dv); lcd_data("-");
06B9:  BSF    03.5
06BA:  MOVF   2E,W
06BB:  MOVWF  37
06BC:  BCF    03.5
06BD:  CALL   34F
06BE:  BSF    03.5
06BF:  MOVF   2F,W
06C0:  MOVWF  37
06C1:  BCF    03.5
06C2:  CALL   34F
06C3:  MOVLW  EC
06C4:  BSF    03.6
06C5:  MOVWF  0D
06C6:  MOVLW  00
06C7:  MOVWF  0F
06C8:  BCF    03.6
06C9:  CALL   36C
....................    lcd_data(b_ch); lcd_data(b_dv); lcd_data("-");
06CA:  BSF    03.5
06CB:  MOVF   30,W
06CC:  MOVWF  37
06CD:  BCF    03.5
06CE:  CALL   34F
06CF:  BSF    03.5
06D0:  MOVF   31,W
06D1:  MOVWF  37
06D2:  BCF    03.5
06D3:  CALL   34F
06D4:  MOVLW  ED
06D5:  BSF    03.6
06D6:  MOVWF  0D
06D7:  MOVLW  00
06D8:  MOVWF  0F
06D9:  BCF    03.6
06DA:  CALL   36C
....................    lcd_data(c_ch); lcd_data(c_dv);
06DB:  BSF    03.5
06DC:  MOVF   32,W
06DD:  MOVWF  37
06DE:  BCF    03.5
06DF:  CALL   34F
06E0:  BSF    03.5
06E1:  MOVF   33,W
06E2:  MOVWF  37
06E3:  BCF    03.5
06E4:  CALL   34F
06E5:  RETURN
.................... }
.................... 
.................... void lcd_dis_2num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 ch, dv;
....................    lcd_setCursor(x, y);
06E6:  BSF    03.5
06E7:  MOVF   25,W
06E8:  MOVWF  34
06E9:  MOVF   26,W
06EA:  MOVWF  35
06EB:  BCF    03.5
06EC:  CALL   330
....................    ch = dt/10 + 0x30;
06ED:  BSF    03.5
06EE:  MOVF   24,W
06EF:  MOVWF  2F
06F0:  MOVF   23,W
06F1:  MOVWF  2E
06F2:  CLRF   31
06F3:  MOVLW  0A
06F4:  MOVWF  30
06F5:  BCF    03.5
06F6:  CALL   526
06F7:  MOVF   79,W
06F8:  BSF    03.5
06F9:  MOVWF  2C
06FA:  MOVF   78,W
06FB:  MOVWF  2B
06FC:  MOVLW  30
06FD:  ADDWF  2B,W
06FE:  MOVWF  29
....................    dv = dt%10 + 0x30;
06FF:  MOVF   24,W
0700:  MOVWF  2F
0701:  MOVF   23,W
0702:  MOVWF  2E
0703:  CLRF   31
0704:  MOVLW  0A
0705:  MOVWF  30
0706:  BCF    03.5
0707:  CALL   526
0708:  MOVF   77,W
0709:  BSF    03.5
070A:  MOVWF  2B
070B:  MOVF   7A,W
070C:  MOVWF  2C
070D:  MOVLW  30
070E:  ADDWF  2B,W
070F:  MOVWF  2A
....................    if(is_xvn == true) if(ch == 0x30) ch = 0x20;
0710:  DECFSZ 27,W
0711:  GOTO   718
0712:  MOVF   29,W
0713:  SUBLW  30
0714:  BTFSS  03.2
0715:  GOTO   718
0716:  MOVLW  20
0717:  MOVWF  29
....................    if(is_dot == true) lcd_data(".");
0718:  DECFSZ 28,W
0719:  GOTO   723
071A:  MOVLW  EE
071B:  BCF    03.5
071C:  BSF    03.6
071D:  MOVWF  0D
071E:  MOVLW  00
071F:  MOVWF  0F
0720:  BCF    03.6
0721:  CALL   36C
0722:  BSF    03.5
....................    lcd_data(ch); lcd_data(dv);
0723:  MOVF   29,W
0724:  MOVWF  37
0725:  BCF    03.5
0726:  CALL   34F
0727:  BSF    03.5
0728:  MOVF   2A,W
0729:  MOVWF  37
072A:  BCF    03.5
072B:  CALL   34F
072C:  RETURN
.................... }
.................... 
.................... void lcd_dis_3num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 tr, ch, dv;
....................    lcd_setCursor(x, y); //xxx /10 -> xx 
*
075B:  MOVF   25,W
075C:  MOVWF  34
075D:  MOVF   26,W
075E:  MOVWF  35
075F:  BCF    03.5
0760:  CALL   330
....................    tr = dt/100 + 0x30; 
0761:  BSF    03.5
0762:  MOVF   24,W
0763:  MOVWF  2F
0764:  MOVF   23,W
0765:  MOVWF  2E
0766:  CLRF   31
0767:  MOVLW  64
0768:  MOVWF  30
0769:  BCF    03.5
076A:  CALL   526
076B:  MOVF   79,W
076C:  BSF    03.5
076D:  MOVWF  2D
076E:  MOVF   78,W
076F:  MOVWF  2C
0770:  MOVLW  30
0771:  ADDWF  2C,W
0772:  MOVWF  29
....................    ch = dt/10%10  + 0x30;
0773:  MOVF   24,W
0774:  MOVWF  2F
0775:  MOVF   23,W
0776:  MOVWF  2E
0777:  CLRF   31
0778:  MOVLW  0A
0779:  MOVWF  30
077A:  BCF    03.5
077B:  CALL   526
077C:  MOVF   79,W
077D:  BSF    03.5
077E:  MOVWF  2D
077F:  MOVF   78,W
0780:  MOVWF  2C
0781:  MOVF   2D,W
0782:  MOVWF  2F
0783:  MOVF   2C,W
0784:  MOVWF  2E
0785:  CLRF   31
0786:  MOVLW  0A
0787:  MOVWF  30
0788:  BCF    03.5
0789:  CALL   526
078A:  MOVF   77,W
078B:  BSF    03.5
078C:  MOVWF  2C
078D:  MOVF   7A,W
078E:  MOVWF  2D
078F:  MOVLW  30
0790:  ADDWF  2C,W
0791:  MOVWF  2A
....................    dv = dt%10     + 0x30;
0792:  MOVF   24,W
0793:  MOVWF  2F
0794:  MOVF   23,W
0795:  MOVWF  2E
0796:  CLRF   31
0797:  MOVLW  0A
0798:  MOVWF  30
0799:  BCF    03.5
079A:  CALL   526
079B:  MOVF   77,W
079C:  BSF    03.5
079D:  MOVWF  2C
079E:  MOVF   7A,W
079F:  MOVWF  2D
07A0:  MOVLW  30
07A1:  ADDWF  2C,W
07A2:  MOVWF  2B
....................    if(is_xvn == true) if(tr == 0x30){
07A3:  DECFSZ 27,W
07A4:  GOTO   7B1
07A5:  MOVF   29,W
07A6:  SUBLW  30
07A7:  BTFSS  03.2
07A8:  GOTO   7B1
....................       tr = 0x20;
07A9:  MOVLW  20
07AA:  MOVWF  29
....................       if(ch == 0x30) ch = 0x20;
07AB:  MOVF   2A,W
07AC:  SUBLW  30
07AD:  BTFSS  03.2
07AE:  GOTO   7B1
07AF:  MOVLW  20
07B0:  MOVWF  2A
....................    }
....................    if(is_dot == true) lcd_data(".");
07B1:  DECFSZ 28,W
07B2:  GOTO   7BC
07B3:  MOVLW  EF
07B4:  BCF    03.5
07B5:  BSF    03.6
07B6:  MOVWF  0D
07B7:  MOVLW  00
07B8:  MOVWF  0F
07B9:  BCF    03.6
07BA:  CALL   36C
07BB:  BSF    03.5
....................    lcd_data(tr); lcd_data(ch); lcd_data(dv);
07BC:  MOVF   29,W
07BD:  MOVWF  37
07BE:  BCF    03.5
07BF:  CALL   34F
07C0:  BSF    03.5
07C1:  MOVF   2A,W
07C2:  MOVWF  37
07C3:  BCF    03.5
07C4:  CALL   34F
07C5:  BSF    03.5
07C6:  MOVF   2B,W
07C7:  MOVWF  37
07C8:  BCF    03.5
07C9:  CALL   34F
.................... }
.................... 
.................... void lcd_dis_temperature (int8 x, int8 y, usi16 ng, usi16 th){
....................    lcd_setCursor(x,y);
*
072D:  MOVF   7B,W
072E:  BSF    03.5
072F:  MOVWF  34
0730:  MOVF   7C,W
0731:  MOVWF  35
0732:  BCF    03.5
0733:  CALL   330
....................    lcd_data("ND: ");
0734:  MOVLW  F0
0735:  BSF    03.6
0736:  MOVWF  0D
0737:  MOVLW  00
0738:  MOVWF  0F
0739:  BCF    03.6
073A:  CALL   36C
....................    lcd_dis_2num_dot(ng, x + 4, y, true, false);
073B:  MOVLW  04
073C:  ADDWF  7B,W
073D:  BSF    03.5
073E:  MOVWF  22
073F:  MOVF   7E,W
0740:  MOVWF  24
0741:  MOVF   7D,W
0742:  MOVWF  23
0743:  MOVF   22,W
0744:  MOVWF  25
0745:  MOVF   7C,W
0746:  MOVWF  26
0747:  MOVLW  01
0748:  MOVWF  27
0749:  CLRF   28
074A:  BCF    03.5
074B:  CALL   6E6
....................    lcd_dis_3num_dot(th, x + 6, y, false, true);
074C:  MOVLW  06
074D:  ADDWF  7B,W
074E:  BSF    03.5
074F:  MOVWF  22
0750:  MOVF   21,W
0751:  MOVWF  24
0752:  MOVF   20,W
0753:  MOVWF  23
0754:  MOVF   22,W
0755:  MOVWF  25
0756:  MOVF   7C,W
0757:  MOVWF  26
0758:  CLRF   27
0759:  MOVLW  01
075A:  MOVWF  28
....................    lcd_data(" oC");
*
07CA:  MOVLW  F3
07CB:  BSF    03.6
07CC:  MOVWF  0D
07CD:  MOVLW  00
07CE:  MOVWF  0F
07CF:  BCF    03.6
07D0:  CALL   36C
07D1:  RETURN
.................... }
.................... 
.................... void lcd_dis_temperature_limit (int8 x, int8 y, usi16 ng){
....................    lcd_setCursor(x,y);
*
12EB:  MOVF   7B,W
12EC:  BSF    03.5
12ED:  MOVWF  34
12EE:  MOVF   7C,W
12EF:  MOVWF  35
12F0:  BCF    0A.4
12F1:  BCF    03.5
12F2:  CALL   330
12F3:  BSF    0A.4
....................    lcd_data("ND-GH: ");
12F4:  MOVLW  F5
12F5:  BSF    03.6
12F6:  MOVWF  0D
12F7:  MOVLW  00
12F8:  MOVWF  0F
12F9:  BCF    0A.4
12FA:  BCF    03.6
12FB:  CALL   36C
12FC:  BSF    0A.4
....................    lcd_dis_2num_dot(ng, x + 7, y, true, false);
12FD:  MOVLW  07
12FE:  ADDWF  7B,W
12FF:  BSF    03.5
1300:  MOVWF  20
1301:  MOVF   7E,W
1302:  MOVWF  24
1303:  MOVF   7D,W
1304:  MOVWF  23
1305:  MOVF   20,W
1306:  MOVWF  25
1307:  MOVF   7C,W
1308:  MOVWF  26
1309:  MOVLW  01
130A:  MOVWF  27
130B:  CLRF   28
130C:  BCF    0A.4
130D:  BCF    03.5
130E:  CALL   6E6
130F:  BSF    0A.4
....................    lcd_data(" oC");
1310:  MOVLW  F9
1311:  BSF    03.6
1312:  MOVWF  0D
1313:  MOVLW  00
1314:  MOVWF  0F
1315:  BCF    0A.4
1316:  BCF    03.6
1317:  CALL   36C
1318:  BSF    0A.4
.................... }
.................... 
.................... #include <library_ds1307_i2c.c>
.................... #define ds13_addr_wr 0xd0
.................... #define ds13_addr_rd 0xd1
.................... 
.................... //cap nhat time: giay-phut-gio-thu-ngay-thang-nam-madk_msds
.................... usi8 time_w[9]={0x31,0x15,0x15,0x04,0x25,0x10,0x23,0x90,0x91};
*
103D:  MOVLW  31
103E:  MOVWF  65
103F:  MOVLW  15
1040:  MOVWF  66
1041:  MOVWF  67
1042:  MOVLW  04
1043:  MOVWF  68
1044:  MOVLW  25
1045:  MOVWF  69
1046:  MOVLW  10
1047:  MOVWF  6A
1048:  MOVLW  23
1049:  MOVWF  6B
104A:  MOVLW  90
104B:  MOVWF  6C
104C:  MOVLW  91
104D:  MOVWF  6D
.................... usi8 time_r[9]={0x30,0x30,0x10,0x08,0x20,0x02,0x20,0x90,0x91};
104E:  MOVLW  30
104F:  MOVWF  6E
1050:  MOVWF  6F
1051:  MOVLW  10
1052:  MOVWF  70
1053:  MOVLW  08
1054:  MOVWF  71
1055:  MOVLW  20
1056:  MOVWF  72
1057:  MOVLW  02
1058:  MOVWF  73
1059:  MOVLW  20
105A:  MOVWF  74
105B:  MOVLW  90
105C:  MOVWF  75
105D:  MOVLW  91
105E:  MOVWF  76
.................... 
.................... #define dec_giay_eat  ds1307_bcdToDec(eat_ss)
.................... #define dec_phut_eat  ds1307_bcdToDec(eat_pp)
.................... #define dec_gio_eat   ds1307_bcdToDec(eat_hh)
.................... 
.................... #define dec_giay_ds  ds1307_bcdToDec(time_r[0])
.................... #define dec_phut_ds  ds1307_bcdToDec(time_r[1])
.................... #define dec_gio_ds   ds1307_bcdToDec(time_r[2])
.................... #define dec_thu_ds   ds1307_bcdToDec(time_r[3])
.................... #define dec_ngay_ds  ds1307_bcdToDec(time_r[4])
.................... #define dec_thang_ds ds1307_bcdToDec(time_r[5])
.................... #define dec_nam_ds   ds1307_bcdToDec(time_r[6])
.................... 
.................... #define giay_ds  time_r[0]
.................... #define phut_ds  time_r[1]
.................... #define gio_ds   time_r[2]
.................... #define thu_ds   time_r[3]
.................... #define ngay_ds  time_r[4]
.................... #define thang_ds time_r[5]
.................... #define nam_ds   time_r[6]
.................... 
.................... #define ma_qd   time_w[8]
.................... #define ma_ds   time_r[8]
.................... 
.................... usi8 ds1307_decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
.................... }
.................... 
.................... usi8 ds1307_bcdToDec(usi8 val) {
....................     return ((val / 16 * 10) + (val % 16));
*
0626:  BSF    03.5
0627:  SWAPF  22,W
0628:  MOVWF  77
0629:  MOVLW  0F
062A:  ANDWF  77,F
062B:  MOVF   77,W
062C:  MOVWF  24
062D:  MOVWF  25
062E:  MOVLW  0A
062F:  MOVWF  26
0630:  BCF    03.5
0631:  CALL   5FF
0632:  MOVF   78,W
0633:  BSF    03.5
0634:  MOVWF  23
0635:  MOVF   22,W
0636:  ANDLW  0F
0637:  ADDWF  23,W
0638:  MOVWF  78
0639:  BCF    03.5
063A:  RETURN
.................... }
.................... 
.................... void ds1307_read_time(usi8 j)     
.................... {   
....................    usi8 i; 
....................    i2c_start();
*
018F:  BSF    03.5
0190:  BSF    11.0
0191:  BTFSC  11.0
0192:  GOTO   191
....................    i2c_write(ds13_addr_wr);
0193:  MOVLW  D0
0194:  MOVWF  47
0195:  BCF    03.5
0196:  CALL   16D
....................    i2c_write(0x00);                     
0197:  BSF    03.5
0198:  CLRF   47
0199:  BCF    03.5
019A:  CALL   16D
....................    i2c_start();               
019B:  BSF    03.5
019C:  BSF    11.1
019D:  BTFSC  11.1
019E:  GOTO   19D
....................    i2c_write(ds13_addr_rd);                              
019F:  MOVLW  D1
01A0:  MOVWF  47
01A1:  BCF    03.5
01A2:  CALL   16D
....................    for(i=0;i<j;i++) time_r[i]=i2c_read();
01A3:  CLRF   7C
01A4:  MOVF   7B,W
01A5:  SUBWF  7C,W
01A6:  BTFSC  03.0
01A7:  GOTO   1B3
01A8:  MOVLW  6E
01A9:  ADDWF  7C,W
01AA:  MOVWF  04
01AB:  BCF    03.7
01AC:  MOVLW  01
01AD:  MOVWF  77
01AE:  CALL   17F
01AF:  MOVF   78,W
01B0:  MOVWF  00
01B1:  INCF   7C,F
01B2:  GOTO   1A4
....................                                  
....................    i = i2c_read(0); //not ack, don't care i  
01B3:  CLRF   77
01B4:  CALL   17F
01B5:  MOVF   78,W
01B6:  MOVWF  7C
....................    i2c_stop();
01B7:  BSF    03.5
01B8:  BSF    11.2
01B9:  BTFSC  11.2
01BA:  GOTO   1B9
01BB:  BCF    03.5
01BC:  RETURN
.................... }
.................... 
.................... void ds1307_update_time(int1 sel)                 
.................... {         
....................    usi8 i;
....................    i2c_start();
*
01C6:  BSF    03.5
01C7:  BSF    11.0
01C8:  BTFSC  11.0
01C9:  GOTO   1C8
....................    i2c_write(ds13_addr_wr);
01CA:  MOVLW  D0
01CB:  MOVWF  47
01CC:  BCF    03.5
01CD:  CALL   16D
....................    i2c_write(0x00);
01CE:  BSF    03.5
01CF:  CLRF   47
01D0:  BCF    03.5
01D1:  CALL   16D
....................    for(i=0;i<9;i++)                          
01D2:  CLRF   7C
01D3:  MOVF   7C,W
01D4:  SUBLW  08
01D5:  BTFSS  03.0
01D6:  GOTO   1F1
....................    {  
....................       if(sel)  i2c_write(time_w[i]);
01D7:  MOVF   7B,F
01D8:  BTFSC  03.2
01D9:  GOTO   1E5
01DA:  MOVLW  65
01DB:  ADDWF  7C,W
01DC:  MOVWF  04
01DD:  BCF    03.7
01DE:  MOVF   00,W
01DF:  MOVWF  7D
01E0:  BSF    03.5
01E1:  MOVWF  47
01E2:  BCF    03.5
01E3:  CALL   16D
01E4:  GOTO   1EF
....................       else     i2c_write(time_r[i]);
01E5:  MOVLW  6E
01E6:  ADDWF  7C,W
01E7:  MOVWF  04
01E8:  BCF    03.7
01E9:  MOVF   00,W
01EA:  MOVWF  7D
01EB:  BSF    03.5
01EC:  MOVWF  47
01ED:  BCF    03.5
01EE:  CALL   16D
01EF:  INCF   7C,F
01F0:  GOTO   1D3
....................    }                                 
....................    i2c_stop();        
01F1:  BSF    03.5
01F2:  BSF    11.2
01F3:  BTFSC  11.2
01F4:  GOTO   1F3
01F5:  BCF    03.5
.................... }  
.................... 
.................... void ds1307_setup()
.................... {                                              
....................    ds1307_read_time(9);          
*
01BD:  MOVLW  09
01BE:  MOVWF  7B
01BF:  CALL   18F
....................    if(ma_qd!=ma_ds)
01C0:  MOVF   76,W
01C1:  SUBWF  6D,W
01C2:  BTFSC  03.2
01C3:  GOTO   1F6
....................    {
....................       ds1307_update_time(1);
01C4:  MOVLW  01
01C5:  MOVWF  7B
....................    }
*
01F6:  BCF    0A.3
01F7:  BSF    0A.4
01F8:  GOTO   064 (RETURN)
.................... }
.................... 
.................... void ds1307_save_ds(usi8 dcdt,dt)                 
.................... {           
....................    i2c_start();
*
09C2:  BSF    03.5
09C3:  BSF    11.0
09C4:  BTFSC  11.0
09C5:  GOTO   1C4
....................    i2c_write(ds13_addr_wr);        
09C6:  MOVLW  D0
09C7:  MOVWF  47
09C8:  BCF    0A.3
09C9:  BCF    03.5
09CA:  CALL   16D
09CB:  BSF    0A.3
....................    i2c_write(dcdt);    
09CC:  MOVF   7B,W
09CD:  BSF    03.5
09CE:  MOVWF  47
09CF:  BCF    0A.3
09D0:  BCF    03.5
09D1:  CALL   16D
09D2:  BSF    0A.3
....................    i2c_write(dt);
09D3:  MOVF   7C,W
09D4:  BSF    03.5
09D5:  MOVWF  47
09D6:  BCF    0A.3
09D7:  BCF    03.5
09D8:  CALL   16D
09D9:  BSF    0A.3
....................    i2c_stop();
09DA:  BSF    03.5
09DB:  BSF    11.2
09DC:  BTFSC  11.2
09DD:  GOTO   1DC
09DE:  BCF    03.5
09DF:  RETURN
.................... }
.................... 
.................... #include <library_ds18b20.c>
.................... #include <touch.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                        Dallas Touch Driver                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    ////
.................... ////                                                                   ////
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  present = touch_present()   Issues a reset and returns true      ////
.................... ////                              if the touch device is there.        ////
.................... ////                                                                   ////
.................... ////  reset_pulse()               Issues a reset and waits for a       ////
.................... ////                              present pulse.                       ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef  TOUCH_C
.................... #define  TOUCH_C
.................... 
.................... #ifndef TOUCH_PIN
....................    #define TOUCH_PIN  PIN_B0
.................... #endif
.................... 
.................... #define TOUCH_PIN_LOW()    output_drive(TOUCH_PIN); output_low(TOUCH_PIN)
.................... #define TOUCH_PIN_HIGH()    output_drive(TOUCH_PIN); output_high(TOUCH_PIN)
.................... #define TOUCH_PIN_FLOAT()  output_float(TOUCH_PIN)
.................... #define TOUCH_PIN_READ()      input_state(TOUCH_PIN)
.................... 
.................... /////////////////////////////
.................... ////                     ////
.................... //// Function Prototypes ////
.................... ////                     ////
.................... /////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit();
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte();
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data);
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data);
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present();
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse();
.................... 
.................... //////////////////////////////////
.................... ////                          ////
.................... //// Function Implementations ////
.................... ////                          ////
.................... //////////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit()
.................... {
....................    int1 data;
.................... 
....................    TOUCH_PIN_LOW();
....................    delay_us(14);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    data = TOUCH_PIN_READ();
....................    delay_us(100);
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte()
.................... {
....................    BYTE i,data;
.................... 
....................    for(i=1; i <= 8; ++i)
....................       shift_right(&data, 1, touch_read_bit());
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data)
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(10);
....................    if(data)
....................    {
....................       TOUCH_PIN_HIGH();
....................       delay_us(10);
....................       if(!TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    else
....................    {
....................       TOUCH_PIN_LOW();
....................       delay_us(10);
....................       if(TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    delay_us(50);
....................    TOUCH_PIN_HIGH();
....................    delay_us(50);
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data)
.................... {
....................    BYTE i;
.................... 
....................    for(i=1; i<=8; ++i)
....................       if(!touch_write_bit(shift_right(&data, 1, 0)))
....................          return FALSE;
.................... 
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present()
.................... {
....................    BOOLEAN present;
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
.................... 
....................    if(!TOUCH_PIN_READ())
....................       return FALSE;
.................... 
....................    delay_us(65);
....................    present = !TOUCH_PIN_READ();
....................    delay_us(240);
....................    return present;
.................... }
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse()
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    while(!touch_present());
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define search_rom       0xf0
.................... #define read_rom         0x33
.................... #define match_rom        0x55
.................... #define skip_rom         0xcc
.................... #define alarm_search     0xec
.................... #define read_scratchpad  0xbe
.................... #define write_scratchpad 0x4e
.................... #define copy_scratchpad  0x48
.................... #define convert_t        0x44
.................... 
.................... bool ds18b20_start(){
....................    output_low(pin_ds18b20);
*
0497:  BCF    05.0
....................    output_drive(pin_ds18b20);
0498:  BSF    03.5
0499:  BCF    05.0
....................    delay_us(500);
049A:  MOVLW  02
049B:  MOVWF  20
049C:  MOVLW  F9
049D:  MOVWF  21
049E:  BCF    03.5
049F:  CALL   304
04A0:  BSF    03.5
04A1:  DECFSZ 20,F
04A2:  GOTO   49C
....................    output_float(pin_ds18b20);
04A3:  BSF    05.0
....................    delay_us(100);
04A4:  MOVLW  A6
04A5:  MOVWF  77
04A6:  DECFSZ 77,F
04A7:  GOTO   4A6
04A8:  NOP
....................    if(!input(pin_ds18b20)){
04A9:  BCF    03.5
04AA:  BTFSC  05.0
04AB:  GOTO   4BA
....................       delay_us(400);
04AC:  MOVLW  02
04AD:  BSF    03.5
04AE:  MOVWF  20
04AF:  MOVLW  C7
04B0:  MOVWF  21
04B1:  BCF    03.5
04B2:  CALL   304
04B3:  BSF    03.5
04B4:  DECFSZ 20,F
04B5:  GOTO   4AF
....................       return true;
04B6:  MOVLW  01
04B7:  MOVWF  78
04B8:  GOTO   4BD
04B9:  BCF    03.5
....................    }
....................    return false;
04BA:  MOVLW  00
04BB:  MOVWF  78
04BC:  BSF    03.5
04BD:  BCF    03.5
04BE:  RETURN
.................... }
.................... 
.................... void ds18b20_write_bit(bool value){
....................    output_low(pin_ds18b20);
*
04D5:  BCF    03.5
04D6:  BCF    05.0
....................    output_drive(pin_ds18b20);
04D7:  BSF    03.5
04D8:  BCF    05.0
....................    delay_us(2);
04D9:  MOVLW  03
04DA:  MOVWF  77
04DB:  DECFSZ 77,F
04DC:  GOTO   4DB
....................    output_bit(pin_ds18b20, value);
04DD:  MOVF   23,F
04DE:  BTFSS  03.2
04DF:  GOTO   4E4
04E0:  BCF    03.5
04E1:  BCF    05.0
04E2:  GOTO   4E6
04E3:  BSF    03.5
04E4:  BCF    03.5
04E5:  BSF    05.0
....................    delay_us(80);
04E6:  MOVLW  85
04E7:  MOVWF  77
04E8:  DECFSZ 77,F
04E9:  GOTO   4E8
....................    output_float(pin_ds18b20);
04EA:  BSF    03.5
04EB:  BSF    05.0
....................    delay_us(2);
04EC:  MOVLW  03
04ED:  MOVWF  77
04EE:  DECFSZ 77,F
04EF:  GOTO   4EE
.................... }
.................... 
.................... void ds18b20_write_byte(int8 value){
....................    for(int8 i = 0; i < 8; i++)
*
04BF:  BSF    03.5
04C0:  CLRF   21
04C1:  MOVF   21,W
04C2:  SUBLW  07
04C3:  BTFSS  03.0
04C4:  GOTO   4F2
....................       ds18b20_write_bit(bit_test(value,i));
04C5:  MOVF   20,W
04C6:  MOVWF  77
04C7:  MOVF   21,W
04C8:  MOVWF  78
04C9:  BTFSC  03.2
04CA:  GOTO   4CF
04CB:  BCF    03.0
04CC:  RRF    77,F
04CD:  DECFSZ 78,F
04CE:  GOTO   4CB
04CF:  MOVLW  00
04D0:  BTFSC  77.0
04D1:  MOVLW  01
04D2:  MOVWF  22
04D3:  MOVF   22,W
04D4:  MOVWF  23
*
04F0:  INCF   21,F
04F1:  GOTO   4C1
04F2:  BCF    03.5
04F3:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_bit(){
....................    bool value;
....................    output_low(pin_ds18b20);
*
04FB:  BCF    03.5
04FC:  BCF    05.0
....................    output_drive(pin_ds18b20);
04FD:  BSF    03.5
04FE:  BCF    05.0
....................    delay_us(2);
04FF:  MOVLW  03
0500:  MOVWF  77
0501:  DECFSZ 77,F
0502:  GOTO   501
....................    output_float(pin_ds18b20);
0503:  BSF    05.0
....................    delay_us(5);
0504:  MOVLW  08
0505:  MOVWF  77
0506:  DECFSZ 77,F
0507:  GOTO   506
....................    value = input(pin_ds18b20);
0508:  BCF    26.0
0509:  BCF    03.5
050A:  BTFSS  05.0
050B:  GOTO   50F
050C:  BSF    03.5
050D:  BSF    26.0
050E:  BCF    03.5
....................    delay_us(100);
050F:  MOVLW  A6
0510:  MOVWF  77
0511:  DECFSZ 77,F
0512:  GOTO   511
0513:  NOP
....................    return value;
0514:  MOVLW  00
0515:  BSF    03.5
0516:  BTFSC  26.0
0517:  MOVLW  01
0518:  MOVWF  78
.................... }
.................... 
.................... int8 ds18b20_read_byte(){
*
04F4:  BSF    03.5
04F5:  CLRF   24
....................    int8 value = 0;
....................    for(int8 i = 0; i < 8; i++)
04F6:  CLRF   25
04F7:  MOVF   25,W
04F8:  SUBLW  07
04F9:  BTFSS  03.0
04FA:  GOTO   522
....................       shift_right(&value,1,ds18b20_read_bit());
*
0519:  MOVF   78,F
051A:  BTFSS  03.2
051B:  GOTO   51E
051C:  BCF    03.0
051D:  GOTO   51F
051E:  BSF    03.0
051F:  RRF    24,F
0520:  INCF   25,F
0521:  GOTO   4F7
....................    return value;
0522:  MOVF   24,W
0523:  MOVWF  78
0524:  BCF    03.5
0525:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_temp_c2(usi16 *raw_temp_value){
....................    if(!ds18b20_start())
*
0550:  CALL   497
0551:  MOVF   78,F
0552:  BTFSS  03.2
0553:  GOTO   557
....................       return false;
0554:  MOVLW  00
0555:  MOVWF  78
0556:  GOTO   5BA
....................    ds18b20_write_byte(skip_rom);
0557:  MOVLW  CC
0558:  BSF    03.5
0559:  MOVWF  20
055A:  BCF    03.5
055B:  CALL   4BF
....................    ds18b20_write_byte(convert_t);
055C:  MOVLW  44
055D:  BSF    03.5
055E:  MOVWF  20
055F:  BCF    03.5
0560:  CALL   4BF
....................    while(ds18b20_read_byte() == 0);
0561:  CALL   4F4
0562:  MOVF   78,F
0563:  BTFSC  03.2
0564:  GOTO   561
....................    if(!ds18b20_start())
0565:  CALL   497
0566:  MOVF   78,F
0567:  BTFSS  03.2
0568:  GOTO   56C
....................       return false;
0569:  MOVLW  00
056A:  MOVWF  78
056B:  GOTO   5BA
....................    ds18b20_write_byte(skip_rom);
056C:  MOVLW  CC
056D:  BSF    03.5
056E:  MOVWF  20
056F:  BCF    03.5
0570:  CALL   4BF
....................    ds18b20_write_byte(read_scratchpad);
0571:  MOVLW  BE
0572:  BSF    03.5
0573:  MOVWF  20
0574:  BCF    03.5
0575:  CALL   4BF
....................    *raw_temp_value = ds18b20_read_byte();
0576:  MOVF   7C,W
0577:  MOVWF  7A
0578:  MOVF   7B,W
0579:  BSF    03.5
057A:  MOVWF  20
057B:  MOVF   7C,W
057C:  MOVWF  21
057D:  BCF    03.5
057E:  CALL   4F4
057F:  BSF    03.5
0580:  MOVF   20,W
0581:  MOVWF  04
0582:  BCF    03.7
0583:  BTFSC  21.0
0584:  BSF    03.7
0585:  INCF   04,F
0586:  CLRF   00
0587:  DECF   04,F
0588:  MOVF   78,W
0589:  MOVWF  00
....................    *raw_temp_value |= (int16)(ds18b20_read_byte()) << 8;
058A:  MOVF   7C,W
058B:  MOVWF  7A
058C:  MOVF   7B,W
058D:  MOVWF  20
058E:  MOVF   7C,W
058F:  MOVWF  21
0590:  MOVF   20,W
0591:  MOVWF  04
0592:  BCF    03.7
0593:  BTFSC  21.0
0594:  BSF    03.7
0595:  INCF   04,F
0596:  MOVF   00,W
0597:  MOVWF  23
0598:  DECF   04,F
0599:  MOVF   00,W
059A:  MOVWF  22
059B:  BCF    03.5
059C:  CALL   4F4
059D:  BSF    03.5
059E:  CLRF   25
059F:  MOVF   78,W
05A0:  MOVWF  24
05A1:  MOVWF  7A
05A2:  MOVLW  00
05A3:  IORWF  22,W
05A4:  MOVWF  77
05A5:  MOVF   7A,W
05A6:  IORWF  23,W
05A7:  MOVWF  7A
05A8:  MOVF   77,W
05A9:  MOVWF  22
05AA:  MOVF   7A,W
05AB:  MOVWF  23
05AC:  MOVF   20,W
05AD:  MOVWF  04
05AE:  BCF    03.7
05AF:  BTFSC  21.0
05B0:  BSF    03.7
05B1:  INCF   04,F
05B2:  MOVF   23,W
05B3:  MOVWF  00
05B4:  DECF   04,F
05B5:  MOVF   22,W
05B6:  MOVWF  00
....................    return true;
05B7:  MOVLW  01
05B8:  MOVWF  78
05B9:  BCF    03.5
.................... }
.................... 
.................... void ds18b20_read_temp(){
....................    if(ds18b20_read_temp_c2(&temperature)){
*
054D:  CLRF   7C
054E:  MOVLW  3E
054F:  MOVWF  7B
*
05BA:  MOVF   78,F
05BB:  BTFSC  03.2
05BC:  GOTO   5FD
....................       isDs18b20 = true;
05BD:  BSF    2C.4
....................       dt_ng = temperature>>4;
05BE:  RRF    3F,W
05BF:  MOVWF  7A
05C0:  RRF    3E,W
05C1:  MOVWF  79
05C2:  RRF    7A,F
05C3:  RRF    79,F
05C4:  RRF    7A,F
05C5:  RRF    79,F
05C6:  RRF    7A,F
05C7:  RRF    79,F
05C8:  MOVF   79,W
05C9:  MOVWF  40
....................       tt = temperature & 0x000f;
05CA:  MOVF   3E,W
05CB:  ANDLW  0F
05CC:  MOVWF  43
05CD:  CLRF   44
....................       dt_tp = (tt*625)/10;
05CE:  MOVF   44,W
05CF:  MOVWF  7C
05D0:  MOVF   43,W
05D1:  MOVWF  7B
05D2:  MOVLW  02
05D3:  MOVWF  7E
05D4:  MOVLW  71
05D5:  MOVWF  7D
*
05EB:  MOVF   79,W
05EC:  MOVWF  7C
05ED:  MOVF   78,W
05EE:  MOVWF  7B
05EF:  MOVF   79,W
05F0:  MOVWF  2F
05F1:  MOVF   78,W
05F2:  MOVWF  2E
05F3:  CLRF   31
05F4:  MOVLW  0A
05F5:  MOVWF  30
05F6:  BCF    03.5
05F7:  CALL   526
05F8:  MOVF   79,W
05F9:  MOVWF  42
05FA:  MOVF   78,W
05FB:  MOVWF  41
....................    }
05FC:  GOTO   5FE
....................    else isDs18b20 = false;
05FD:  BCF    2C.4
05FE:  RETURN
.................... }
.................... 
.................... #include <library_change_rtc.c>
.................... 
.................... usi8 tang_or_giam_bcd(unsigned int8 x, int1 sel){
....................    usi8 y, dv, ch, v;
....................    ch = (x>>4);
*
0987:  SWAPF  7B,W
0988:  BSF    03.5
0989:  MOVWF  20
098A:  MOVLW  0F
098B:  ANDWF  20,F
....................    dv = x& 0x0f;
098C:  MOVF   7B,W
098D:  ANDLW  0F
098E:  MOVWF  7E
....................    y = ch*10 + dv;
098F:  MOVF   20,W
0990:  MOVWF  25
0991:  MOVLW  0A
0992:  MOVWF  26
0993:  BCF    0A.3
0994:  BCF    03.5
0995:  CALL   5FF
0996:  BSF    0A.3
0997:  MOVF   7E,W
0998:  ADDWF  78,W
0999:  MOVWF  7D
....................    if(sel == 0) y++;
099A:  MOVF   7C,F
099B:  BTFSS  03.2
099C:  GOTO   19F
099D:  INCF   7D,F
099E:  GOTO   1A0
....................    else         y--;
099F:  DECF   7D,F
....................    ch = y/10; dv = y%10;
09A0:  MOVF   7D,W
09A1:  BSF    03.5
09A2:  MOVWF  34
09A3:  MOVLW  0A
09A4:  MOVWF  35
09A5:  BCF    0A.3
09A6:  BCF    03.5
09A7:  CALL   63B
09A8:  BSF    0A.3
09A9:  MOVF   78,W
09AA:  BSF    03.5
09AB:  MOVWF  20
09AC:  MOVF   7D,W
09AD:  MOVWF  34
09AE:  MOVLW  0A
09AF:  MOVWF  35
09B0:  BCF    0A.3
09B1:  BCF    03.5
09B2:  CALL   63B
09B3:  BSF    0A.3
09B4:  MOVF   77,W
09B5:  MOVWF  7E
....................    v = (ch<<4)|dv;
09B6:  BSF    03.5
09B7:  SWAPF  20,W
09B8:  MOVWF  77
09B9:  MOVLW  F0
09BA:  ANDWF  77,F
09BB:  MOVF   77,W
09BC:  IORWF  7E,W
09BD:  MOVWF  21
....................    return v;
09BE:  MOVF   21,W
09BF:  MOVWF  78
09C0:  BCF    03.5
09C1:  RETURN
.................... }
.................... 
.................... void tat_bat_2led_chinh(){
....................    if(gt_mod == 1 || gt_mod == 4) { e_11 = ~e_11; e_22 = true; e_33 = true;}
*
0889:  DECFSZ 35,W
088A:  GOTO   08C
088B:  GOTO   090
088C:  MOVF   35,W
088D:  SUBLW  04
088E:  BTFSS  03.2
088F:  GOTO   095
0890:  MOVLW  20
0891:  XORWF  2C,F
0892:  BSF    2C.6
0893:  BSF    2C.7
0894:  GOTO   0B2
....................    else if(gt_mod == 2 || gt_mod == 5) { e_11 = true; e_22 = ~e_22; e_33 = true;}
0895:  MOVF   35,W
0896:  SUBLW  02
0897:  BTFSC  03.2
0898:  GOTO   09D
0899:  MOVF   35,W
089A:  SUBLW  05
089B:  BTFSS  03.2
089C:  GOTO   0A2
089D:  BSF    2C.5
089E:  MOVLW  40
089F:  XORWF  2C,F
08A0:  BSF    2C.7
08A1:  GOTO   0B2
....................    else if(gt_mod == 3 || gt_mod == 6) { e_11 = true; e_22 = true; e_33 = ~e_33;}
08A2:  MOVF   35,W
08A3:  SUBLW  03
08A4:  BTFSC  03.2
08A5:  GOTO   0AA
08A6:  MOVF   35,W
08A7:  SUBLW  06
08A8:  BTFSS  03.2
08A9:  GOTO   0AF
08AA:  BSF    2C.5
08AB:  BSF    2C.6
08AC:  MOVLW  80
08AD:  XORWF  2C,F
08AE:  GOTO   0B2
....................    else { e_11 = true; e_22 = true; e_33 = true;}
08AF:  BSF    2C.5
08B0:  BSF    2C.6
08B1:  BSF    2C.7
.................... }
.................... 
.................... void giai_ma_gpg_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_ds,dec_phut_ds,dec_giay_ds,e_33, e_22, e_11);
*
08B7:  MOVF   70,W
08B8:  BSF    03.5
08B9:  MOVWF  22
08BA:  BCF    0A.3
08BB:  BCF    03.5
08BC:  CALL   626
08BD:  BSF    0A.3
08BE:  MOVF   78,W
08BF:  BSF    03.5
08C0:  MOVWF  20
08C1:  BCF    03.5
08C2:  MOVF   6F,W
08C3:  BSF    03.5
08C4:  MOVWF  22
08C5:  BCF    0A.3
08C6:  BCF    03.5
08C7:  CALL   626
08C8:  BSF    0A.3
08C9:  MOVF   78,W
08CA:  BSF    03.5
08CB:  MOVWF  21
08CC:  BCF    03.5
08CD:  MOVF   6E,W
08CE:  BSF    03.5
08CF:  MOVWF  22
08D0:  BCF    0A.3
08D1:  BCF    03.5
08D2:  CALL   626
08D3:  BSF    0A.3
08D4:  MOVF   78,W
08D5:  BSF    03.5
08D6:  MOVWF  22
08D7:  MOVLW  00
08D8:  BCF    03.5
08D9:  BTFSC  2C.7
08DA:  MOVLW  01
08DB:  BSF    03.5
08DC:  MOVWF  23
08DD:  MOVLW  00
08DE:  BCF    03.5
08DF:  BTFSC  2C.6
08E0:  MOVLW  01
08E1:  BSF    03.5
08E2:  MOVWF  24
08E3:  MOVLW  00
08E4:  BCF    03.5
08E5:  BTFSC  2C.5
08E6:  MOVLW  01
08E7:  BSF    03.5
08E8:  MOVWF  25
08E9:  MOVLW  04
08EA:  MOVWF  26
08EB:  MOVLW  01
08EC:  MOVWF  27
08ED:  MOVF   20,W
08EE:  MOVWF  28
08EF:  MOVF   21,W
08F0:  MOVWF  29
08F1:  MOVF   22,W
08F2:  MOVWF  2A
08F3:  MOVF   23,W
08F4:  MOVWF  2B
08F5:  MOVF   24,W
08F6:  MOVWF  2C
08F7:  MOVF   25,W
08F8:  MOVWF  2D
08F9:  BCF    0A.3
08FA:  BCF    03.5
08FB:  CALL   652
08FC:  BSF    0A.3
08FD:  RETURN
.................... }
.................... 
.................... void giai_ma_ntn_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_ngay_ds,dec_thang_ds,dec_nam_ds,e_33, e_22, e_11);
08FE:  MOVF   72,W
08FF:  BSF    03.5
0900:  MOVWF  22
0901:  BCF    0A.3
0902:  BCF    03.5
0903:  CALL   626
0904:  BSF    0A.3
0905:  MOVF   78,W
0906:  BSF    03.5
0907:  MOVWF  20
0908:  MOVF   73,W
0909:  MOVWF  22
090A:  BCF    0A.3
090B:  BCF    03.5
090C:  CALL   626
090D:  BSF    0A.3
090E:  MOVF   78,W
090F:  BSF    03.5
0910:  MOVWF  21
0911:  MOVF   74,W
0912:  MOVWF  22
0913:  BCF    0A.3
0914:  BCF    03.5
0915:  CALL   626
0916:  BSF    0A.3
0917:  MOVF   78,W
0918:  BSF    03.5
0919:  MOVWF  22
091A:  MOVLW  00
091B:  BCF    03.5
091C:  BTFSC  2C.7
091D:  MOVLW  01
091E:  BSF    03.5
091F:  MOVWF  23
0920:  MOVLW  00
0921:  BCF    03.5
0922:  BTFSC  2C.6
0923:  MOVLW  01
0924:  BSF    03.5
0925:  MOVWF  24
0926:  MOVLW  00
0927:  BCF    03.5
0928:  BTFSC  2C.5
0929:  MOVLW  01
092A:  BSF    03.5
092B:  MOVWF  25
092C:  MOVLW  04
092D:  MOVWF  26
092E:  MOVLW  01
092F:  MOVWF  27
0930:  MOVF   20,W
0931:  MOVWF  28
0932:  MOVF   21,W
0933:  MOVWF  29
0934:  MOVF   22,W
0935:  MOVWF  2A
0936:  MOVF   23,W
0937:  MOVWF  2B
0938:  MOVF   24,W
0939:  MOVWF  2C
093A:  MOVF   25,W
093B:  MOVWF  2D
093C:  BCF    0A.3
093D:  BCF    03.5
093E:  CALL   652
093F:  BSF    0A.3
0940:  RETURN
.................... }
.................... 
.................... void giai_ma_thu_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,0x00,dec_thu_ds,0x00,0, e_22, 0);
0941:  MOVF   71,W
0942:  BSF    03.5
0943:  MOVWF  22
0944:  BCF    0A.3
0945:  BCF    03.5
0946:  CALL   626
0947:  BSF    0A.3
0948:  MOVF   78,W
0949:  MOVWF  7B
094A:  MOVLW  00
094B:  BTFSC  2C.6
094C:  MOVLW  01
094D:  MOVWF  7C
094E:  MOVLW  04
094F:  BSF    03.5
0950:  MOVWF  26
0951:  MOVLW  01
0952:  MOVWF  27
0953:  CLRF   28
0954:  MOVF   78,W
0955:  MOVWF  29
0956:  CLRF   2A
0957:  CLRF   2B
0958:  MOVF   7C,W
0959:  MOVWF  2C
095A:  CLRF   2D
095B:  BCF    0A.3
095C:  BCF    03.5
095D:  CALL   652
095E:  BSF    0A.3
095F:  RETURN
.................... }
.................... 
.................... void giai_ma_gpg_ntn_thu_lcd(){
....................    if(gt_mod == 0){
0960:  MOVF   35,F
0961:  BTFSS  03.2
0962:  GOTO   172
....................       if(tt_ht == 0 || tt_ht == 1) giai_ma_gpg_lcd();
0963:  MOVF   34,F
0964:  BTFSC  03.2
0965:  GOTO   168
0966:  DECFSZ 34,W
0967:  GOTO   169
0968:  CALL   0B7
....................       if(tt_ht == 2) giai_ma_ntn_lcd();
0969:  MOVF   34,W
096A:  SUBLW  02
096B:  BTFSC  03.2
096C:  CALL   0FE
....................       if(tt_ht == 3) giai_ma_thu_lcd();
096D:  MOVF   34,W
096E:  SUBLW  03
096F:  BTFSC  03.2
0970:  CALL   141
....................    }
0971:  GOTO   186
....................    else{
....................       if(gt_mod < 4)       giai_ma_gpg_lcd();
0972:  BTFSC  35.7
0973:  GOTO   178
0974:  MOVF   35,W
0975:  SUBLW  03
0976:  BTFSS  03.0
0977:  GOTO   17A
0978:  CALL   0B7
0979:  GOTO   186
....................       else if(gt_mod < 7)  giai_ma_ntn_lcd();
097A:  BTFSC  35.7
097B:  GOTO   180
097C:  MOVF   35,W
097D:  SUBLW  06
097E:  BTFSS  03.0
097F:  GOTO   182
0980:  CALL   0FE
0981:  GOTO   186
....................       else if(gt_mod == 7) giai_ma_thu_lcd();
0982:  MOVF   35,W
0983:  SUBLW  07
0984:  BTFSC  03.2
0985:  CALL   141
....................    }
0986:  RETURN
.................... }
.................... 
.................... void xu_ly_choptat(){
....................    if(gt_mod != 0){
*
0886:  MOVF   35,F
0887:  BTFSC  03.2
0888:  GOTO   0B3
....................       tat_bat_2led_chinh();
....................    }
*
08B2:  GOTO   0B6
....................    else { e_11 = true; e_22 = true; e_33 = true;}
08B3:  BSF    2C.5
08B4:  BSF    2C.6
08B5:  BSF    2C.7
08B6:  RETURN
....................    
.................... }
.................... 
.................... void phim_chon_hthi_mode(){
....................    if(tick_btn(2, bt3)){
*
1349:  MOVLW  02
134A:  MOVWF  7B
134B:  MOVLW  33
134C:  MOVWF  7C
134D:  BCF    0A.4
134E:  BSF    0A.3
134F:  CALL   06B
1350:  BSF    0A.4
1351:  BCF    0A.3
1352:  MOVF   78,F
1353:  BTFSC  03.2
1354:  GOTO   37C
....................       tt_ht = 1;
1355:  MOVLW  01
1356:  MOVWF  34
....................       if(tt_ht == 1){
1357:  DECFSZ 34,W
1358:  GOTO   376
....................          gt_mod++;
1359:  INCF   35,F
....................          if(gt_mod < 4) tt_ht = 1;
135A:  BTFSC  35.7
135B:  GOTO   360
135C:  MOVF   35,W
135D:  SUBLW  03
135E:  BTFSS  03.0
135F:  GOTO   363
1360:  MOVLW  01
1361:  MOVWF  34
1362:  GOTO   376
....................          else if(gt_mod < 7) tt_ht = 2;
1363:  BTFSC  35.7
1364:  GOTO   369
1365:  MOVF   35,W
1366:  SUBLW  06
1367:  BTFSS  03.0
1368:  GOTO   36C
1369:  MOVLW  02
136A:  MOVWF  34
136B:  GOTO   376
....................          else if(gt_mod == 7) tt_ht = 3;
136C:  MOVF   35,W
136D:  SUBLW  07
136E:  BTFSS  03.2
136F:  GOTO   373
1370:  MOVLW  03
1371:  MOVWF  34
1372:  GOTO   376
....................          else{
....................             gt_mod = 0;
1373:  CLRF   35
....................             tt_ht = 0;
1374:  CLRF   34
....................             countLevel = 0;
1375:  CLRF   3A
....................          }
....................       }
....................       tg_chinh = 0;
1376:  CLRF   36
....................       giai_ma_gpg_ntn_thu_lcd();
1377:  BCF    0A.4
1378:  BSF    0A.3
1379:  CALL   160
137A:  BSF    0A.4
137B:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay(){
....................    if(giay_ds == 0x59) giay_ds = 0;
*
139A:  MOVF   6E,W
139B:  SUBLW  59
139C:  BTFSS  03.2
139D:  GOTO   3A0
139E:  CLRF   6E
139F:  GOTO   3AA
....................    else giay_ds = tang_or_giam_bcd(giay_ds, tang);
13A0:  MOVF   6E,W
13A1:  MOVWF  7B
13A2:  CLRF   7C
13A3:  BCF    0A.4
13A4:  BSF    0A.3
13A5:  CALL   187
13A6:  BSF    0A.4
13A7:  BCF    0A.3
13A8:  MOVF   78,W
13A9:  MOVWF  6E
....................    ds1307_save_ds(0,giay_ds);
13AA:  CLRF   7B
13AB:  MOVF   6E,W
13AC:  MOVWF  7C
13AD:  BCF    0A.4
13AE:  BSF    0A.3
13AF:  CALL   1C2
13B0:  BSF    0A.4
13B1:  BCF    0A.3
.................... }
.................... void tang_phut(){
....................    if(phut_ds == 0x59) phut_ds = 0;
*
13B3:  MOVF   6F,W
13B4:  SUBLW  59
13B5:  BTFSS  03.2
13B6:  GOTO   3B9
13B7:  CLRF   6F
13B8:  GOTO   3C3
....................    else phut_ds = tang_or_giam_bcd(phut_ds, tang);
13B9:  MOVF   6F,W
13BA:  MOVWF  7B
13BB:  CLRF   7C
13BC:  BCF    0A.4
13BD:  BSF    0A.3
13BE:  CALL   187
13BF:  BSF    0A.4
13C0:  BCF    0A.3
13C1:  MOVF   78,W
13C2:  MOVWF  6F
....................    ds1307_save_ds(1,phut_ds);
13C3:  MOVLW  01
13C4:  MOVWF  7B
13C5:  MOVF   6F,W
13C6:  MOVWF  7C
13C7:  BCF    0A.4
13C8:  BSF    0A.3
13C9:  CALL   1C2
13CA:  BSF    0A.4
13CB:  BCF    0A.3
.................... }
.................... void tang_gio(){
....................    if(gio_ds == 0x23) gio_ds = 0;
*
13CD:  MOVF   70,W
13CE:  SUBLW  23
13CF:  BTFSS  03.2
13D0:  GOTO   3D3
13D1:  CLRF   70
13D2:  GOTO   3DD
....................    else gio_ds = tang_or_giam_bcd(gio_ds, tang);
13D3:  MOVF   70,W
13D4:  MOVWF  7B
13D5:  CLRF   7C
13D6:  BCF    0A.4
13D7:  BSF    0A.3
13D8:  CALL   187
13D9:  BSF    0A.4
13DA:  BCF    0A.3
13DB:  MOVF   78,W
13DC:  MOVWF  70
....................    ds1307_save_ds(2,gio_ds);
13DD:  MOVLW  02
13DE:  MOVWF  7B
13DF:  MOVF   70,W
13E0:  MOVWF  7C
13E1:  BCF    0A.4
13E2:  BSF    0A.3
13E3:  CALL   1C2
13E4:  BSF    0A.4
13E5:  BCF    0A.3
.................... }
.................... void chinh_tang_gpg(){
....................    switch(gt_mod){
*
138F:  MOVF   35,W
1390:  XORLW  01
1391:  BTFSC  03.2
1392:  GOTO   39A
1393:  XORLW  03
1394:  BTFSC  03.2
1395:  GOTO   3B3
1396:  XORLW  01
1397:  BTFSC  03.2
1398:  GOTO   3CD
1399:  GOTO   3E7
....................       case 1:
....................          tang_giay();
....................          break;
*
13B2:  GOTO   3E8
....................       case 2:
....................          tang_phut();
....................          break;
*
13CC:  GOTO   3E8
....................       case 3:
....................          tang_gio();
....................          break;
*
13E6:  GOTO   3E8
....................       default: break;
13E7:  GOTO   3E8
....................    }
.................... }
.................... void tang_nam(){
....................    if(nam_ds == 0x99) nam_ds = 0;
*
13FA:  MOVF   74,W
13FB:  SUBLW  99
13FC:  BTFSS  03.2
13FD:  GOTO   400
13FE:  CLRF   74
13FF:  GOTO   40A
....................    else nam_ds = tang_or_giam_bcd(nam_ds, tang);
1400:  MOVF   74,W
1401:  MOVWF  7B
1402:  CLRF   7C
1403:  BCF    0A.4
1404:  BSF    0A.3
1405:  CALL   187
1406:  BSF    0A.4
1407:  BCF    0A.3
1408:  MOVF   78,W
1409:  MOVWF  74
....................    ds1307_save_ds(6,nam_ds);
140A:  MOVLW  06
140B:  MOVWF  7B
140C:  MOVF   74,W
140D:  MOVWF  7C
140E:  BCF    0A.4
140F:  BSF    0A.3
1410:  CALL   1C2
1411:  BSF    0A.4
1412:  BCF    0A.3
.................... }
.................... void tang_thang(){
....................    if(thang_ds == 0x12) thang_ds = 1;
*
1414:  MOVF   73,W
1415:  SUBLW  12
1416:  BTFSS  03.2
1417:  GOTO   41B
1418:  MOVLW  01
1419:  MOVWF  73
141A:  GOTO   425
....................    else thang_ds = tang_or_giam_bcd(thang_ds, tang);
141B:  MOVF   73,W
141C:  MOVWF  7B
141D:  CLRF   7C
141E:  BCF    0A.4
141F:  BSF    0A.3
1420:  CALL   187
1421:  BSF    0A.4
1422:  BCF    0A.3
1423:  MOVF   78,W
1424:  MOVWF  73
....................    ds1307_save_ds(5,thang_ds);
1425:  MOVLW  05
1426:  MOVWF  7B
1427:  MOVF   73,W
1428:  MOVWF  7C
1429:  BCF    0A.4
142A:  BSF    0A.3
142B:  CALL   1C2
142C:  BSF    0A.4
142D:  BCF    0A.3
.................... }
.................... void tang_ngay(){
....................    if(ngay_ds == 0x31) ngay_ds = 1;
*
142F:  MOVF   72,W
1430:  SUBLW  31
1431:  BTFSS  03.2
1432:  GOTO   436
1433:  MOVLW  01
1434:  MOVWF  72
1435:  GOTO   440
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, tang);
1436:  MOVF   72,W
1437:  MOVWF  7B
1438:  CLRF   7C
1439:  BCF    0A.4
143A:  BSF    0A.3
143B:  CALL   187
143C:  BSF    0A.4
143D:  BCF    0A.3
143E:  MOVF   78,W
143F:  MOVWF  72
....................    ds1307_save_ds(4,ngay_ds);
1440:  MOVLW  04
1441:  MOVWF  7B
1442:  MOVF   72,W
1443:  MOVWF  7C
1444:  BCF    0A.4
1445:  BSF    0A.3
1446:  CALL   1C2
1447:  BSF    0A.4
1448:  BCF    0A.3
.................... }
.................... void chinh_tang_ntn(){
....................    switch(gt_mod){
*
13EF:  MOVF   35,W
13F0:  XORLW  04
13F1:  BTFSC  03.2
13F2:  GOTO   3FA
13F3:  XORLW  01
13F4:  BTFSC  03.2
13F5:  GOTO   414
13F6:  XORLW  03
13F7:  BTFSC  03.2
13F8:  GOTO   42F
13F9:  GOTO   44A
....................       case 4:
....................          tang_nam();
....................          break;
*
1413:  GOTO   44B
....................       case 5:
....................          tang_thang();
....................          break;
*
142E:  GOTO   44B
....................       case 6:
....................          tang_ngay();
....................          break;
*
1449:  GOTO   44B
....................       default: break;
144A:  GOTO   44B
....................    }
.................... }
.................... void chinh_tang_thu(){
....................    if(thu_ds == 8) thu_ds = 2;
*
1450:  MOVF   71,W
1451:  SUBLW  08
1452:  BTFSS  03.2
1453:  GOTO   457
1454:  MOVLW  02
1455:  MOVWF  71
1456:  GOTO   458
....................    else thu_ds++;
1457:  INCF   71,F
....................    ds1307_save_ds(3,thu_ds);
1458:  MOVLW  03
1459:  MOVWF  7B
145A:  MOVF   71,W
145B:  MOVWF  7C
145C:  BCF    0A.4
145D:  BSF    0A.3
145E:  CALL   1C2
145F:  BSF    0A.4
1460:  BCF    0A.3
.................... }
.................... 
.................... void phim_up(){
....................    if(tick_btn(1, bt1)){
*
137C:  MOVLW  01
137D:  MOVWF  7B
137E:  MOVLW  31
137F:  MOVWF  7C
1380:  BCF    0A.4
1381:  BSF    0A.3
1382:  CALL   06B
1383:  BSF    0A.4
1384:  BCF    0A.3
1385:  MOVF   78,F
1386:  BTFSC  03.2
1387:  GOTO   469
....................       tg_chinh = 0;
1388:  CLRF   36
....................       if(gt_mod<4) chinh_tang_gpg();
1389:  BTFSC  35.7
138A:  GOTO   38F
138B:  MOVF   35,W
138C:  SUBLW  03
138D:  BTFSS  03.0
138E:  GOTO   3E9
*
13E8:  GOTO   461
....................       else if(gt_mod<7) chinh_tang_ntn();
13E9:  BTFSC  35.7
13EA:  GOTO   3EF
13EB:  MOVF   35,W
13EC:  SUBLW  06
13ED:  BTFSS  03.0
13EE:  GOTO   44C
*
144B:  GOTO   461
....................       else if(gt_mod==7) chinh_tang_thu();
144C:  MOVF   35,W
144D:  SUBLW  07
144E:  BTFSS  03.2
144F:  GOTO   461
....................       e_11 = true; e_22 = true; e_33 = true;
*
1461:  BSF    2C.5
1462:  BSF    2C.6
1463:  BSF    2C.7
....................       giai_ma_gpg_ntn_thu_lcd();
1464:  BCF    0A.4
1465:  BSF    0A.3
1466:  CALL   160
1467:  BSF    0A.4
1468:  BCF    0A.3
....................    }
.................... }
.................... void giam_giay(){
....................    if(giay_ds == 0) giay_ds = 0x59;
*
1487:  MOVF   6E,F
1488:  BTFSS  03.2
1489:  GOTO   48D
148A:  MOVLW  59
148B:  MOVWF  6E
148C:  GOTO   498
....................    else giay_ds = tang_or_giam_bcd(giay_ds,giam);
148D:  MOVF   6E,W
148E:  MOVWF  7B
148F:  MOVLW  01
1490:  MOVWF  7C
1491:  BCF    0A.4
1492:  BSF    0A.3
1493:  CALL   187
1494:  BSF    0A.4
1495:  BCF    0A.3
1496:  MOVF   78,W
1497:  MOVWF  6E
....................    ds1307_save_ds(0,giay_ds);
1498:  CLRF   7B
1499:  MOVF   6E,W
149A:  MOVWF  7C
149B:  BCF    0A.4
149C:  BSF    0A.3
149D:  CALL   1C2
149E:  BSF    0A.4
149F:  BCF    0A.3
.................... }
.................... void giam_phut(){
....................    if(phut_ds == 0) phut_ds = 0x59;
*
14A1:  MOVF   6F,F
14A2:  BTFSS  03.2
14A3:  GOTO   4A7
14A4:  MOVLW  59
14A5:  MOVWF  6F
14A6:  GOTO   4B2
....................    else phut_ds = tang_or_giam_bcd(phut_ds,giam);
14A7:  MOVF   6F,W
14A8:  MOVWF  7B
14A9:  MOVLW  01
14AA:  MOVWF  7C
14AB:  BCF    0A.4
14AC:  BSF    0A.3
14AD:  CALL   187
14AE:  BSF    0A.4
14AF:  BCF    0A.3
14B0:  MOVF   78,W
14B1:  MOVWF  6F
....................    ds1307_save_ds(1,phut_ds);
14B2:  MOVLW  01
14B3:  MOVWF  7B
14B4:  MOVF   6F,W
14B5:  MOVWF  7C
14B6:  BCF    0A.4
14B7:  BSF    0A.3
14B8:  CALL   1C2
14B9:  BSF    0A.4
14BA:  BCF    0A.3
.................... }
.................... void giam_gio(){
....................    if(gio_ds == 0) gio_ds = 0x23;
*
14BC:  MOVF   70,F
14BD:  BTFSS  03.2
14BE:  GOTO   4C2
14BF:  MOVLW  23
14C0:  MOVWF  70
14C1:  GOTO   4CD
....................    else gio_ds = tang_or_giam_bcd(gio_ds,giam);
14C2:  MOVF   70,W
14C3:  MOVWF  7B
14C4:  MOVLW  01
14C5:  MOVWF  7C
14C6:  BCF    0A.4
14C7:  BSF    0A.3
14C8:  CALL   187
14C9:  BSF    0A.4
14CA:  BCF    0A.3
14CB:  MOVF   78,W
14CC:  MOVWF  70
....................    ds1307_save_ds(2,gio_ds);
14CD:  MOVLW  02
14CE:  MOVWF  7B
14CF:  MOVF   70,W
14D0:  MOVWF  7C
14D1:  BCF    0A.4
14D2:  BSF    0A.3
14D3:  CALL   1C2
14D4:  BSF    0A.4
14D5:  BCF    0A.3
.................... }
.................... void chinh_giam_gpg(){
....................    switch(gt_mod){
*
147C:  MOVF   35,W
147D:  XORLW  01
147E:  BTFSC  03.2
147F:  GOTO   487
1480:  XORLW  03
1481:  BTFSC  03.2
1482:  GOTO   4A1
1483:  XORLW  01
1484:  BTFSC  03.2
1485:  GOTO   4BC
1486:  GOTO   4D7
....................       case 1:
....................          giam_giay();
....................          break;
*
14A0:  GOTO   4D8
....................       case 2:
....................          giam_phut();
....................          break;
*
14BB:  GOTO   4D8
....................       case 3:
....................          giam_gio();
....................          break;
*
14D6:  GOTO   4D8
....................       default: break;
14D7:  GOTO   4D8
....................    }
.................... }
.................... void giam_nam(){
....................    if(nam_ds == 0x0) nam_ds = 0x99;
*
14EA:  MOVF   74,F
14EB:  BTFSS  03.2
14EC:  GOTO   4F0
14ED:  MOVLW  99
14EE:  MOVWF  74
14EF:  GOTO   4FB
....................    else nam_ds = tang_or_giam_bcd(nam_ds, giam);
14F0:  MOVF   74,W
14F1:  MOVWF  7B
14F2:  MOVLW  01
14F3:  MOVWF  7C
14F4:  BCF    0A.4
14F5:  BSF    0A.3
14F6:  CALL   187
14F7:  BSF    0A.4
14F8:  BCF    0A.3
14F9:  MOVF   78,W
14FA:  MOVWF  74
....................    ds1307_save_ds(6,nam_ds);
14FB:  MOVLW  06
14FC:  MOVWF  7B
14FD:  MOVF   74,W
14FE:  MOVWF  7C
14FF:  BCF    0A.4
1500:  BSF    0A.3
1501:  CALL   1C2
1502:  BSF    0A.4
1503:  BCF    0A.3
.................... }
.................... void giam_thang(){
....................    if(thang_ds == 0x1) thang_ds = 12;
*
1505:  DECFSZ 73,W
1506:  GOTO   50A
1507:  MOVLW  0C
1508:  MOVWF  73
1509:  GOTO   515
....................    else thang_ds = tang_or_giam_bcd(thang_ds, giam);
150A:  MOVF   73,W
150B:  MOVWF  7B
150C:  MOVLW  01
150D:  MOVWF  7C
150E:  BCF    0A.4
150F:  BSF    0A.3
1510:  CALL   187
1511:  BSF    0A.4
1512:  BCF    0A.3
1513:  MOVF   78,W
1514:  MOVWF  73
....................    ds1307_save_ds(5,thang_ds);
1515:  MOVLW  05
1516:  MOVWF  7B
1517:  MOVF   73,W
1518:  MOVWF  7C
1519:  BCF    0A.4
151A:  BSF    0A.3
151B:  CALL   1C2
151C:  BSF    0A.4
151D:  BCF    0A.3
.................... }
.................... void giam_ngay(){
....................    if(ngay_ds == 0x1) ngay_ds = 21;
*
151F:  DECFSZ 72,W
1520:  GOTO   524
1521:  MOVLW  15
1522:  MOVWF  72
1523:  GOTO   52F
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, giam);
1524:  MOVF   72,W
1525:  MOVWF  7B
1526:  MOVLW  01
1527:  MOVWF  7C
1528:  BCF    0A.4
1529:  BSF    0A.3
152A:  CALL   187
152B:  BSF    0A.4
152C:  BCF    0A.3
152D:  MOVF   78,W
152E:  MOVWF  72
....................    ds1307_save_ds(4,ngay_ds);
152F:  MOVLW  04
1530:  MOVWF  7B
1531:  MOVF   72,W
1532:  MOVWF  7C
1533:  BCF    0A.4
1534:  BSF    0A.3
1535:  CALL   1C2
1536:  BSF    0A.4
1537:  BCF    0A.3
.................... }
.................... void chinh_giam_ntn(){
....................    switch(gt_mod){
*
14DF:  MOVF   35,W
14E0:  XORLW  04
14E1:  BTFSC  03.2
14E2:  GOTO   4EA
14E3:  XORLW  01
14E4:  BTFSC  03.2
14E5:  GOTO   505
14E6:  XORLW  03
14E7:  BTFSC  03.2
14E8:  GOTO   51F
14E9:  GOTO   539
....................       case 4:
....................          giam_nam();
....................          break;
*
1504:  GOTO   53A
....................       case 5:
....................          giam_thang();
....................          break;
*
151E:  GOTO   53A
....................       case 6:
....................          giam_ngay();
....................          break;
*
1538:  GOTO   53A
....................       default: break;
1539:  GOTO   53A
....................    }
.................... }
.................... void chinh_giam_thu(){
....................    if(thu_ds == 2) thu_ds = 8;
*
153F:  MOVF   71,W
1540:  SUBLW  02
1541:  BTFSS  03.2
1542:  GOTO   546
1543:  MOVLW  08
1544:  MOVWF  71
1545:  GOTO   547
....................    else thu_ds--;
1546:  DECF   71,F
....................    ds1307_save_ds(3,thu_ds);
1547:  MOVLW  03
1548:  MOVWF  7B
1549:  MOVF   71,W
154A:  MOVWF  7C
154B:  BCF    0A.4
154C:  BSF    0A.3
154D:  CALL   1C2
154E:  BSF    0A.4
154F:  BCF    0A.3
.................... }
.................... void phim_dw(){
....................    if(tick_btn(1, bt2)){
*
1469:  MOVLW  01
146A:  MOVWF  7B
146B:  MOVLW  32
146C:  MOVWF  7C
146D:  BCF    0A.4
146E:  BSF    0A.3
146F:  CALL   06B
1470:  BSF    0A.4
1471:  BCF    0A.3
1472:  MOVF   78,F
1473:  BTFSC  03.2
1474:  GOTO   558
....................       tg_chinh = 0;
1475:  CLRF   36
....................       if(gt_mod<4) chinh_giam_gpg();
1476:  BTFSC  35.7
1477:  GOTO   47C
1478:  MOVF   35,W
1479:  SUBLW  03
147A:  BTFSS  03.0
147B:  GOTO   4D9
*
14D8:  GOTO   550
....................       else if(gt_mod<7) chinh_giam_ntn();
14D9:  BTFSC  35.7
14DA:  GOTO   4DF
14DB:  MOVF   35,W
14DC:  SUBLW  06
14DD:  BTFSS  03.0
14DE:  GOTO   53B
*
153A:  GOTO   550
....................       else if(gt_mod==7) chinh_giam_thu();
153B:  MOVF   35,W
153C:  SUBLW  07
153D:  BTFSS  03.2
153E:  GOTO   550
....................       e_11 = true; e_22 = true; e_33 = true;
*
1550:  BSF    2C.5
1551:  BSF    2C.6
1552:  BSF    2C.7
....................       giai_ma_gpg_ntn_thu_lcd();
1553:  BCF    0A.4
1554:  BSF    0A.3
1555:  CALL   160
1556:  BSF    0A.4
1557:  BCF    0A.3
....................    }
.................... }
.................... void log_mode(){
....................    lcd_setCursor(0, 1);
*
1576:  BSF    03.5
1577:  CLRF   34
1578:  MOVLW  01
1579:  MOVWF  35
157A:  BCF    0A.4
157B:  BCF    03.5
157C:  CALL   330
157D:  BSF    0A.4
....................    if(tt_ht == 0) lcd_data(" N ");
157E:  MOVF   34,F
157F:  BTFSS  03.2
1580:  GOTO   58B
1581:  MOVLW  FB
1582:  BSF    03.6
1583:  MOVWF  0D
1584:  MOVLW  00
1585:  MOVWF  0F
1586:  BCF    0A.4
1587:  BCF    03.6
1588:  CALL   36C
1589:  BSF    0A.4
158A:  GOTO   5B2
....................    else if(tt_ht == 1) lcd_data("GPG");
158B:  DECFSZ 34,W
158C:  GOTO   597
158D:  MOVLW  FD
158E:  BSF    03.6
158F:  MOVWF  0D
1590:  MOVLW  00
1591:  MOVWF  0F
1592:  BCF    0A.4
1593:  BCF    03.6
1594:  CALL   36C
1595:  BSF    0A.4
1596:  GOTO   5B2
....................    else if(tt_ht == 2) lcd_data("NTN");
1597:  MOVF   34,W
1598:  SUBLW  02
1599:  BTFSS  03.2
159A:  GOTO   5A5
159B:  MOVLW  FF
159C:  BSF    03.6
159D:  MOVWF  0D
159E:  MOVLW  00
159F:  MOVWF  0F
15A0:  BCF    0A.4
15A1:  BCF    03.6
15A2:  CALL   36C
15A3:  BSF    0A.4
15A4:  GOTO   5B2
....................    else if(tt_ht == 3) lcd_data(" T ");
15A5:  MOVF   34,W
15A6:  SUBLW  03
15A7:  BTFSS  03.2
15A8:  GOTO   5B2
15A9:  MOVLW  01
15AA:  BSF    03.6
15AB:  MOVWF  0D
15AC:  MOVLW  01
15AD:  MOVWF  0F
15AE:  BCF    0A.4
15AF:  BCF    03.6
15B0:  CALL   36C
15B1:  BSF    0A.4
....................    lcd_setCursor(13, 1);
15B2:  MOVLW  0D
15B3:  BSF    03.5
15B4:  MOVWF  34
15B5:  MOVLW  01
15B6:  MOVWF  35
15B7:  BCF    0A.4
15B8:  BCF    03.5
15B9:  CALL   330
15BA:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
15BB:  MOVLW  30
15BC:  ADDWF  35,W
15BD:  MOVWF  7B
15BE:  BSF    03.5
15BF:  MOVWF  37
15C0:  BCF    0A.4
15C1:  BCF    03.5
15C2:  CALL   34F
15C3:  BSF    0A.4
....................    if(gt_mod != 0){
15C4:  MOVF   35,F
15C5:  BTFSC  03.2
15C6:  GOTO   5EC
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
15C7:  MOVF   36,W
15C8:  MOVWF  7B
15C9:  MOVLW  0A
15CA:  MOVWF  7C
15CB:  BCF    0A.4
15CC:  BSF    0A.3
15CD:  CALL   1E0
15CE:  BSF    0A.4
15CF:  BCF    0A.3
15D0:  MOVLW  30
15D1:  ADDWF  78,W
15D2:  MOVWF  7B
15D3:  BSF    03.5
15D4:  MOVWF  37
15D5:  BCF    0A.4
15D6:  BCF    03.5
15D7:  CALL   34F
15D8:  BSF    0A.4
15D9:  MOVF   36,W
15DA:  MOVWF  7B
15DB:  MOVLW  0A
15DC:  MOVWF  7C
15DD:  BCF    0A.4
15DE:  BSF    0A.3
15DF:  CALL   1E0
15E0:  BSF    0A.4
15E1:  BCF    0A.3
15E2:  MOVLW  30
15E3:  ADDWF  77,W
15E4:  MOVWF  7B
15E5:  BSF    03.5
15E6:  MOVWF  37
15E7:  BCF    0A.4
15E8:  BCF    03.5
15E9:  CALL   34F
15EA:  BSF    0A.4
....................    }
15EB:  GOTO   5F5
....................    else
....................       lcd_data("__");
15EC:  MOVLW  03
15ED:  BSF    03.6
15EE:  MOVWF  0D
15EF:  MOVLW  01
15F0:  MOVWF  0F
15F1:  BCF    0A.4
15F2:  BCF    03.6
15F3:  CALL   36C
15F4:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_change_alarm_eat.c>
.................... void giai_ma_gpg_alarm_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_eat,dec_phut_eat,dec_giay_eat,e_33, e_22, e_11);
*
0A05:  MOVF   37,W
0A06:  BSF    03.5
0A07:  MOVWF  22
0A08:  BCF    0A.3
0A09:  BCF    03.5
0A0A:  CALL   626
0A0B:  BSF    0A.3
0A0C:  MOVF   78,W
0A0D:  BSF    03.5
0A0E:  MOVWF  20
0A0F:  BCF    03.5
0A10:  MOVF   38,W
0A11:  BSF    03.5
0A12:  MOVWF  22
0A13:  BCF    0A.3
0A14:  BCF    03.5
0A15:  CALL   626
0A16:  BSF    0A.3
0A17:  MOVF   78,W
0A18:  BSF    03.5
0A19:  MOVWF  21
0A1A:  BCF    03.5
0A1B:  MOVF   39,W
0A1C:  BSF    03.5
0A1D:  MOVWF  22
0A1E:  BCF    0A.3
0A1F:  BCF    03.5
0A20:  CALL   626
0A21:  BSF    0A.3
0A22:  MOVF   78,W
0A23:  BSF    03.5
0A24:  MOVWF  22
0A25:  MOVLW  00
0A26:  BCF    03.5
0A27:  BTFSC  2C.7
0A28:  MOVLW  01
0A29:  BSF    03.5
0A2A:  MOVWF  23
0A2B:  MOVLW  00
0A2C:  BCF    03.5
0A2D:  BTFSC  2C.6
0A2E:  MOVLW  01
0A2F:  BSF    03.5
0A30:  MOVWF  24
0A31:  MOVLW  00
0A32:  BCF    03.5
0A33:  BTFSC  2C.5
0A34:  MOVLW  01
0A35:  BSF    03.5
0A36:  MOVWF  25
0A37:  MOVLW  04
0A38:  MOVWF  26
0A39:  MOVLW  01
0A3A:  MOVWF  27
0A3B:  MOVF   20,W
0A3C:  MOVWF  28
0A3D:  MOVF   21,W
0A3E:  MOVWF  29
0A3F:  MOVF   22,W
0A40:  MOVWF  2A
0A41:  MOVF   23,W
0A42:  MOVWF  2B
0A43:  MOVF   24,W
0A44:  MOVWF  2C
0A45:  MOVF   25,W
0A46:  MOVWF  2D
0A47:  BCF    0A.3
0A48:  BCF    03.5
0A49:  CALL   652
0A4A:  BSF    0A.3
0A4B:  RETURN
.................... }
.................... void phim_chon_mode_alarm(){
....................    if(tick_btn(2, bt3)){
*
1613:  MOVLW  02
1614:  MOVWF  7B
1615:  MOVLW  33
1616:  MOVWF  7C
1617:  BCF    0A.4
1618:  BSF    0A.3
1619:  CALL   06B
161A:  BSF    0A.4
161B:  BCF    0A.3
161C:  MOVF   78,F
161D:  BTFSC  03.2
161E:  GOTO   62F
....................       if(gt_mod < 3) gt_mod++;
161F:  BTFSC  35.7
1620:  GOTO   625
1621:  MOVF   35,W
1622:  SUBLW  02
1623:  BTFSS  03.0
1624:  GOTO   627
1625:  INCF   35,F
1626:  GOTO   629
....................       else{
....................          gt_mod = 0;
1627:  CLRF   35
....................          countLevel = 0;
1628:  CLRF   3A
....................       }
....................       tg_chinh = 0;
1629:  CLRF   36
....................       giai_ma_gpg_alarm_lcd();
162A:  BCF    0A.4
162B:  BSF    0A.3
162C:  CALL   205
162D:  BSF    0A.4
162E:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay_eat(){
....................    if(eat_ss == 0x59) eat_ss = 0x00;
*
1647:  MOVF   39,W
1648:  SUBLW  59
1649:  BTFSS  03.2
164A:  GOTO   64D
164B:  CLRF   39
164C:  GOTO   657
....................    else eat_ss = tang_or_giam_bcd(eat_ss, tang);
164D:  MOVF   39,W
164E:  MOVWF  7B
164F:  CLRF   7C
1650:  BCF    0A.4
1651:  BSF    0A.3
1652:  CALL   187
1653:  BSF    0A.4
1654:  BCF    0A.3
1655:  MOVF   78,W
1656:  MOVWF  39
.................... }
.................... void tang_phut_eat(){
....................    if(eat_pp == 0x59) eat_pp = 0x00;
*
1658:  MOVF   38,W
1659:  SUBLW  59
165A:  BTFSS  03.2
165B:  GOTO   65E
165C:  CLRF   38
165D:  GOTO   668
....................    else eat_pp = tang_or_giam_bcd(eat_pp, tang);
165E:  MOVF   38,W
165F:  MOVWF  7B
1660:  CLRF   7C
1661:  BCF    0A.4
1662:  BSF    0A.3
1663:  CALL   187
1664:  BSF    0A.4
1665:  BCF    0A.3
1666:  MOVF   78,W
1667:  MOVWF  38
.................... }
.................... void tang_gio_eat(){
....................    if(eat_hh == 0x23) eat_hh = 0x00;
*
1669:  MOVF   37,W
166A:  SUBLW  23
166B:  BTFSS  03.2
166C:  GOTO   66F
166D:  CLRF   37
166E:  GOTO   679
....................    else eat_hh = tang_or_giam_bcd(eat_hh, tang);
166F:  MOVF   37,W
1670:  MOVWF  7B
1671:  CLRF   7C
1672:  BCF    0A.4
1673:  BSF    0A.3
1674:  CALL   187
1675:  BSF    0A.4
1676:  BCF    0A.3
1677:  MOVF   78,W
1678:  MOVWF  37
.................... }
.................... void chinh_tang_gpg_eat(){
....................    switch(gt_mod){
*
163C:  MOVF   35,W
163D:  XORLW  01
163E:  BTFSC  03.2
163F:  GOTO   647
1640:  XORLW  03
1641:  BTFSC  03.2
1642:  GOTO   658
1643:  XORLW  01
1644:  BTFSC  03.2
1645:  GOTO   669
1646:  GOTO   67A
....................       case 1:
....................          tang_giay_eat();
....................          break;
*
1657:  GOTO   67B
....................       case 2:
....................          tang_phut_eat();
....................          break;
*
1668:  GOTO   67B
....................       case 3:
....................          tang_gio_eat();
....................          break;
*
1679:  GOTO   67B
....................       default: break;
167A:  GOTO   67B
....................    }
.................... }
.................... 
.................... void phim_up_eat(){
....................    if(tick_btn(1, bt1)){
*
162F:  MOVLW  01
1630:  MOVWF  7B
1631:  MOVLW  31
1632:  MOVWF  7C
1633:  BCF    0A.4
1634:  BSF    0A.3
1635:  CALL   06B
1636:  BSF    0A.4
1637:  BCF    0A.3
1638:  MOVF   78,F
1639:  BTFSC  03.2
163A:  GOTO   683
....................       tg_chinh = 0;
163B:  CLRF   36
....................       chinh_tang_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
167B:  BSF    2C.5
167C:  BSF    2C.6
167D:  BSF    2C.7
....................       giai_ma_gpg_alarm_lcd();
167E:  BCF    0A.4
167F:  BSF    0A.3
1680:  CALL   205
1681:  BSF    0A.4
1682:  BCF    0A.3
....................    }
.................... }
.................... 
.................... void giam_giay_eat(){
....................    if(eat_ss == 0) eat_ss = 0x59;
*
169B:  MOVF   39,F
169C:  BTFSS  03.2
169D:  GOTO   6A1
169E:  MOVLW  59
169F:  MOVWF  39
16A0:  GOTO   6AC
....................    else eat_ss = tang_or_giam_bcd(eat_ss,giam);
16A1:  MOVF   39,W
16A2:  MOVWF  7B
16A3:  MOVLW  01
16A4:  MOVWF  7C
16A5:  BCF    0A.4
16A6:  BSF    0A.3
16A7:  CALL   187
16A8:  BSF    0A.4
16A9:  BCF    0A.3
16AA:  MOVF   78,W
16AB:  MOVWF  39
.................... }
.................... void giam_phut_eat(){
....................    if(eat_pp == 0) eat_pp = 0x59;
*
16AD:  MOVF   38,F
16AE:  BTFSS  03.2
16AF:  GOTO   6B3
16B0:  MOVLW  59
16B1:  MOVWF  38
16B2:  GOTO   6BE
....................    else eat_pp = tang_or_giam_bcd(eat_pp,giam);
16B3:  MOVF   38,W
16B4:  MOVWF  7B
16B5:  MOVLW  01
16B6:  MOVWF  7C
16B7:  BCF    0A.4
16B8:  BSF    0A.3
16B9:  CALL   187
16BA:  BSF    0A.4
16BB:  BCF    0A.3
16BC:  MOVF   78,W
16BD:  MOVWF  38
.................... }
.................... void giam_gio_eat(){
....................    if(eat_hh == 0) eat_hh = 0x23;
*
16BF:  MOVF   37,F
16C0:  BTFSS  03.2
16C1:  GOTO   6C5
16C2:  MOVLW  23
16C3:  MOVWF  37
16C4:  GOTO   6D0
....................    else eat_hh = tang_or_giam_bcd(eat_hh,giam);
16C5:  MOVF   37,W
16C6:  MOVWF  7B
16C7:  MOVLW  01
16C8:  MOVWF  7C
16C9:  BCF    0A.4
16CA:  BSF    0A.3
16CB:  CALL   187
16CC:  BSF    0A.4
16CD:  BCF    0A.3
16CE:  MOVF   78,W
16CF:  MOVWF  37
.................... }
.................... void chinh_giam_gpg_eat(){
....................    switch(gt_mod){
*
1690:  MOVF   35,W
1691:  XORLW  01
1692:  BTFSC  03.2
1693:  GOTO   69B
1694:  XORLW  03
1695:  BTFSC  03.2
1696:  GOTO   6AD
1697:  XORLW  01
1698:  BTFSC  03.2
1699:  GOTO   6BF
169A:  GOTO   6D1
....................       case 1:
....................          giam_giay_eat();
....................          break;
*
16AC:  GOTO   6D2
....................       case 2:
....................          giam_phut_eat();
....................          break;
*
16BE:  GOTO   6D2
....................       case 3:
....................          giam_gio_eat();
....................          break;
*
16D0:  GOTO   6D2
....................       default: break;
16D1:  GOTO   6D2
....................    }
.................... }
.................... void phim_dw_eat(){
....................    if(tick_btn(1, bt2)){
*
1683:  MOVLW  01
1684:  MOVWF  7B
1685:  MOVLW  32
1686:  MOVWF  7C
1687:  BCF    0A.4
1688:  BSF    0A.3
1689:  CALL   06B
168A:  BSF    0A.4
168B:  BCF    0A.3
168C:  MOVF   78,F
168D:  BTFSC  03.2
168E:  GOTO   6DA
....................       tg_chinh = 0;
168F:  CLRF   36
....................       chinh_giam_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
16D2:  BSF    2C.5
16D3:  BSF    2C.6
16D4:  BSF    2C.7
....................       giai_ma_gpg_alarm_lcd();
16D5:  BCF    0A.4
16D6:  BSF    0A.3
16D7:  CALL   205
16D8:  BSF    0A.4
16D9:  BCF    0A.3
....................    }
.................... }
.................... void log_mode_alarm(){
....................    lcd_setCursor(13, 1);
*
16F1:  MOVLW  0D
16F2:  BSF    03.5
16F3:  MOVWF  34
16F4:  MOVLW  01
16F5:  MOVWF  35
16F6:  BCF    0A.4
16F7:  BCF    03.5
16F8:  CALL   330
16F9:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
16FA:  MOVLW  30
16FB:  ADDWF  35,W
16FC:  MOVWF  7B
16FD:  BSF    03.5
16FE:  MOVWF  37
16FF:  BCF    0A.4
1700:  BCF    03.5
1701:  CALL   34F
1702:  BSF    0A.4
....................    if(gt_mod != 0){
1703:  MOVF   35,F
1704:  BTFSC  03.2
1705:  GOTO   72B
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
1706:  MOVF   36,W
1707:  MOVWF  7B
1708:  MOVLW  0A
1709:  MOVWF  7C
170A:  BCF    0A.4
170B:  BSF    0A.3
170C:  CALL   1E0
170D:  BSF    0A.4
170E:  BCF    0A.3
170F:  MOVLW  30
1710:  ADDWF  78,W
1711:  MOVWF  7B
1712:  BSF    03.5
1713:  MOVWF  37
1714:  BCF    0A.4
1715:  BCF    03.5
1716:  CALL   34F
1717:  BSF    0A.4
1718:  MOVF   36,W
1719:  MOVWF  7B
171A:  MOVLW  0A
171B:  MOVWF  7C
171C:  BCF    0A.4
171D:  BSF    0A.3
171E:  CALL   1E0
171F:  BSF    0A.4
1720:  BCF    0A.3
1721:  MOVLW  30
1722:  ADDWF  77,W
1723:  MOVWF  7B
1724:  BSF    03.5
1725:  MOVWF  37
1726:  BCF    0A.4
1727:  BCF    03.5
1728:  CALL   34F
1729:  BSF    0A.4
....................    }
172A:  GOTO   734
....................    else
....................       lcd_data("__");
172B:  MOVLW  05
172C:  BSF    03.6
172D:  MOVWF  0D
172E:  MOVLW  01
172F:  MOVWF  0F
1730:  BCF    0A.4
1731:  BCF    03.6
1732:  CALL   36C
1733:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_control_chiller.c>
.................... void control_temperature(int8 nd_ss, int8 gh){
....................    if(nd_ss > gh){
*
111E:  MOVF   7B,W
111F:  SUBWF  7C,W
1120:  BTFSC  03.0
1121:  GOTO   125
....................    // water is hot
....................       output_bit(pinDLCold, 1);
1122:  BSF    08.6
....................       output_bit(pinDLHot,  0);
1123:  BCF    08.7
....................    }
1124:  GOTO   127
....................    else{
....................    // water is cold
....................       output_bit(pinDLCold, 0);
1125:  BCF    08.6
....................       output_bit(pinDLHot,  1);
1126:  BSF    08.7
....................    }
.................... }
.................... 
.................... void servo_degree_0(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
0315:  CLRF   7B
0316:  MOVF   7B,W
0317:  SUBLW  31
0318:  BTFSS  03.0
0319:  GOTO   32F
....................       output_bit(pinServo, 1);
031A:  BSF    07.1
....................       Delay_us(800); // pulse of 800us
031B:  MOVLW  04
031C:  MOVWF  7C
031D:  MOVLW  C7
031E:  BSF    03.5
031F:  MOVWF  21
0320:  BCF    03.5
0321:  CALL   304
0322:  DECFSZ 7C,F
0323:  GOTO   31D
....................       output_bit(pinServo, 0);
0324:  BCF    07.1
....................       Delay_us(19200);
0325:  MOVLW  13
0326:  MOVWF  7C
0327:  CALL   1F9
0328:  MOVLW  C8
0329:  BSF    03.5
032A:  MOVWF  21
032B:  BCF    03.5
032C:  CALL   304
032D:  INCF   7B,F
032E:  GOTO   316
....................    }
032F:  RETURN
.................... }
.................... 
.................... void servo_degree_90(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
1166:  CLRF   7B
1167:  MOVF   7B,W
1168:  SUBLW  31
1169:  BTFSS  03.0
116A:  GOTO   18F
....................       output_bit(pinServo, 1);
116B:  BSF    07.1
....................       Delay_us(1500); // pulse of 1500us
116C:  MOVLW  01
116D:  MOVWF  7C
116E:  BCF    0A.4
116F:  CALL   1F9
1170:  BSF    0A.4
1171:  MOVLW  02
1172:  MOVWF  7C
1173:  MOVLW  F9
1174:  BSF    03.5
1175:  MOVWF  21
1176:  BCF    0A.4
1177:  BCF    03.5
1178:  CALL   304
1179:  BSF    0A.4
117A:  DECFSZ 7C,F
117B:  GOTO   173
....................       output_bit(pinServo, 0);
117C:  BCF    07.1
....................       Delay_us(18500);
117D:  MOVLW  12
117E:  MOVWF  7C
117F:  BCF    0A.4
1180:  CALL   1F9
1181:  BSF    0A.4
1182:  MOVLW  02
1183:  MOVWF  7C
1184:  MOVLW  F9
1185:  BSF    03.5
1186:  MOVWF  21
1187:  BCF    0A.4
1188:  BCF    03.5
1189:  CALL   304
118A:  BSF    0A.4
118B:  DECFSZ 7C,F
118C:  GOTO   184
118D:  INCF   7B,F
118E:  GOTO   167
....................    }
.................... }
.................... 
.................... void servo_degree_180(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
....................       output_bit(pinServo, 1);
....................       Delay_us(2200); // pulse of 2200us
....................       output_bit(pinServo, 0);
....................       Delay_us(17800);
....................    }
.................... }
.................... 
.................... void control_servo(){
....................    if(dec_gio_ds == dec_gio_eat && dec_phut_ds == dec_phut_eat && dec_giay_ds == dec_giay_eat){
*
1127:  MOVF   70,W
1128:  BSF    03.5
1129:  MOVWF  22
112A:  BCF    0A.4
112B:  BCF    03.5
112C:  CALL   626
112D:  BSF    0A.4
112E:  MOVF   78,W
112F:  MOVWF  7B
1130:  MOVF   37,W
1131:  BSF    03.5
1132:  MOVWF  22
1133:  BCF    0A.4
1134:  BCF    03.5
1135:  CALL   626
1136:  BSF    0A.4
1137:  MOVF   78,W
1138:  SUBWF  7B,W
1139:  BTFSS  03.2
113A:  GOTO   164
113B:  MOVF   6F,W
113C:  BSF    03.5
113D:  MOVWF  22
113E:  BCF    0A.4
113F:  BCF    03.5
1140:  CALL   626
1141:  BSF    0A.4
1142:  MOVF   78,W
1143:  MOVWF  7B
1144:  MOVF   38,W
1145:  BSF    03.5
1146:  MOVWF  22
1147:  BCF    0A.4
1148:  BCF    03.5
1149:  CALL   626
114A:  BSF    0A.4
114B:  MOVF   78,W
114C:  SUBWF  7B,W
114D:  BTFSS  03.2
114E:  GOTO   164
114F:  MOVF   6E,W
1150:  BSF    03.5
1151:  MOVWF  22
1152:  BCF    0A.4
1153:  BCF    03.5
1154:  CALL   626
1155:  BSF    0A.4
1156:  MOVF   78,W
1157:  MOVWF  7B
1158:  MOVF   39,W
1159:  BSF    03.5
115A:  MOVWF  22
115B:  BCF    0A.4
115C:  BCF    03.5
115D:  CALL   626
115E:  BSF    0A.4
115F:  MOVF   78,W
1160:  SUBWF  7B,W
1161:  BTFSS  03.2
1162:  GOTO   164
....................       flag_servo = true;
1163:  BSF    3C.0
....................    }
....................    if(flag_servo){
1164:  BTFSS  3C.0
1165:  GOTO   190
....................       servo_degree_90();
....................    }
*
118F:  GOTO   193
....................    else{
....................       servo_degree_0();
1190:  BCF    0A.4
1191:  CALL   315
1192:  BSF    0A.4
....................    }
.................... }
.................... 
.................... 
.................... #include <library_menu.c>
.................... 
.................... void menu(){
....................    if (push_btn(false,bt0)) countLevel++;
*
1077:  CLRF   7B
1078:  MOVLW  30
1079:  MOVWF  7C
*
10B1:  MOVF   78,F
10B2:  BTFSC  03.2
10B3:  GOTO   0B5
10B4:  INCF   3A,F
.................... 
....................    if (countLevel >= maxLevel) countLevel = 0;
10B5:  MOVF   3A,W
10B6:  SUBLW  05
10B7:  BTFSC  03.0
10B8:  GOTO   0BA
10B9:  CLRF   3A
....................    
....................    if(countLevel != countLevelRev){
10BA:  MOVF   3B,W
10BB:  SUBWF  3A,W
10BC:  BTFSC  03.2
10BD:  GOTO   0C3
....................       countLevelRev = countLevel;
10BE:  MOVF   3A,W
10BF:  MOVWF  3B
....................       lcd_clear();
10C0:  BCF    0A.4
10C1:  CALL   286
10C2:  BSF    0A.4
....................    }
....................    
....................    switch(countLevel){
10C3:  MOVF   3A,W
10C4:  BTFSC  03.2
10C5:  GOTO   0D3
10C6:  XORLW  01
10C7:  BTFSC  03.2
10C8:  GOTO   2BA
10C9:  XORLW  03
10CA:  BTFSC  03.2
10CB:  GOTO   327
10CC:  XORLW  01
10CD:  BTFSC  03.2
10CE:  GOTO   5F6
10CF:  XORLW  07
10D0:  BTFSC  03.2
10D1:  GOTO   735
10D2:  GOTO   765
....................       case 0:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
10D3:  MOVLW  08
10D4:  MOVWF  7B
10D5:  BCF    0A.4
10D6:  CALL   18F
10D7:  BSF    0A.4
.................... 
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
10D8:  BCF    0A.4
10D9:  CALL   54D
10DA:  BSF    0A.4
.................... 
.................... //! display info rtc and temperature for user
....................          lcd_dis_xx_yy_zz(4,0,dec_gio_ds,dec_phut_ds,dec_giay_ds,1,1,1);
10DB:  MOVF   70,W
10DC:  BSF    03.5
10DD:  MOVWF  22
10DE:  BCF    0A.4
10DF:  BCF    03.5
10E0:  CALL   626
10E1:  BSF    0A.4
10E2:  MOVF   78,W
10E3:  MOVWF  7B
10E4:  MOVF   6F,W
10E5:  BSF    03.5
10E6:  MOVWF  22
10E7:  BCF    0A.4
10E8:  BCF    03.5
10E9:  CALL   626
10EA:  BSF    0A.4
10EB:  MOVF   78,W
10EC:  MOVWF  7C
10ED:  MOVF   6E,W
10EE:  BSF    03.5
10EF:  MOVWF  22
10F0:  BCF    0A.4
10F1:  BCF    03.5
10F2:  CALL   626
10F3:  BSF    0A.4
10F4:  MOVF   78,W
10F5:  MOVWF  7D
10F6:  MOVLW  04
10F7:  BSF    03.5
10F8:  MOVWF  26
10F9:  CLRF   27
10FA:  MOVF   7B,W
10FB:  MOVWF  28
10FC:  MOVF   7C,W
10FD:  MOVWF  29
10FE:  MOVF   78,W
10FF:  MOVWF  2A
1100:  MOVLW  01
1101:  MOVWF  2B
1102:  MOVWF  2C
1103:  MOVWF  2D
1104:  BCF    0A.4
1105:  BCF    03.5
1106:  CALL   652
1107:  BSF    0A.4
....................          lcd_dis_temperature(2,1,dt_ng,dt_tp);
1108:  MOVLW  02
1109:  MOVWF  7B
110A:  MOVLW  01
110B:  MOVWF  7C
110C:  CLRF   7E
110D:  MOVF   40,W
110E:  MOVWF  7D
110F:  MOVF   42,W
1110:  BSF    03.5
1111:  MOVWF  21
1112:  BCF    03.5
1113:  MOVF   41,W
1114:  BSF    03.5
1115:  MOVWF  20
1116:  BCF    0A.4
1117:  BCF    03.5
1118:  CALL   72D
1119:  BSF    0A.4
.................... 
.................... //! control delay and servo
....................          control_temperature(dt_ng,limitTemperature);
111A:  MOVF   40,W
111B:  MOVWF  7B
111C:  MOVF   2D,W
111D:  MOVWF  7C
....................          control_servo();
....................          
....................          handle_uart();
....................          
....................          if(flag_10s == true){
*
1223:  BTFSS  2C.1
1224:  GOTO   242
....................             flag_10s = false;
1225:  BCF    2C.1
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:rt:", dt_ng);
1226:  MOVLW  07
1227:  BSF    03.6
1228:  MOVWF  0D
1229:  MOVLW  01
122A:  MOVWF  0F
122B:  BCF    0A.4
122C:  BCF    03.6
122D:  CALL   406
122E:  BSF    0A.4
122F:  MOVF   40,W
1230:  MOVWF  7E
1231:  MOVLW  18
1232:  BSF    03.5
1233:  MOVWF  20
1234:  BCF    0A.4
1235:  BSF    0A.3
1236:  BCF    03.5
1237:  CALL   000
1238:  BSF    0A.4
1239:  BCF    0A.3
123A:  MOVLW  0D
123B:  BTFSS  0C.4
123C:  GOTO   23B
123D:  MOVWF  19
123E:  MOVLW  0A
123F:  BTFSS  0C.4
1240:  GOTO   23F
1241:  MOVWF  19
....................          }
....................          if(flag_13s == true){
1242:  BTFSS  2C.2
1243:  GOTO   261
....................             flag_13s = false;
1244:  BCF    2C.2
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:lt:", limitTemperature);
1245:  MOVLW  0B
1246:  BSF    03.6
1247:  MOVWF  0D
1248:  MOVLW  01
1249:  MOVWF  0F
124A:  BCF    0A.4
124B:  BCF    03.6
124C:  CALL   406
124D:  BSF    0A.4
124E:  MOVF   2D,W
124F:  MOVWF  7E
1250:  MOVLW  18
1251:  BSF    03.5
1252:  MOVWF  20
1253:  BCF    0A.4
1254:  BSF    0A.3
1255:  BCF    03.5
1256:  CALL   000
1257:  BSF    0A.4
1258:  BCF    0A.3
1259:  MOVLW  0D
125A:  BTFSS  0C.4
125B:  GOTO   25A
125C:  MOVWF  19
125D:  MOVLW  0A
125E:  BTFSS  0C.4
125F:  GOTO   25E
1260:  MOVWF  19
....................          }
....................          if(flag_16s == true){
1261:  BTFSS  2C.3
1262:  GOTO   2B9
....................             flag_16s = false;
1263:  BCF    2C.3
....................             fprintf(UART_STREAM, "%s%d-%d-%d\r\n", "dt:ra:", dec_gio_eat, dec_phut_eat, dec_giay_eat);
1264:  MOVF   37,W
1265:  BSF    03.5
1266:  MOVWF  22
1267:  BCF    0A.4
1268:  BCF    03.5
1269:  CALL   626
126A:  BSF    0A.4
126B:  MOVF   78,W
126C:  MOVWF  7B
126D:  MOVF   38,W
126E:  BSF    03.5
126F:  MOVWF  22
1270:  BCF    0A.4
1271:  BCF    03.5
1272:  CALL   626
1273:  BSF    0A.4
1274:  MOVF   78,W
1275:  MOVWF  7C
1276:  MOVF   39,W
1277:  BSF    03.5
1278:  MOVWF  22
1279:  BCF    0A.4
127A:  BCF    03.5
127B:  CALL   626
127C:  BSF    0A.4
127D:  MOVF   78,W
127E:  MOVWF  7D
127F:  MOVLW  0F
1280:  BSF    03.6
1281:  MOVWF  0D
1282:  MOVLW  01
1283:  MOVWF  0F
1284:  BCF    0A.4
1285:  BCF    03.6
1286:  CALL   406
1287:  BSF    0A.4
1288:  MOVF   7B,W
1289:  MOVWF  7E
128A:  MOVLW  18
128B:  BSF    03.5
128C:  MOVWF  20
128D:  BCF    0A.4
128E:  BSF    0A.3
128F:  BCF    03.5
1290:  CALL   000
1291:  BSF    0A.4
1292:  BCF    0A.3
1293:  MOVLW  2D
1294:  BTFSS  0C.4
1295:  GOTO   294
1296:  MOVWF  19
1297:  MOVF   7C,W
1298:  MOVWF  7E
1299:  MOVLW  18
129A:  BSF    03.5
129B:  MOVWF  20
129C:  BCF    0A.4
129D:  BSF    0A.3
129E:  BCF    03.5
129F:  CALL   000
12A0:  BSF    0A.4
12A1:  BCF    0A.3
12A2:  MOVLW  2D
12A3:  BTFSS  0C.4
12A4:  GOTO   2A3
12A5:  MOVWF  19
12A6:  MOVF   7D,W
12A7:  MOVWF  7E
12A8:  MOVLW  18
12A9:  BSF    03.5
12AA:  MOVWF  20
12AB:  BCF    0A.4
12AC:  BSF    0A.3
12AD:  BCF    03.5
12AE:  CALL   000
12AF:  BSF    0A.4
12B0:  BCF    0A.3
12B1:  MOVLW  0D
12B2:  BTFSS  0C.4
12B3:  GOTO   2B2
12B4:  MOVWF  19
12B5:  MOVLW  0A
12B6:  BTFSS  0C.4
12B7:  GOTO   2B6
12B8:  MOVWF  19
....................          }
....................          break;
12B9:  GOTO   795
....................       case 1:
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
12BA:  BCF    0A.4
12BB:  CALL   54D
12BC:  BSF    0A.4
.................... 
.................... //! change limit temperature
....................          limitTemperature += tick_btn(1,bt2);
12BD:  MOVLW  01
12BE:  MOVWF  7B
12BF:  MOVLW  32
12C0:  MOVWF  7C
12C1:  BCF    0A.4
12C2:  BSF    0A.3
12C3:  CALL   06B
12C4:  BSF    0A.4
12C5:  BCF    0A.3
12C6:  MOVF   78,W
12C7:  ADDWF  2D,F
....................          limitTemperature -= tick_btn(1,bt1);
12C8:  MOVLW  01
12C9:  MOVWF  7B
12CA:  MOVLW  31
12CB:  MOVWF  7C
12CC:  BCF    0A.4
12CD:  BSF    0A.3
12CE:  CALL   06B
12CF:  BSF    0A.4
12D0:  BCF    0A.3
12D1:  MOVF   78,W
12D2:  SUBWF  2D,F
.................... 
.................... //! display info temperature limit and sensor
....................          lcd_dis_temperature(2,0,dt_ng,dt_tp);
12D3:  MOVLW  02
12D4:  MOVWF  7B
12D5:  CLRF   7C
12D6:  CLRF   7E
12D7:  MOVF   40,W
12D8:  MOVWF  7D
12D9:  MOVF   42,W
12DA:  BSF    03.5
12DB:  MOVWF  21
12DC:  BCF    03.5
12DD:  MOVF   41,W
12DE:  BSF    03.5
12DF:  MOVWF  20
12E0:  BCF    0A.4
12E1:  BCF    03.5
12E2:  CALL   72D
12E3:  BSF    0A.4
....................          lcd_dis_temperature_limit(2,1,limitTemperature);
12E4:  MOVLW  02
12E5:  MOVWF  7B
12E6:  MOVLW  01
12E7:  MOVWF  7C
12E8:  CLRF   7E
12E9:  MOVF   2D,W
12EA:  MOVWF  7D
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
*
1319:  MOVLW  01
131A:  MOVWF  7B
131B:  MOVLW  33
131C:  MOVWF  7C
131D:  BCF    0A.4
131E:  BSF    0A.3
131F:  CALL   06B
1320:  BSF    0A.4
1321:  BCF    0A.3
1322:  MOVF   78,F
1323:  BTFSC  03.2
1324:  GOTO   326
1325:  CLRF   3A
....................          
....................          break;
1326:  GOTO   795
....................       case 2:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
1327:  MOVLW  08
1328:  MOVWF  7B
1329:  BCF    0A.4
132A:  CALL   18F
132B:  BSF    0A.4
.................... 
.................... //!
....................          lcd_setCursor(1,0);
132C:  MOVLW  01
132D:  BSF    03.5
132E:  MOVWF  34
132F:  CLRF   35
1330:  BCF    0A.4
1331:  BCF    03.5
1332:  CALL   330
1333:  BSF    0A.4
....................          lcd_data("cai dat dong ho");
1334:  MOVLW  13
1335:  BSF    03.6
1336:  MOVWF  0D
1337:  MOVLW  01
1338:  MOVWF  0F
1339:  BCF    0A.4
133A:  BCF    03.6
133B:  CALL   36C
133C:  BSF    0A.4
....................          if(bdn < 5){
133D:  MOVF   33,W
133E:  SUBLW  04
133F:  BTFSS  03.0
1340:  GOTO   559
....................             if(gt_mod != 0) xu_ly_choptat();
1341:  MOVF   35,F
1342:  BTFSC  03.2
1343:  GOTO   349
1344:  BCF    0A.4
1345:  BSF    0A.3
1346:  CALL   086
1347:  BSF    0A.4
1348:  BCF    0A.3
....................             phim_chon_hthi_mode();
....................             phim_up();
....................             phim_dw();
....................          }
*
1558:  GOTO   571
....................          else if(bdn >= 10){
1559:  MOVF   33,W
155A:  SUBLW  09
155B:  BTFSC  03.0
155C:  GOTO   571
....................             bdn = 0;
155D:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
155E:  BTFSC  36.7
155F:  GOTO   564
1560:  MOVF   36,W
1561:  SUBLW  13
1562:  BTFSS  03.0
1563:  GOTO   566
1564:  INCF   36,F
1565:  GOTO   56B
....................             else{
....................                gt_mod = 0; tt_ht = 0;
1566:  CLRF   35
1567:  CLRF   34
....................                e_11 = true; e_22 = true; e_33 = true;
1568:  BSF    2C.5
1569:  BSF    2C.6
156A:  BSF    2C.7
....................             }
....................             if(giay_tam!=giay_ds){
156B:  MOVF   6E,W
156C:  SUBWF  32,W
156D:  BTFSC  03.2
156E:  GOTO   571
....................                giay_tam = giay_ds;
156F:  MOVF   6E,W
1570:  MOVWF  32
....................             }
....................          }
....................          giai_ma_gpg_ntn_thu_lcd();
1571:  BCF    0A.4
1572:  BSF    0A.3
1573:  CALL   160
1574:  BSF    0A.4
1575:  BCF    0A.3
....................          log_mode();
....................          break;
*
15F5:  GOTO   795
....................       case 3:
....................          lcd_setCursor(1,0);
15F6:  MOVLW  01
15F7:  BSF    03.5
15F8:  MOVWF  34
15F9:  CLRF   35
15FA:  BCF    0A.4
15FB:  BCF    03.5
15FC:  CALL   330
15FD:  BSF    0A.4
....................          lcd_data("t/g cho ca an");
15FE:  MOVLW  1B
15FF:  BSF    03.6
1600:  MOVWF  0D
1601:  MOVLW  01
1602:  MOVWF  0F
1603:  BCF    0A.4
1604:  BCF    03.6
1605:  CALL   36C
1606:  BSF    0A.4
....................          if(bdn < 5){
1607:  MOVF   33,W
1608:  SUBLW  04
1609:  BTFSS  03.0
160A:  GOTO   6DB
....................             if(gt_mod != 0) xu_ly_choptat();
160B:  MOVF   35,F
160C:  BTFSC  03.2
160D:  GOTO   613
160E:  BCF    0A.4
160F:  BSF    0A.3
1610:  CALL   086
1611:  BSF    0A.4
1612:  BCF    0A.3
....................             phim_chon_mode_alarm();
....................             phim_up_eat();
....................             phim_dw_eat();
....................          }
*
16DA:  GOTO   6EC
....................          else if(bdn >= 10){
16DB:  MOVF   33,W
16DC:  SUBLW  09
16DD:  BTFSC  03.0
16DE:  GOTO   6EC
....................             bdn = 0;
16DF:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
16E0:  BTFSC  36.7
16E1:  GOTO   6E6
16E2:  MOVF   36,W
16E3:  SUBLW  13
16E4:  BTFSS  03.0
16E5:  GOTO   6E8
16E6:  INCF   36,F
16E7:  GOTO   6EC
....................             else{
....................                gt_mod = 0;
16E8:  CLRF   35
....................                e_11 = true; e_22 = true; e_33 = true;
16E9:  BSF    2C.5
16EA:  BSF    2C.6
16EB:  BSF    2C.7
....................             }
....................          }
....................          giai_ma_gpg_alarm_lcd();
16EC:  BCF    0A.4
16ED:  BSF    0A.3
16EE:  CALL   205
16EF:  BSF    0A.4
16F0:  BCF    0A.3
....................          log_mode_alarm();
....................          break;
*
1734:  GOTO   795
....................       case 4:
....................          lcd_setCursor(1,0);
1735:  MOVLW  01
1736:  BSF    03.5
1737:  MOVWF  34
1738:  CLRF   35
1739:  BCF    0A.4
173A:  BCF    03.5
173B:  CALL   330
173C:  BSF    0A.4
....................          lcd_data("check com esp");
173D:  MOVLW  22
173E:  BSF    03.6
173F:  MOVWF  0D
1740:  MOVLW  01
1741:  MOVWF  0F
1742:  BCF    0A.4
1743:  BCF    03.6
1744:  CALL   36C
1745:  BSF    0A.4
....................          lcd_setCursor(1,1);
1746:  MOVLW  01
1747:  BSF    03.5
1748:  MOVWF  34
1749:  MOVWF  35
174A:  BCF    0A.4
174B:  BCF    03.5
174C:  CALL   330
174D:  BSF    0A.4
....................          lcd_data(indexComplete + 0x30);
174E:  MOVLW  30
174F:  ADDWF  59,W
1750:  MOVWF  7B
1751:  BSF    03.5
1752:  MOVWF  37
1753:  BCF    0A.4
1754:  BCF    03.5
1755:  CALL   34F
1756:  BSF    0A.4
....................          if(tick_btn(1,bt3)) countLevel = 0;
1757:  MOVLW  01
1758:  MOVWF  7B
1759:  MOVLW  33
175A:  MOVWF  7C
175B:  BCF    0A.4
175C:  BSF    0A.3
175D:  CALL   06B
175E:  BSF    0A.4
175F:  BCF    0A.3
1760:  MOVF   78,F
1761:  BTFSC  03.2
1762:  GOTO   764
1763:  CLRF   3A
....................          break;
1764:  GOTO   795
....................       default:
....................          lcd_setCursor(2,0);
1765:  MOVLW  02
1766:  BSF    03.5
1767:  MOVWF  34
1768:  CLRF   35
1769:  BCF    0A.4
176A:  BCF    03.5
176B:  CALL   330
176C:  BSF    0A.4
....................          lcd_data("Information");
176D:  MOVLW  29
176E:  BSF    03.6
176F:  MOVWF  0D
1770:  MOVLW  01
1771:  MOVWF  0F
1772:  BCF    0A.4
1773:  BCF    03.6
1774:  CALL   36C
1775:  BSF    0A.4
....................          lcd_setCursor(0,1);
1776:  BSF    03.5
1777:  CLRF   34
1778:  MOVLW  01
1779:  MOVWF  35
177A:  BCF    0A.4
177B:  BCF    03.5
177C:  CALL   330
177D:  BSF    0A.4
....................          lcd_data("Version: V1.0.0");
177E:  MOVLW  2F
177F:  BSF    03.6
1780:  MOVWF  0D
1781:  MOVLW  01
1782:  MOVWF  0F
1783:  BCF    0A.4
1784:  BCF    03.6
1785:  CALL   36C
1786:  BSF    0A.4
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
1787:  MOVLW  01
1788:  MOVWF  7B
1789:  MOVLW  33
178A:  MOVWF  7C
178B:  BCF    0A.4
178C:  BSF    0A.3
178D:  CALL   06B
178E:  BSF    0A.4
178F:  BCF    0A.3
1790:  MOVF   78,F
1791:  BTFSC  03.2
1792:  GOTO   794
1793:  CLRF   3A
....................          break;
1794:  GOTO   795
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void loop(){
.................... //! function to access for change limit temperature, change time for time rtc, change time clock for eat fish, check com with esp, log version sys
....................    menu();
.................... }
.................... 
.................... void main(){
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2B
1005:  BSF    2B.3
1006:  MOVF   2B,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2B.4
100B:  MOVF   2B,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  31
100F:  MOVWF  13
1010:  MOVLW  28
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    14.7
1015:  BCF    14.6
1016:  MOVLW  81
1017:  MOVWF  19
1018:  MOVLW  A6
1019:  MOVWF  18
101A:  MOVLW  90
101B:  BCF    03.5
101C:  MOVWF  18
101D:  BCF    2C.0
101E:  BCF    2C.1
101F:  BCF    2C.2
1020:  BCF    2C.3
1021:  BCF    2C.4
1022:  MOVLW  19
1023:  MOVWF  2D
1024:  CLRF   34
1025:  CLRF   35
1026:  CLRF   36
1027:  CLRF   3A
1028:  CLRF   3B
1029:  CLRF   3D
102A:  CLRF   57
102B:  CLRF   58
102C:  CLRF   59
102D:  CLRF   5B
102E:  CLRF   5A
102F:  CLRF   5C
1030:  CLRF   5D
1031:  BSF    03.5
1032:  BSF    1F.0
1033:  BSF    1F.1
1034:  BSF    1F.2
1035:  BCF    1F.3
1036:  MOVLW  07
1037:  MOVWF  1C
1038:  BCF    03.7
.................... 
.................... //! setup enviroments
....................    setup_initialize();
*
105F:  BCF    0A.4
1060:  GOTO   144
1061:  BSF    0A.4
....................    
.................... //! setup ds1307 rtc
....................    ds1307_setup();
1062:  BCF    0A.4
1063:  GOTO   1BD
1064:  BSF    0A.4
.................... 
.................... //! setup lcd display
....................    lcd_setup();
1065:  BCF    0A.4
1066:  GOTO   28F
1067:  BSF    0A.4
.................... 
.................... //! setup servo initialize is 0 degree
....................    servo_degree_0();
1068:  BCF    0A.4
1069:  CALL   315
106A:  BSF    0A.4
.................... 
.................... //! display info include: name project and name university
....................    log_lcd_initialize();
106B:  BCF    0A.4
106C:  GOTO   3E0
106D:  BSF    0A.4
....................    
....................    printf("Hello from PIC16F877A!\r\n");
106E:  MOVLW  37
106F:  BSF    03.6
1070:  MOVWF  0D
1071:  MOVLW  01
1072:  MOVWF  0F
1073:  BCF    0A.4
1074:  BCF    03.6
1075:  CALL   406
1076:  BSF    0A.4
....................    
....................    while(true){
.................... //! loop function is function suport in process of system
....................       loop();
*
1795:  GOTO   077
....................    }
.................... }
1796:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
