CCS PCM C Compiler, Version 5.115, 43599               09-Jun-24 16:11

               Filename:   E:\STUDY\HKII-2023-2024\DO_AN_1\PROJECT\CODE_FINNAL\main.lst

               ROM used:   4307 words (53%)
                           Largest free fragment is 2048
               RAM used:   89 (24%) at main() level
                           140 (38%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   05A
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   08F
.................... #include <library_project.c>
.................... /*
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
....................                        SU PHAM KY THUAT - TP.HCM
....................  DO AN 1 - HIEU CHINH NHIET DO HO CA VA CHO CA AN TU DONG - KET NOI ESP
.................... 
....................    THANH VIEN:
....................       VO MINH THUAN   - 21161366
....................       LE QUANG THUONG - 21161367
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... */
.................... #include <define_pic16f.c>
.................... //! config mode to operation of pic16f877a
.................... #include <16f877a.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
008C:  DATA F3,39
008D:  DATA BA,37
008E:  DATA 6B,00
*
00B2:  DATA C4,37
00B3:  DATA A0,30
00B4:  DATA 6E,10
00B5:  DATA 31,10
00B6:  DATA 2D,10
00B7:  DATA C8,25
00B8:  DATA C9,24
00B9:  DATA 00,00
00BA:  DATA 53,28
00BB:  DATA 4B,2A
00BC:  DATA 2D,2A
00BD:  DATA 50,24
00BE:  DATA C3,26
00BF:  DATA 00,00
00C0:  DATA 2D,00
00C1:  DATA 2D,00
00C2:  DATA 2E,00
00C3:  DATA 2E,00
00C4:  DATA 4E,22
00C5:  DATA 3A,10
00C6:  DATA 00,01
00C7:  DATA A0,37
00C8:  DATA 43,00
00C9:  DATA 4E,22
00CA:  DATA AD,23
00CB:  DATA 48,1D
00CC:  DATA 20,00
00CD:  DATA A0,37
00CE:  DATA 43,00
00CF:  DATA 20,27
00D0:  DATA 20,00
00D1:  DATA 47,28
00D2:  DATA 47,00
00D3:  DATA 4E,2A
00D4:  DATA 4E,00
00D5:  DATA 20,2A
00D6:  DATA 20,00
00D7:  DATA DF,2F
00D8:  DATA 00,00
00D9:  DATA DF,2F
00DA:  DATA 00,00
00DB:  DATA E3,30
00DC:  DATA 69,10
00DD:  DATA E4,30
00DE:  DATA 74,10
00DF:  DATA E4,37
00E0:  DATA EE,33
00E1:  DATA 20,34
00E2:  DATA 6F,00
00E3:  DATA F4,17
00E4:  DATA 67,10
00E5:  DATA 63,34
00E6:  DATA 6F,10
00E7:  DATA E3,30
00E8:  DATA A0,30
00E9:  DATA 6E,00
00EA:  DATA 63,34
00EB:  DATA E5,31
00EC:  DATA 6B,10
00ED:  DATA E3,37
00EE:  DATA 6D,10
00EF:  DATA E5,39
00F0:  DATA 70,00
00F1:  DATA 49,37
00F2:  DATA E6,37
00F3:  DATA F2,36
00F4:  DATA 61,3A
00F5:  DATA E9,37
00F6:  DATA 6E,00
00F7:  DATA D6,32
00F8:  DATA F2,39
00F9:  DATA E9,37
00FA:  DATA 6E,1D
00FB:  DATA 20,2B
00FC:  DATA 31,17
00FD:  DATA 30,17
00FE:  DATA 30,00
00FF:  DATA C8,32
0100:  DATA 6C,36
0101:  DATA 6F,10
0102:  DATA 66,39
0103:  DATA EF,36
0104:  DATA 20,28
0105:  DATA C9,21
0106:  DATA 31,1B
0107:  DATA 46,1C
0108:  DATA B7,1B
0109:  DATA C1,10
010A:  DATA 00,00
*
034F:  MOVF   0B,W
0350:  BSF    03.5
0351:  MOVWF  34
0352:  BCF    03.5
0353:  BCF    0B.7
0354:  BSF    03.5
0355:  BSF    03.6
0356:  BSF    0C.7
0357:  BSF    0C.0
0358:  NOP
0359:  NOP
035A:  BCF    03.6
035B:  BTFSS  34.7
035C:  GOTO   360
035D:  BCF    03.5
035E:  BSF    0B.7
035F:  BSF    03.5
0360:  BCF    03.5
0361:  BSF    03.6
0362:  MOVF   0C,W
0363:  ANDLW  7F
0364:  BTFSC  03.2
0365:  GOTO   3C1
0366:  BSF    03.5
0367:  BCF    03.6
0368:  MOVWF  34
0369:  BCF    03.5
036A:  BSF    03.6
036B:  MOVF   0D,W
036C:  BSF    03.5
036D:  BCF    03.6
036E:  MOVWF  35
036F:  BCF    03.5
0370:  BSF    03.6
0371:  MOVF   0F,W
0372:  BSF    03.5
0373:  BCF    03.6
0374:  MOVWF  36
0375:  MOVF   34,W
0376:  MOVWF  37
0377:  BCF    03.5
0378:  CALL   332
0379:  BSF    03.5
037A:  MOVF   35,W
037B:  BCF    03.5
037C:  BSF    03.6
037D:  MOVWF  0D
037E:  BSF    03.5
037F:  BCF    03.6
0380:  MOVF   36,W
0381:  BCF    03.5
0382:  BSF    03.6
0383:  MOVWF  0F
0384:  BCF    03.6
0385:  MOVF   0B,W
0386:  BSF    03.5
0387:  MOVWF  37
0388:  BCF    03.5
0389:  BCF    0B.7
038A:  BSF    03.5
038B:  BSF    03.6
038C:  BSF    0C.7
038D:  BSF    0C.0
038E:  NOP
038F:  NOP
0390:  BCF    03.6
0391:  BTFSS  37.7
0392:  GOTO   396
0393:  BCF    03.5
0394:  BSF    0B.7
0395:  BSF    03.5
0396:  BCF    03.5
0397:  BSF    03.6
0398:  RLF    0C,W
0399:  RLF    0E,W
039A:  ANDLW  7F
039B:  BTFSC  03.2
039C:  GOTO   3C1
039D:  BSF    03.5
039E:  BCF    03.6
039F:  MOVWF  34
03A0:  BCF    03.5
03A1:  BSF    03.6
03A2:  MOVF   0D,W
03A3:  BSF    03.5
03A4:  BCF    03.6
03A5:  MOVWF  35
03A6:  BCF    03.5
03A7:  BSF    03.6
03A8:  MOVF   0F,W
03A9:  BSF    03.5
03AA:  BCF    03.6
03AB:  MOVWF  36
03AC:  MOVF   34,W
03AD:  MOVWF  37
03AE:  BCF    03.5
03AF:  CALL   332
03B0:  BSF    03.5
03B1:  MOVF   35,W
03B2:  BCF    03.5
03B3:  BSF    03.6
03B4:  MOVWF  0D
03B5:  BSF    03.5
03B6:  BCF    03.6
03B7:  MOVF   36,W
03B8:  BCF    03.5
03B9:  BSF    03.6
03BA:  MOVWF  0F
03BB:  INCF   0D,F
03BC:  BTFSC  03.2
03BD:  INCF   0F,F
03BE:  BCF    03.6
03BF:  GOTO   34F
03C0:  BSF    03.6
03C1:  BCF    03.6
03C2:  RETURN
*
03E9:  MOVF   0B,W
03EA:  MOVWF  7B
03EB:  BCF    0B.7
03EC:  BSF    03.5
03ED:  BSF    03.6
03EE:  BSF    0C.7
03EF:  BSF    0C.0
03F0:  NOP
03F1:  NOP
03F2:  BTFSS  7B.7
03F3:  GOTO   3F9
03F4:  BCF    03.5
03F5:  BCF    03.6
03F6:  BSF    0B.7
03F7:  BSF    03.5
03F8:  BSF    03.6
03F9:  BCF    03.5
03FA:  MOVF   0C,W
03FB:  ANDLW  7F
03FC:  BTFSC  03.2
03FD:  GOTO   439
03FE:  MOVWF  7B
03FF:  MOVF   0D,W
0400:  MOVWF  7C
0401:  MOVF   0F,W
0402:  MOVWF  7D
0403:  MOVF   7B,W
0404:  BCF    03.6
0405:  BTFSS  0C.4
0406:  GOTO   405
0407:  MOVWF  19
0408:  MOVF   7C,W
0409:  BSF    03.6
040A:  MOVWF  0D
040B:  MOVF   7D,W
040C:  MOVWF  0F
040D:  BCF    03.6
040E:  MOVF   0B,W
040F:  MOVWF  7E
0410:  BCF    0B.7
0411:  BSF    03.5
0412:  BSF    03.6
0413:  BSF    0C.7
0414:  BSF    0C.0
0415:  NOP
0416:  NOP
0417:  BTFSS  7E.7
0418:  GOTO   41E
0419:  BCF    03.5
041A:  BCF    03.6
041B:  BSF    0B.7
041C:  BSF    03.5
041D:  BSF    03.6
041E:  BCF    03.5
041F:  RLF    0C,W
0420:  RLF    0E,W
0421:  ANDLW  7F
0422:  BTFSC  03.2
0423:  GOTO   439
0424:  MOVWF  7B
0425:  MOVF   0D,W
0426:  MOVWF  7C
0427:  MOVF   0F,W
0428:  MOVWF  7D
0429:  MOVF   7B,W
042A:  BCF    03.6
042B:  BTFSS  0C.4
042C:  GOTO   42B
042D:  MOVWF  19
042E:  MOVF   7C,W
042F:  BSF    03.6
0430:  MOVWF  0D
0431:  MOVF   7D,W
0432:  MOVWF  0F
0433:  INCF   0D,F
0434:  BTFSC  03.2
0435:  INCF   0F,F
0436:  BCF    03.6
0437:  GOTO   3E9
0438:  BSF    03.6
0439:  BCF    03.6
043A:  RETURN
043B:  MOVF   76,W
043C:  ANDLW  07
043D:  MOVWF  77
043E:  RRF    76,W
043F:  MOVWF  78
0440:  RRF    78,F
0441:  RRF    78,F
0442:  MOVLW  1F
0443:  ANDWF  78,F
0444:  MOVF   78,W
0445:  ADDWF  7C,W
0446:  MOVWF  04
0447:  BCF    03.7
0448:  BTFSC  7D.0
0449:  BSF    03.7
044A:  CLRF   78
044B:  INCF   78,F
044C:  INCF   77,F
044D:  GOTO   44F
044E:  RLF    78,F
044F:  DECFSZ 77,F
0450:  GOTO   44E
0451:  MOVF   7B,F
0452:  BTFSC  03.2
0453:  GOTO   457
0454:  MOVF   78,W
0455:  IORWF  00,F
0456:  GOTO   45A
0457:  COMF   78,F
0458:  MOVF   78,W
0459:  ANDWF  00,F
045A:  RETURN
045B:  MOVF   76,W
045C:  ANDLW  07
045D:  MOVWF  77
045E:  RRF    76,W
045F:  MOVWF  78
0460:  RRF    78,F
0461:  RRF    78,F
0462:  MOVLW  1F
0463:  ANDWF  78,F
0464:  MOVF   78,W
0465:  ADDWF  7B,W
0466:  MOVWF  04
0467:  BCF    03.7
0468:  BTFSC  7C.0
0469:  BSF    03.7
046A:  MOVF   00,W
046B:  MOVWF  78
046C:  INCF   77,F
046D:  GOTO   46F
046E:  RRF    78,F
046F:  DECFSZ 77,F
0470:  GOTO   46E
0471:  MOVLW  01
0472:  ANDWF  78,F
0473:  RETURN
*
050B:  CLRF   78
050C:  CLRF   79
050D:  CLRF   77
050E:  CLRF   7A
050F:  BSF    03.5
0510:  MOVF   2F,W
0511:  BTFSS  03.2
0512:  GOTO   516
0513:  MOVF   2E,W
0514:  BTFSC  03.2
0515:  GOTO   530
0516:  MOVLW  10
0517:  MOVWF  30
0518:  BCF    03.0
0519:  RLF    2C,F
051A:  RLF    2D,F
051B:  RLF    77,F
051C:  RLF    7A,F
051D:  MOVF   2F,W
051E:  SUBWF  7A,W
051F:  BTFSS  03.2
0520:  GOTO   523
0521:  MOVF   2E,W
0522:  SUBWF  77,W
0523:  BTFSS  03.0
0524:  GOTO   52C
0525:  MOVF   2E,W
0526:  SUBWF  77,F
0527:  BTFSS  03.0
0528:  DECF   7A,F
0529:  MOVF   2F,W
052A:  SUBWF  7A,F
052B:  BSF    03.0
052C:  RLF    78,F
052D:  RLF    79,F
052E:  DECFSZ 30,F
052F:  GOTO   518
0530:  BCF    03.5
0531:  RETURN
*
05BB:  MOVLW  10
05BC:  MOVWF  76
05BD:  CLRF   77
05BE:  CLRF   7A
05BF:  RRF    75,F
05C0:  RRF    74,F
05C1:  BTFSS  03.0
05C2:  GOTO   5C9
05C3:  MOVF   7B,W
05C4:  ADDWF  77,F
05C5:  BTFSC  03.0
05C6:  INCF   7A,F
05C7:  MOVF   7C,W
05C8:  ADDWF  7A,F
05C9:  RRF    7A,F
05CA:  RRF    77,F
05CB:  RRF    79,F
05CC:  RRF    78,F
05CD:  DECFSZ 76,F
05CE:  GOTO   5BF
*
05E4:  CLRF   77
05E5:  CLRF   78
05E6:  BSF    03.5
05E7:  MOVF   25,W
05E8:  BCF    03.0
05E9:  BTFSC  26.0
05EA:  ADDWF  77,F
05EB:  RRF    77,F
05EC:  RRF    78,F
05ED:  BTFSC  26.1
05EE:  ADDWF  77,F
05EF:  RRF    77,F
05F0:  RRF    78,F
05F1:  BTFSC  26.2
05F2:  ADDWF  77,F
05F3:  RRF    77,F
05F4:  RRF    78,F
05F5:  BTFSC  26.3
05F6:  ADDWF  77,F
05F7:  RRF    77,F
05F8:  RRF    78,F
05F9:  BTFSC  26.4
05FA:  ADDWF  77,F
05FB:  RRF    77,F
05FC:  RRF    78,F
05FD:  BTFSC  26.5
05FE:  ADDWF  77,F
05FF:  RRF    77,F
0600:  RRF    78,F
0601:  BTFSC  26.6
0602:  ADDWF  77,F
0603:  RRF    77,F
0604:  RRF    78,F
0605:  BTFSC  26.7
0606:  ADDWF  77,F
0607:  RRF    77,F
0608:  RRF    78,F
0609:  BCF    03.5
060A:  RETURN
*
0620:  BSF    03.5
0621:  MOVF   35,W
0622:  CLRF   78
0623:  SUBWF  34,W
0624:  BTFSC  03.0
0625:  GOTO   629
0626:  MOVF   34,W
0627:  MOVWF  77
0628:  GOTO   635
0629:  CLRF   77
062A:  MOVLW  08
062B:  MOVWF  36
062C:  RLF    34,F
062D:  RLF    77,F
062E:  MOVF   35,W
062F:  SUBWF  77,W
0630:  BTFSC  03.0
0631:  MOVWF  77
0632:  RLF    78,F
0633:  DECFSZ 36,F
0634:  GOTO   62C
0635:  BCF    03.5
0636:  RETURN
*
0958:  MOVF   74,W
0959:  XORWF  75,W
095A:  ANDLW  80
095B:  MOVWF  7C
095C:  BTFSS  74.7
095D:  GOTO   160
095E:  COMF   74,F
095F:  INCF   74,F
0960:  BTFSS  75.7
0961:  GOTO   164
0962:  COMF   75,F
0963:  INCF   75,F
0964:  MOVF   75,W
0965:  CLRF   78
0966:  SUBWF  74,W
0967:  BTFSC  03.0
0968:  GOTO   16C
0969:  MOVF   74,W
096A:  MOVWF  77
096B:  GOTO   178
096C:  CLRF   77
096D:  MOVLW  08
096E:  MOVWF  7B
096F:  RLF    74,F
0970:  RLF    77,F
0971:  MOVF   75,W
0972:  SUBWF  77,W
0973:  BTFSC  03.0
0974:  MOVWF  77
0975:  RLF    78,F
0976:  DECFSZ 7B,F
0977:  GOTO   16F
0978:  BTFSS  7C.7
0979:  GOTO   17C
097A:  COMF   78,F
097B:  INCF   78,F
097C:  RETURN
.................... 
.................... #list
.................... 
.................... #device  adc=10
.................... #fuses   hs, nowdt, put, noprotect, nolvp
.................... #use     delay(clock=20MHz) 
*
01D1:  MOVLW  75
01D2:  MOVWF  04
01D3:  BCF    03.7
01D4:  MOVF   00,W
01D5:  BTFSC  03.2
01D6:  GOTO   1E4
01D7:  MOVLW  06
01D8:  MOVWF  78
01D9:  CLRF   77
01DA:  DECFSZ 77,F
01DB:  GOTO   1DA
01DC:  DECFSZ 78,F
01DD:  GOTO   1D9
01DE:  MOVLW  7B
01DF:  MOVWF  77
01E0:  DECFSZ 77,F
01E1:  GOTO   1E0
01E2:  DECFSZ 00,F
01E3:  GOTO   1D7
01E4:  RETURN
*
02DC:  MOVLW  03
02DD:  BSF    03.5
02DE:  SUBWF  21,F
02DF:  BTFSS  03.0
02E0:  GOTO   2EB
02E1:  MOVLW  A1
02E2:  MOVWF  04
02E3:  BCF    03.7
02E4:  MOVF   00,W
02E5:  BTFSC  03.2
02E6:  GOTO   2EB
02E7:  GOTO   2E9
02E8:  GOTO   2E9
02E9:  DECFSZ 00,F
02EA:  GOTO   2E8
02EB:  BCF    03.5
02EC:  RETURN
.................... #use     i2c(master,slow,sda=pin_c4,scl=pin_c3)
*
0145:  BCF    14.7
0146:  BCF    0C.3
0147:  BSF    03.5
0148:  MOVF   47,W
0149:  BCF    03.5
014A:  MOVWF  13
014B:  MOVLW  02
014C:  BTFSC  14.7
014D:  GOTO   155
014E:  BSF    03.5
014F:  BTFSC  14.2
0150:  GOTO   14F
0151:  MOVLW  00
0152:  BTFSC  11.6
0153:  MOVLW  01
0154:  BCF    03.5
0155:  MOVWF  78
0156:  RETURN
0157:  BCF    14.6
0158:  BSF    03.5
0159:  BSF    11.3
015A:  BTFSC  11.3
015B:  GOTO   15A
015C:  BTFSC  77.0
015D:  BCF    11.5
015E:  BTFSS  77.0
015F:  BSF    11.5
0160:  BSF    11.4
0161:  BTFSC  11.4
0162:  GOTO   161
0163:  BCF    03.5
0164:  MOVF   13,W
0165:  MOVWF  78
0166:  RETURN
.................... #use     rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits = 8, stream=UART_STREAM)
.................... 
.................... //! define name again to user
.................... #define usi8  unsigned int8
.................... #define usi16 unsigned int16
.................... #define usi32 unsigned int32
.................... #define si8   signed   int8
.................... #define si16  signed   int16
.................... #define si32  signed   int32
.................... #define bool int1
.................... 
.................... //! define variables
.................... bool flag_10ms = false;
.................... bool isDs18b20 = false;
.................... 
.................... usi8 limitTemperature = 25;
.................... 
.................... usi16 tick_10ms;
.................... 
.................... usi8 giay_tam, bdn, tt_ht = 0;
.................... si8 gt_mod = 0, tg_chinh = 0;
.................... 
.................... bool e_11, e_22, e_33;
.................... 
.................... usi8 eat_hh, eat_pp, eat_ss;
.................... 
.................... #define maxLevel 6
.................... 
.................... usi8 countLevel = 0;
.................... usi8 countLevelRev = 0;
.................... 
.................... bool flag_servo;
.................... usi8 count_servo = 0;
.................... 
.................... #define tang false
.................... #define giam true
.................... 
.................... //! define available for ds18b20
.................... usi16 temperature;
.................... usi8 dt_ng;
.................... usi16 dt_tp;
.................... usi16 tt;
.................... 
.................... //! define button to use
.................... #ifndef bt0
.................... #define bt0    pin_b0
.................... #endif
.................... 
.................... #ifndef bt1
.................... #define bt1    pin_b1
.................... #endif
.................... 
.................... #ifndef bt2
.................... #define bt2    pin_b2
.................... #endif
.................... 
.................... #ifndef bt3
.................... #define bt3    pin_b3
.................... #endif
.................... 
.................... //! define pin sensors
.................... #define pin_ds18b20 pin_a0
.................... 
.................... //! define pin controls
.................... #ifndef pinServo
.................... #define pinServo    pin_c1
.................... #endif
.................... 
.................... #ifndef pinDLCold
.................... #define pinDLCold     pin_d6
.................... #endif
.................... 
.................... #ifndef pinDLHot
.................... #define pinDLHot      pin_d7
.................... #endif
.................... 
.................... #ifndef ledTest
.................... #define ledTest       pin_b5
.................... #endif
.................... 
.................... #include <library_uart.c>
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
1036:  BCF    03.5
1037:  CLRF   42
1038:  CLRF   43
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... //! define buffer size is 16 byte
.................... #define BUFFER_SIZE 16
.................... 
.................... //! define available for uart buffer
.................... char receivedString[BUFFER_SIZE]="";
1039:  CLRF   44
.................... volatile unsigned int index = 0;
.................... volatile int stringComplete = 0;
.................... volatile unsigned int indexComplete = 0;
.................... 
.................... #int_rda
.................... void read_uart(){
....................    if(kbhit()){
*
005A:  BTFSS  0C.5
005B:  GOTO   086
.................... //!   Read the received character
....................       char receivedChar = getch();  
005C:  BTFSS  0C.5
005D:  GOTO   05C
005E:  MOVF   1A,W
005F:  BSF    03.5
0060:  MOVWF  49
....................        
....................        if (receivedChar == '\r' || receivedChar == '\n') {
0061:  MOVF   49,W
0062:  SUBLW  0D
0063:  BTFSC  03.2
0064:  GOTO   069
0065:  MOVF   49,W
0066:  SUBLW  0A
0067:  BTFSS  03.2
0068:  GOTO   075
.................... //!        End of string (carriage return detected)
....................            receivedString[index] = '\0';  // Null-terminate the string
0069:  MOVLW  44
006A:  BCF    03.5
006B:  ADDWF  54,W
006C:  MOVWF  04
006D:  BCF    03.7
006E:  CLRF   00
....................            indexComplete = index;
006F:  MOVF   54,W
0070:  MOVWF  56
....................            stringComplete = 1;  // Set the flag to indicate string reception complete
0071:  MOVLW  01
0072:  MOVWF  55
....................        } else {
0073:  GOTO   086
0074:  BSF    03.5
....................           // Store the received character
....................            if (index < BUFFER_SIZE - 1) {
0075:  BCF    03.5
0076:  MOVF   54,W
0077:  SUBLW  0E
0078:  BTFSS  03.0
0079:  GOTO   084
....................                receivedString[index++] = receivedChar;
007A:  MOVF   54,W
007B:  INCF   54,F
007C:  ADDLW  44
007D:  MOVWF  04
007E:  BCF    03.7
007F:  BSF    03.5
0080:  MOVF   49,W
0081:  MOVWF  00
....................            } else {
0082:  GOTO   087
0083:  BCF    03.5
....................                // Handle buffer overflow
....................                index = BUFFER_SIZE - 1;  // Prevent overflow
0084:  MOVLW  0F
0085:  MOVWF  54
0086:  BSF    03.5
....................            }
....................        }
....................    }
0087:  BCF    03.5
0088:  BCF    0C.5
0089:  BCF    0A.3
008A:  BCF    0A.4
008B:  GOTO   033
.................... }
.................... 
.................... usi8 decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
*
07BF:  MOVF   75,W
07C0:  BSF    03.5
07C1:  MOVWF  34
07C2:  MOVLW  0A
07C3:  MOVWF  35
07C4:  BCF    03.5
07C5:  CALL   620
07C6:  SWAPF  78,W
07C7:  MOVWF  76
07C8:  MOVLW  F0
07C9:  ANDWF  76,F
07CA:  MOVF   75,W
07CB:  BSF    03.5
07CC:  MOVWF  34
07CD:  MOVLW  0A
07CE:  MOVWF  35
07CF:  BCF    03.5
07D0:  CALL   620
07D1:  MOVF   77,W
07D2:  ADDWF  76,W
07D3:  MOVWF  78
07D4:  RETURN
.................... }
.................... 
.................... void send_ok(){
....................    printf("ss:ok");
*
07B7:  MOVLW  8C
07B8:  BSF    03.6
07B9:  MOVWF  0D
07BA:  MOVLW  00
07BB:  MOVWF  0F
07BC:  BCF    03.6
07BD:  CALL   3E9
07BE:  RETURN
.................... }
.................... 
.................... void handle_uart(){
....................    if (stringComplete) {
*
11BA:  MOVF   55,F
11BB:  BTFSC  03.2
11BC:  GOTO   24F
....................       stringComplete = 0;
11BD:  CLRF   55
....................       index = 0;
11BE:  CLRF   54
....................       indexComplete = 0;
11BF:  CLRF   56
....................       if(receivedString[0] == 's' && receivedString[1] == 't' && receivedString[2] == ':'){
11C0:  MOVF   44,W
11C1:  SUBLW  73
11C2:  BTFSS  03.2
11C3:  GOTO   1DF
11C4:  MOVF   45,W
11C5:  SUBLW  74
11C6:  BTFSS  03.2
11C7:  GOTO   1DF
11C8:  MOVF   46,W
11C9:  SUBLW  3A
11CA:  BTFSS  03.2
11CB:  GOTO   1DF
.................... //!      Header for changing temperature found
.................... //!      frame "st:23"
....................          limitTemperature = ((receivedString[3] - '0') * 10) + (receivedString[4] - '0');
11CC:  MOVLW  30
11CD:  SUBWF  47,W
11CE:  MOVWF  75
11CF:  BSF    03.5
11D0:  MOVWF  25
11D1:  MOVLW  0A
11D2:  MOVWF  26
11D3:  BCF    0A.4
11D4:  BCF    03.5
11D5:  CALL   5E4
11D6:  BSF    0A.4
11D7:  MOVLW  30
11D8:  SUBWF  48,W
11D9:  ADDWF  78,W
11DA:  MOVWF  2D
....................          send_ok();
11DB:  BCF    0A.4
11DC:  CALL   7B7
11DD:  BSF    0A.4
....................       }
11DE:  GOTO   24F
....................       else if(receivedString[0] == 's' && receivedString[1] == 'a' && receivedString[2] == ':'){
11DF:  MOVF   44,W
11E0:  SUBLW  73
11E1:  BTFSS  03.2
11E2:  GOTO   23A
11E3:  MOVF   45,W
11E4:  SUBLW  61
11E5:  BTFSS  03.2
11E6:  GOTO   23A
11E7:  MOVF   46,W
11E8:  SUBLW  3A
11E9:  BTFSS  03.2
11EA:  GOTO   23A
.................... //!      Header for changing alarm settings found
.................... //!      frame "sa:gpg:11-11-11"
....................          if(receivedString[3] == 'g' && receivedString[4] == 'p' && receivedString[5] == 'g'){
11EB:  MOVF   47,W
11EC:  SUBLW  67
11ED:  BTFSS  03.2
11EE:  GOTO   239
11EF:  MOVF   48,W
11F0:  SUBLW  70
11F1:  BTFSS  03.2
11F2:  GOTO   239
11F3:  MOVF   49,W
11F4:  SUBLW  67
11F5:  BTFSS  03.2
11F6:  GOTO   239
....................             // Address for changing gpg alarm settings found
....................             eat_hh = decToBcd((receivedString[7] - '0') * 10) + (receivedString[8] - '0');
11F7:  MOVLW  30
11F8:  SUBWF  4B,W
11F9:  MOVWF  75
11FA:  BSF    03.5
11FB:  MOVWF  25
11FC:  MOVLW  0A
11FD:  MOVWF  26
11FE:  BCF    0A.4
11FF:  BCF    03.5
1200:  CALL   5E4
1201:  BSF    0A.4
1202:  MOVF   78,W
1203:  MOVWF  74
1204:  MOVWF  75
1205:  BCF    0A.4
1206:  CALL   7BF
1207:  BSF    0A.4
1208:  MOVLW  30
1209:  SUBWF  4C,W
120A:  ADDWF  78,W
120B:  MOVWF  35
....................             eat_pp = decToBcd((receivedString[10] - '0') * 10) + (receivedString[11] - '0');
120C:  MOVLW  30
120D:  SUBWF  4E,W
120E:  MOVWF  75
120F:  BSF    03.5
1210:  MOVWF  25
1211:  MOVLW  0A
1212:  MOVWF  26
1213:  BCF    0A.4
1214:  BCF    03.5
1215:  CALL   5E4
1216:  BSF    0A.4
1217:  MOVF   78,W
1218:  MOVWF  74
1219:  MOVWF  75
121A:  BCF    0A.4
121B:  CALL   7BF
121C:  BSF    0A.4
121D:  MOVLW  30
121E:  SUBWF  4F,W
121F:  ADDWF  78,W
1220:  MOVWF  36
....................             eat_ss = decToBcd((receivedString[13] - '0') * 10) + (receivedString[14] - '0');
1221:  MOVLW  30
1222:  SUBWF  51,W
1223:  MOVWF  75
1224:  BSF    03.5
1225:  MOVWF  25
1226:  MOVLW  0A
1227:  MOVWF  26
1228:  BCF    0A.4
1229:  BCF    03.5
122A:  CALL   5E4
122B:  BSF    0A.4
122C:  MOVF   78,W
122D:  MOVWF  74
122E:  MOVWF  75
122F:  BCF    0A.4
1230:  CALL   7BF
1231:  BSF    0A.4
1232:  MOVLW  30
1233:  SUBWF  52,W
1234:  ADDWF  78,W
1235:  MOVWF  37
....................             send_ok();
1236:  BCF    0A.4
1237:  CALL   7B7
1238:  BSF    0A.4
....................          }
....................       }
1239:  GOTO   24F
....................       else if(receivedString[0] == 'c' && receivedString[1] == 's' && receivedString[2] == ':'){
123A:  MOVF   44,W
123B:  SUBLW  63
123C:  BTFSS  03.2
123D:  GOTO   24F
123E:  MOVF   45,W
123F:  SUBLW  73
1240:  BTFSS  03.2
1241:  GOTO   24F
1242:  MOVF   46,W
1243:  SUBLW  3A
1244:  BTFSS  03.2
1245:  GOTO   24F
.................... //!      Header for controling servo manual
.................... //!      frame "cs:1" -> servo on    
.................... //!      frame "cs:0" -> servo off
....................          flag_servo = receivedString[3] - '0';
1246:  MOVLW  30
1247:  SUBWF  47,W
1248:  MOVWF  78
1249:  BCF    2C.5
124A:  BTFSC  78.0
124B:  BSF    2C.5
....................          send_ok();
124C:  BCF    0A.4
124D:  CALL   7B7
124E:  BSF    0A.4
....................       }
....................    }  
.................... }
.................... 
.................... 
.................... #int_timer1
.................... void interrupt_timer1()
.................... {
....................    set_timer1(59286);
*
008F:  CLRF   0E
0090:  MOVLW  E7
0091:  MOVWF  0F
0092:  MOVLW  96
0093:  MOVWF  0E
0094:  NOP
....................    
....................    flag_10ms = !flag_10ms;
0095:  MOVLW  01
0096:  XORWF  2C,F
.................... 
....................    tick_10ms++;
0097:  INCF   2E,F
0098:  BTFSC  03.2
0099:  INCF   2F,F
.................... 
.................... //! when tick_10ms >= 10 --> 100ms
....................    if(tick_10ms >= 10){
009A:  MOVF   2F,F
009B:  BTFSS  03.2
009C:  GOTO   0A1
009D:  MOVF   2E,W
009E:  SUBLW  09
009F:  BTFSC  03.0
00A0:  GOTO   0AE
....................       bdn++;
00A1:  INCF   31,F
....................       tick_10ms = 0;
00A2:  CLRF   2F
00A3:  CLRF   2E
....................       
.................... //! disable flag servo on --> flag_servo >> false
....................       if(flag_servo == true){
00A4:  BTFSS  2C.5
00A5:  GOTO   0AE
....................          if(count_servo < 100) count_servo++; // 10s
00A6:  MOVF   3A,W
00A7:  SUBLW  63
00A8:  BTFSS  03.0
00A9:  GOTO   0AC
00AA:  INCF   3A,F
00AB:  GOTO   0AE
....................          else{
....................             count_servo = 0;
00AC:  CLRF   3A
....................             flag_servo = false;
00AD:  BCF    2C.5
....................          }
....................       }
....................    }
00AE:  BCF    0C.0
00AF:  BCF    0A.3
00B0:  BCF    0A.4
00B1:  GOTO   033
.................... }
.................... 
.................... void setup_initialize(){
.................... //! set up timer 1 to timer count is 10ms of one cycle
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);
*
010B:  MOVLW  B5
010C:  MOVWF  10
....................    set_timer1(59286);
010D:  CLRF   0E
010E:  MOVLW  E7
010F:  MOVWF  0F
0110:  MOVLW  96
0111:  MOVWF  0E
0112:  NOP
.................... 
.................... //! enable interrupt timer 1 and read data uart
....................    enable_interrupts(global);
0113:  MOVLW  C0
0114:  IORWF  0B,F
....................    enable_interrupts(int_timer1);
0115:  BSF    03.5
0116:  BSF    0C.0
....................    enable_interrupts(int_rda);
0117:  BSF    0C.5
.................... 
.................... 
.................... //! setup mode for all gpio of pic16f877a
....................    set_tris_a(0xff);
0118:  MOVLW  FF
0119:  MOVWF  05
....................    set_tris_b(0xdf);
011A:  MOVLW  DF
011B:  MOVWF  06
....................    set_tris_d(0x00); output_d(0x00);
011C:  MOVLW  00
011D:  MOVWF  08
011E:  CLRF   08
011F:  BCF    03.5
0120:  CLRF   08
....................    set_tris_e(0x00); output_e(0x00);
0121:  BSF    03.5
0122:  BCF    09.0
0123:  BCF    09.1
0124:  BCF    09.2
0125:  BCF    09.0
0126:  BCF    09.1
0127:  BCF    09.2
0128:  BCF    03.5
0129:  CLRF   09
....................    set_tris_c(0x98); output_c(0x98);
012A:  MOVLW  98
012B:  BSF    03.5
012C:  MOVWF  07
012D:  BCF    03.5
012E:  MOVWF  2B
012F:  MOVLW  00
0130:  MOVWF  2B
0131:  BSF    03.5
0132:  CLRF   07
0133:  MOVLW  98
0134:  BCF    03.5
0135:  MOVWF  07
....................  
.................... //! setup variable initialize
....................    flag_10ms = false;
0136:  BCF    2C.0
....................    isDs18b20 = false;
0137:  BCF    2C.1
....................    
....................    limitTemperature = 25;
0138:  MOVLW  19
0139:  MOVWF  2D
....................    
....................    e_11 = true; e_22 = true; e_33 = true;
013A:  BSF    2C.2
013B:  BSF    2C.3
013C:  BSF    2C.4
....................    
....................    eat_hh = 0x09; eat_pp = 0x30; eat_ss = 0x30;
013D:  MOVLW  09
013E:  MOVWF  35
013F:  MOVLW  30
0140:  MOVWF  36
0141:  MOVWF  37
0142:  BCF    0A.3
0143:  BSF    0A.4
0144:  GOTO   05E (RETURN)
.................... }
.................... 
.................... #include <library_button.c>
.................... //! button place
.................... //! bt3 - bt2 - bt1 - bt0
.................... 
.................... usi8 countPush = 0;
.................... usi8 countTick = 0;
.................... 
.................... bool push_btn(bool isRelease, usi8 pin){
.................... //! isRelease == 0 --> push button is hold
.................... //! isRelease == 1 --> push button is release
....................    if(!input(pin)){
*
1077:  MOVF   75,W
1078:  MOVWF  76
1079:  MOVLW  01
107A:  MOVWF  7B
107B:  CLRF   7D
107C:  MOVLW  80
107D:  MOVWF  7C
107E:  BCF    0A.4
107F:  CALL   43B
1080:  BSF    0A.4
1081:  MOVF   75,W
1082:  MOVWF  76
1083:  CLRF   7C
1084:  CLRF   7B
1085:  BCF    0A.4
1086:  CALL   45B
1087:  BSF    0A.4
1088:  BTFSC  78.0
1089:  GOTO   0C4
....................       if(flag_10ms == true) countPush++;
108A:  BTFSS  2C.0
108B:  GOTO   08D
108C:  INCF   59,F
.................... //! check if countPush == 2 (20ms) --> debound button
....................       if(countPush >= 1){
108D:  MOVF   59,W
108E:  SUBLW  00
108F:  BTFSC  03.0
1090:  GOTO   0C1
....................          if(!input(pin)){
1091:  MOVF   75,W
1092:  MOVWF  76
1093:  MOVLW  01
1094:  MOVWF  7B
1095:  CLRF   7D
1096:  MOVLW  80
1097:  MOVWF  7C
1098:  BCF    0A.4
1099:  CALL   43B
109A:  BSF    0A.4
109B:  MOVF   75,W
109C:  MOVWF  76
109D:  CLRF   7C
109E:  CLRF   7B
109F:  BCF    0A.4
10A0:  CALL   45B
10A1:  BSF    0A.4
10A2:  BTFSC  78.0
10A3:  GOTO   0BE
....................             if(isRelease == false) while(!input(pin));
10A4:  MOVF   74,F
10A5:  BTFSS  03.2
10A6:  GOTO   0BA
10A7:  MOVF   75,W
10A8:  MOVWF  76
10A9:  MOVLW  01
10AA:  MOVWF  7B
10AB:  CLRF   7D
10AC:  MOVLW  80
10AD:  MOVWF  7C
10AE:  BCF    0A.4
10AF:  CALL   43B
10B0:  BSF    0A.4
10B1:  MOVF   75,W
10B2:  MOVWF  76
10B3:  CLRF   7C
10B4:  CLRF   7B
10B5:  BCF    0A.4
10B6:  CALL   45B
10B7:  BSF    0A.4
10B8:  BTFSS  78.0
10B9:  GOTO   0A7
....................             countPush = 0;
10BA:  CLRF   59
....................             return true;
10BB:  MOVLW  01
10BC:  MOVWF  78
10BD:  GOTO   0C6
....................          }
....................          return false;
10BE:  MOVLW  00
10BF:  MOVWF  78
10C0:  GOTO   0C6
....................       }
....................       return false;
10C1:  MOVLW  00
10C2:  MOVWF  78
10C3:  GOTO   0C6
....................    }
.................... //!   countPush = 0;
....................    return false;
10C4:  MOVLW  00
10C5:  MOVWF  78
.................... }
.................... 
.................... bool tick_btn(usi8 delay, usi8 pin){
.................... //! dl is time delay that compute with 10ms for dl is 1
....................    if(!input(pin)){
*
07D5:  MOVF   75,W
07D6:  MOVWF  76
07D7:  MOVLW  01
07D8:  MOVWF  7B
07D9:  CLRF   7D
07DA:  MOVLW  80
07DB:  MOVWF  7C
07DC:  CALL   43B
07DD:  MOVF   75,W
07DE:  MOVWF  76
07DF:  CLRF   7C
07E0:  CLRF   7B
07E1:  CALL   45B
07E2:  BTFSC  78.0
07E3:  GOTO   7F1
....................       if(flag_10ms == true) countTick++;
07E4:  BTFSC  2C.0
07E5:  INCF   5A,F
.................... //! check if countTick >= delay (delay * 10ms) --> time delay wanna to tick rising signal
....................       if(countTick >= delay){
07E6:  MOVF   74,W
07E7:  SUBWF  5A,W
07E8:  BTFSS  03.0
07E9:  GOTO   7EE
....................          countTick = 0;
07EA:  CLRF   5A
....................          return true;
07EB:  MOVLW  01
07EC:  MOVWF  78
07ED:  GOTO   7F3
....................       }
....................       return false;
07EE:  MOVLW  00
07EF:  MOVWF  78
07F0:  GOTO   7F3
....................    }
.................... //!   countTick = 0;
....................    return false;
07F1:  MOVLW  00
07F2:  MOVWF  78
07F3:  RETURN
.................... }
.................... 
.................... #include <library_i2c.c>
.................... #define pcf8574_addr_wr 0x4E // 0b01001110
.................... #define pcf8574_addr_rd 0x4F // 0b01001111
.................... 
.................... //! i2c reset
.................... void i2c_reset()
.................... {
....................    i2c_start();
....................    i2c_stop();
.................... }
.................... 
.................... //! i2c setup write for pcf8574
.................... void i2c_setup_write()
.................... {
....................    i2c_start();
*
026C:  BSF    03.5
026D:  BSF    11.0
026E:  BTFSC  11.0
026F:  GOTO   26E
....................    i2c_write(pcf8574_addr_wr);
0270:  MOVLW  4E
0271:  MOVWF  47
0272:  BCF    03.5
0273:  CALL   145
.................... }
.................... 
.................... //! i2c write 1byte for pcf8574
.................... void i2c_write_1byte(usi8 payload)
.................... {
....................    i2c_start();
*
01EF:  BSF    11.1
01F0:  BTFSC  11.1
01F1:  GOTO   1F0
*
020D:  BSF    11.1
020E:  BTFSC  11.1
020F:  GOTO   20E
*
022C:  BSF    11.1
022D:  BTFSC  11.1
022E:  GOTO   22D
*
0285:  BSF    11.1
0286:  BTFSC  11.1
0287:  GOTO   286
....................    i2c_write(pcf8574_addr_wr);
*
01F2:  MOVLW  4E
01F3:  MOVWF  47
01F4:  BCF    03.5
01F5:  CALL   145
*
0210:  MOVLW  4E
0211:  MOVWF  47
0212:  BCF    03.5
0213:  CALL   145
*
022F:  MOVLW  4E
0230:  MOVWF  47
0231:  BCF    03.5
0232:  CALL   145
*
0288:  MOVLW  4E
0289:  MOVWF  47
028A:  BCF    03.5
028B:  CALL   145
....................    i2c_write(payload);
*
01F6:  BSF    03.5
01F7:  MOVF   46,W
01F8:  MOVWF  47
01F9:  BCF    03.5
01FA:  CALL   145
*
0214:  BSF    03.5
0215:  MOVF   46,W
0216:  MOVWF  47
0217:  BCF    03.5
0218:  CALL   145
*
0233:  BSF    03.5
0234:  MOVF   46,W
0235:  MOVWF  47
0236:  BCF    03.5
0237:  CALL   145
*
028C:  BSF    03.5
028D:  MOVF   46,W
028E:  MOVWF  47
028F:  BCF    03.5
0290:  CALL   145
....................    i2c_stop();
*
01FB:  BSF    03.5
01FC:  BSF    11.2
01FD:  BTFSC  11.2
01FE:  GOTO   1FD
*
0219:  BSF    03.5
021A:  BSF    11.2
021B:  BTFSC  11.2
021C:  GOTO   21B
*
0238:  BSF    03.5
0239:  BSF    11.2
023A:  BTFSC  11.2
023B:  GOTO   23A
*
0291:  BSF    03.5
0292:  BSF    11.2
0293:  BTFSC  11.2
0294:  GOTO   293
.................... }
.................... 
.................... 
.................... #include <library_lcd_i2c.c>
.................... #define lcd_cols 16
.................... #define lcd_rows 2
.................... 
.................... // commands
.................... #define LCD_CLEARDISPLAY 0x01
.................... #define LCD_RETURNHOME 0x02
.................... #define LCD_ENTRYMODESET 0x04
.................... #define LCD_DISPLAYCONTROL 0x08
.................... #define LCD_CURSORSHIFT 0x10
.................... #define LCD_FUNCTIONSET 0x20
.................... #define LCD_SETCGRAMADDR 0x40
.................... #define LCD_SETDDRAMADDR 0x80
.................... 
.................... // flags for display entry mode
.................... #define LCD_ENTRYRIGHT 0x00
.................... #define LCD_ENTRYLEFT 0x02
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00
.................... 
.................... // flags for display on/off control
.................... #define LCD_DISPLAYON 0x04
.................... #define LCD_DISPLAYOFF 0x00
.................... #define LCD_CURSORON 0x02
.................... #define LCD_CURSOROFF 0x00
.................... #define LCD_BLINKON 0x01
.................... #define LCD_BLINKOFF 0x00
.................... 
.................... // flags for display/cursor shift
.................... #define LCD_DISPLAYMOVE 0x08
.................... #define LCD_CURSORMOVE 0x00
.................... #define LCD_MOVERIGHT 0x04
.................... #define LCD_MOVELEFT 0x00
.................... 
.................... // flags for function set
.................... #define LCD_8BITMODE 0x10
.................... #define LCD_4BITMODE 0x00
.................... #define LCD_2LINE 0x08
.................... #define LCD_1LINE 0x00
.................... #define LCD_5x10DOTS 0x04
.................... #define LCD_5x8DOTS 0x00
.................... 
.................... // flags for backlight control
.................... #define LCD_BACKLIGHT 0x08
.................... #define LCD_NOBACKLIGHT 0x00
.................... 
.................... #define En 0B00000100  // Enable bit
.................... #define Rw 0B00000010  // Read/Write bit
.................... #define Rs 0B00000001  // Register select bit
.................... 
.................... void write4bits(usi8 value);
.................... void expanderWrite(usi8 _data);
.................... void pulseEnable(usi8 _data);
.................... void lcd_command(usi8 value);
.................... void lcd_display();
.................... void lcd_clear();
.................... void lcd_home();
.................... void lcd_send(usi8 value, usi8 mode);
.................... void lcd_data(usi8 value);
.................... 
.................... usi8 _displayfunction;
.................... usi8 _displaycontrol;
.................... usi8 _displaymode;
.................... usi8 _numlines;
.................... usi8 _cols;
.................... usi8 _rows;
.................... usi8 _backlightval;
.................... 
.................... void lcd_setup(){
....................    _cols = lcd_cols; // 16
*
0267:  MOVLW  10
0268:  MOVWF  5F
....................    _rows = lcd_rows; // 2
0269:  MOVLW  02
026A:  MOVWF  60
....................    _backlightval = LCD_NOBACKLIGHT; // back light is off
026B:  CLRF   61
....................    
....................    i2c_setup_write(); // setup i2c
....................    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
*
0274:  CLRF   5B
....................    
....................    _displayfunction |= LCD_2LINE;
0275:  BSF    5B.3
....................    _numlines = _rows; // 2
0276:  MOVF   60,W
0277:  MOVWF  5E
....................    
....................    delay_ms(40);
0278:  MOVLW  28
0279:  MOVWF  75
027A:  CALL   1D1
....................    
....................    expanderWrite(_backlightval); // back light is on
027B:  MOVF   61,W
027C:  BSF    03.5
027D:  MOVWF  44
....................    delay_ms(100);
*
0295:  MOVLW  64
0296:  MOVWF  75
0297:  BCF    03.5
0298:  CALL   1D1
....................    
....................    //It is try to set use 4bit in 3 time
....................    write4bits(0x03 << 4);
0299:  MOVLW  30
029A:  BSF    03.5
029B:  MOVWF  41
029C:  BCF    03.5
029D:  CALL   1E5
....................    delay_ms(5);
029E:  MOVLW  05
029F:  MOVWF  75
02A0:  CALL   1D1
....................    
....................    write4bits(0x03 << 4);
02A1:  MOVLW  30
02A2:  BSF    03.5
02A3:  MOVWF  41
02A4:  BCF    03.5
02A5:  CALL   1E5
....................    delay_ms(5);
02A6:  MOVLW  05
02A7:  MOVWF  75
02A8:  CALL   1D1
....................    
....................    write4bits(0x03 << 4);
02A9:  MOVLW  30
02AA:  BSF    03.5
02AB:  MOVWF  41
02AC:  BCF    03.5
02AD:  CALL   1E5
....................    delay_ms(5);
02AE:  MOVLW  05
02AF:  MOVWF  75
02B0:  CALL   1D1
....................    
....................    write4bits(0x02 << 4); // set using 4bit for lcd16x2
02B1:  MOVLW  20
02B2:  BSF    03.5
02B3:  MOVWF  41
02B4:  BCF    03.5
02B5:  CALL   1E5
....................    
....................    lcd_command(LCD_FUNCTIONSET | _displayfunction);
02B6:  MOVF   5B,W
02B7:  IORLW  20
02B8:  MOVWF  74
02B9:  BSF    03.5
02BA:  MOVWF  3B
02BB:  BCF    03.5
02BC:  CALL   242
....................    
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
02BD:  MOVLW  04
02BE:  MOVWF  5C
....................    lcd_display();
....................    
....................    lcd_clear();
*
02C7:  CALL   25E
....................    
....................    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
02C8:  MOVLW  02
02C9:  MOVWF  5D
....................    lcd_command(LCD_ENTRYMODESET | _displaymode);
02CA:  MOVF   5D,W
02CB:  IORLW  04
02CC:  MOVWF  74
02CD:  BSF    03.5
02CE:  MOVWF  3B
02CF:  BCF    03.5
02D0:  CALL   242
....................    
....................    lcd_home();
*
02D9:  BCF    0A.3
02DA:  BSF    0A.4
02DB:  GOTO   064 (RETURN)
.................... }
.................... 
.................... void lcd_clear(){
....................    lcd_command(LCD_CLEARDISPLAY);
*
025E:  MOVLW  01
025F:  BSF    03.5
0260:  MOVWF  3B
0261:  BCF    03.5
0262:  CALL   242
....................    delay_ms(20);
0263:  MOVLW  14
0264:  MOVWF  75
0265:  CALL   1D1
0266:  RETURN
.................... }
.................... 
.................... void lcd_home(){
....................    lcd_command(LCD_RETURNHOME);
*
02D1:  MOVLW  02
02D2:  BSF    03.5
02D3:  MOVWF  3B
02D4:  BCF    03.5
02D5:  CALL   242
....................    delay_ms(20);
02D6:  MOVLW  14
02D7:  MOVWF  75
02D8:  CALL   1D1
.................... }
.................... 
.................... void lcd_setCursor(usi8 col, usi8 row){
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
*
0313:  BSF    03.5
0314:  CLRF   36
0315:  MOVLW  40
0316:  MOVWF  37
0317:  MOVLW  14
0318:  MOVWF  38
0319:  MOVLW  54
031A:  MOVWF  39
....................    if ( row > _numlines ) {
031B:  MOVF   35,W
031C:  BCF    03.5
031D:  SUBWF  5E,W
031E:  BTFSC  03.0
031F:  GOTO   325
....................       row = _numlines-1;
0320:  MOVLW  01
0321:  SUBWF  5E,W
0322:  BSF    03.5
0323:  MOVWF  35
0324:  BCF    03.5
....................    }
....................    lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
0325:  MOVLW  B6
0326:  BSF    03.5
0327:  ADDWF  35,W
0328:  MOVWF  04
0329:  BCF    03.7
032A:  MOVF   00,W
032B:  ADDWF  34,W
032C:  IORLW  80
032D:  MOVWF  3A
032E:  MOVWF  3B
032F:  BCF    03.5
0330:  CALL   242
0331:  RETURN
.................... }
.................... 
.................... void lcd_display() {
....................    _displaycontrol |= LCD_DISPLAYON;
*
02BF:  BSF    5C.2
....................    lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
02C0:  MOVF   5C,W
02C1:  IORLW  08
02C2:  MOVWF  74
02C3:  BSF    03.5
02C4:  MOVWF  3B
02C5:  BCF    03.5
02C6:  CALL   242
.................... }
.................... 
.................... void lcd_command(usi8 value){
....................    lcd_send(value,0);
*
0242:  BSF    03.5
0243:  MOVF   3B,W
0244:  MOVWF  3C
0245:  CLRF   3D
*
025D:  RETURN
.................... }
.................... 
.................... void lcd_data(usi8 value){
....................    lcd_send(value,Rs);
*
0332:  BSF    03.5
0333:  MOVF   37,W
0334:  MOVWF  3C
0335:  MOVLW  01
0336:  MOVWF  3D
*
034E:  RETURN
.................... }
.................... 
.................... void lcd_send(usi8 value, usi8 mode) {
*
0246:  MOVF   3C,W
0247:  ANDLW  F0
0248:  MOVWF  3E
0249:  SWAPF  3C,W
024A:  MOVWF  77
024B:  MOVLW  F0
024C:  ANDWF  77,F
024D:  MOVF   77,W
024E:  ANDLW  F0
024F:  MOVWF  3F
*
0337:  MOVF   3C,W
0338:  ANDLW  F0
0339:  MOVWF  3E
033A:  SWAPF  3C,W
033B:  MOVWF  77
033C:  MOVLW  F0
033D:  ANDWF  77,F
033E:  MOVF   77,W
033F:  ANDLW  F0
0340:  MOVWF  3F
....................    usi8 highnib=value&0xf0;
....................    usi8 lownib=(value<<4)&0xf0;
....................    write4bits((highnib)|mode);
*
0250:  MOVF   3E,W
0251:  IORWF  3D,W
0252:  MOVWF  40
0253:  MOVWF  41
0254:  BCF    03.5
0255:  CALL   1E5
*
0341:  MOVF   3E,W
0342:  IORWF  3D,W
0343:  MOVWF  40
0344:  MOVWF  41
0345:  BCF    03.5
0346:  CALL   1E5
....................    write4bits((lownib)|mode); 
*
0256:  BSF    03.5
0257:  MOVF   3F,W
0258:  IORWF  3D,W
0259:  MOVWF  40
025A:  MOVWF  41
025B:  BCF    03.5
025C:  CALL   1E5
*
0347:  BSF    03.5
0348:  MOVF   3F,W
0349:  IORWF  3D,W
034A:  MOVWF  40
034B:  MOVWF  41
034C:  BCF    03.5
034D:  CALL   1E5
.................... }
.................... 
.................... void write4bits(usi8 value) {
....................    expanderWrite(value);
*
01E5:  BSF    03.5
01E6:  MOVF   41,W
01E7:  MOVWF  44
....................    pulseEnable(value);
*
01FF:  MOVF   41,W
0200:  MOVWF  42
*
0240:  BCF    03.5
0241:  RETURN
.................... }
.................... 
.................... void expanderWrite(usi8 _data){
....................    i2c_write_1byte(_data|_backlightval);
*
01E8:  MOVF   44,W
01E9:  BCF    03.5
01EA:  IORWF  61,W
01EB:  BSF    03.5
01EC:  MOVWF  45
01ED:  MOVF   45,W
01EE:  MOVWF  46
*
0206:  MOVF   44,W
0207:  BCF    03.5
0208:  IORWF  61,W
0209:  BSF    03.5
020A:  MOVWF  45
020B:  MOVF   45,W
020C:  MOVWF  46
*
0225:  MOVF   44,W
0226:  BCF    03.5
0227:  IORWF  61,W
0228:  BSF    03.5
0229:  MOVWF  45
022A:  MOVF   45,W
022B:  MOVWF  46
*
027E:  MOVF   44,W
027F:  BCF    03.5
0280:  IORWF  61,W
0281:  BSF    03.5
0282:  MOVWF  45
0283:  MOVF   45,W
0284:  MOVWF  46
.................... }
.................... 
.................... void pulseEnable(usi8 _data){
....................    expanderWrite(_data | En);
*
0201:  MOVF   42,W
0202:  IORLW  04
0203:  MOVWF  43
0204:  MOVF   43,W
0205:  MOVWF  44
....................    delay_us(1);
*
021D:  GOTO   21E
021E:  GOTO   21F
021F:  NOP
....................    expanderWrite(_data & ~En);
0220:  MOVF   42,W
0221:  ANDLW  FB
0222:  MOVWF  43
0223:  MOVF   43,W
0224:  MOVWF  44
....................    delay_us(50);
*
023C:  MOVLW  53
023D:  MOVWF  77
023E:  DECFSZ 77,F
023F:  GOTO   23E
.................... }
.................... 
.................... void log_lcd_initialize(){
....................    lcd_setCursor(1,0);
*
03C3:  MOVLW  01
03C4:  BSF    03.5
03C5:  MOVWF  34
03C6:  CLRF   35
03C7:  BCF    03.5
03C8:  CALL   313
....................    lcd_data("Do an 1 - HKII");
03C9:  MOVLW  B2
03CA:  BSF    03.6
03CB:  MOVWF  0D
03CC:  MOVLW  00
03CD:  MOVWF  0F
03CE:  BCF    03.6
03CF:  CALL   34F
....................    lcd_setCursor(3,1);
03D0:  MOVLW  03
03D1:  BSF    03.5
03D2:  MOVWF  34
03D3:  MOVLW  01
03D4:  MOVWF  35
03D5:  BCF    03.5
03D6:  CALL   313
....................    lcd_data("SPKT-TPHCM");
03D7:  MOVLW  BA
03D8:  BSF    03.6
03D9:  MOVWF  0D
03DA:  MOVLW  00
03DB:  MOVWF  0F
03DC:  BCF    03.6
03DD:  CALL   34F
....................    delay_ms(2000);
03DE:  MOVLW  08
03DF:  MOVWF  74
03E0:  MOVLW  FA
03E1:  MOVWF  75
03E2:  CALL   1D1
03E3:  DECFSZ 74,F
03E4:  GOTO   3E0
....................    lcd_clear();
03E5:  CALL   25E
03E6:  BCF    0A.3
03E7:  BSF    0A.4
03E8:  GOTO   06A (RETURN)
.................... }
.................... 
.................... void lcd_dis_xx_yy_zz(usi8 x, usi8 y, usi8 a, usi8 b, usi8 c, bool e3, bool e2, bool e1){
....................    usi8 a_ch, a_dv, b_ch, b_dv, c_ch, c_dv;
....................    a_ch = e3 == true ? a/10 + 0x30 : 0x20; a_dv = e3 == true ? a%10 + 0x30 : 0x20;
*
0637:  BSF    03.5
0638:  DECFSZ 2B,W
0639:  GOTO   644
063A:  MOVF   28,W
063B:  MOVWF  34
063C:  MOVLW  0A
063D:  MOVWF  35
063E:  BCF    03.5
063F:  CALL   620
0640:  MOVLW  30
0641:  ADDWF  78,W
0642:  GOTO   646
0643:  BSF    03.5
0644:  MOVLW  20
0645:  BCF    03.5
0646:  BSF    03.5
0647:  MOVWF  2E
0648:  DECFSZ 2B,W
0649:  GOTO   654
064A:  MOVF   28,W
064B:  MOVWF  34
064C:  MOVLW  0A
064D:  MOVWF  35
064E:  BCF    03.5
064F:  CALL   620
0650:  MOVLW  30
0651:  ADDWF  77,W
0652:  GOTO   656
0653:  BSF    03.5
0654:  MOVLW  20
0655:  BCF    03.5
0656:  BSF    03.5
0657:  MOVWF  2F
....................    b_ch = e2 == true ? b/10 + 0x30 : 0x20; b_dv = e2 == true ? b%10 + 0x30 : 0x20;
0658:  DECFSZ 2C,W
0659:  GOTO   664
065A:  MOVF   29,W
065B:  MOVWF  34
065C:  MOVLW  0A
065D:  MOVWF  35
065E:  BCF    03.5
065F:  CALL   620
0660:  MOVLW  30
0661:  ADDWF  78,W
0662:  GOTO   666
0663:  BSF    03.5
0664:  MOVLW  20
0665:  BCF    03.5
0666:  BSF    03.5
0667:  MOVWF  30
0668:  DECFSZ 2C,W
0669:  GOTO   674
066A:  MOVF   29,W
066B:  MOVWF  34
066C:  MOVLW  0A
066D:  MOVWF  35
066E:  BCF    03.5
066F:  CALL   620
0670:  MOVLW  30
0671:  ADDWF  77,W
0672:  GOTO   676
0673:  BSF    03.5
0674:  MOVLW  20
0675:  BCF    03.5
0676:  BSF    03.5
0677:  MOVWF  31
....................    c_ch = e1 == true ? c/10 + 0x30 : 0x20; c_dv = e1 == true ? c%10 + 0x30 : 0x20;
0678:  DECFSZ 2D,W
0679:  GOTO   684
067A:  MOVF   2A,W
067B:  MOVWF  34
067C:  MOVLW  0A
067D:  MOVWF  35
067E:  BCF    03.5
067F:  CALL   620
0680:  MOVLW  30
0681:  ADDWF  78,W
0682:  GOTO   686
0683:  BSF    03.5
0684:  MOVLW  20
0685:  BCF    03.5
0686:  BSF    03.5
0687:  MOVWF  32
0688:  DECFSZ 2D,W
0689:  GOTO   694
068A:  MOVF   2A,W
068B:  MOVWF  34
068C:  MOVLW  0A
068D:  MOVWF  35
068E:  BCF    03.5
068F:  CALL   620
0690:  MOVLW  30
0691:  ADDWF  77,W
0692:  GOTO   696
0693:  BSF    03.5
0694:  MOVLW  20
0695:  BCF    03.5
0696:  BSF    03.5
0697:  MOVWF  33
....................    lcd_setCursor(x, y);
0698:  MOVF   26,W
0699:  MOVWF  34
069A:  MOVF   27,W
069B:  MOVWF  35
069C:  BCF    03.5
069D:  CALL   313
....................    lcd_data(a_ch); lcd_data(a_dv); lcd_data("-");
069E:  BSF    03.5
069F:  MOVF   2E,W
06A0:  MOVWF  37
06A1:  BCF    03.5
06A2:  CALL   332
06A3:  BSF    03.5
06A4:  MOVF   2F,W
06A5:  MOVWF  37
06A6:  BCF    03.5
06A7:  CALL   332
06A8:  MOVLW  C0
06A9:  BSF    03.6
06AA:  MOVWF  0D
06AB:  MOVLW  00
06AC:  MOVWF  0F
06AD:  BCF    03.6
06AE:  CALL   34F
....................    lcd_data(b_ch); lcd_data(b_dv); lcd_data("-");
06AF:  BSF    03.5
06B0:  MOVF   30,W
06B1:  MOVWF  37
06B2:  BCF    03.5
06B3:  CALL   332
06B4:  BSF    03.5
06B5:  MOVF   31,W
06B6:  MOVWF  37
06B7:  BCF    03.5
06B8:  CALL   332
06B9:  MOVLW  C1
06BA:  BSF    03.6
06BB:  MOVWF  0D
06BC:  MOVLW  00
06BD:  MOVWF  0F
06BE:  BCF    03.6
06BF:  CALL   34F
....................    lcd_data(c_ch); lcd_data(c_dv);
06C0:  BSF    03.5
06C1:  MOVF   32,W
06C2:  MOVWF  37
06C3:  BCF    03.5
06C4:  CALL   332
06C5:  BSF    03.5
06C6:  MOVF   33,W
06C7:  MOVWF  37
06C8:  BCF    03.5
06C9:  CALL   332
06CA:  RETURN
.................... }
.................... 
.................... void lcd_dis_2num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 ch, dv;
....................    lcd_setCursor(x, y);
06CB:  BSF    03.5
06CC:  MOVF   23,W
06CD:  MOVWF  34
06CE:  MOVF   24,W
06CF:  MOVWF  35
06D0:  BCF    03.5
06D1:  CALL   313
....................    ch = dt/10 + 0x30;
06D2:  BSF    03.5
06D3:  MOVF   22,W
06D4:  MOVWF  2D
06D5:  MOVF   21,W
06D6:  MOVWF  2C
06D7:  CLRF   2F
06D8:  MOVLW  0A
06D9:  MOVWF  2E
06DA:  BCF    03.5
06DB:  CALL   50B
06DC:  MOVF   79,W
06DD:  BSF    03.5
06DE:  MOVWF  2A
06DF:  MOVF   78,W
06E0:  MOVWF  29
06E1:  MOVLW  30
06E2:  ADDWF  29,W
06E3:  MOVWF  27
....................    dv = dt%10 + 0x30;
06E4:  MOVF   22,W
06E5:  MOVWF  2D
06E6:  MOVF   21,W
06E7:  MOVWF  2C
06E8:  CLRF   2F
06E9:  MOVLW  0A
06EA:  MOVWF  2E
06EB:  BCF    03.5
06EC:  CALL   50B
06ED:  MOVF   77,W
06EE:  BSF    03.5
06EF:  MOVWF  29
06F0:  MOVF   7A,W
06F1:  MOVWF  2A
06F2:  MOVLW  30
06F3:  ADDWF  29,W
06F4:  MOVWF  28
....................    if(is_xvn == true) if(ch == 0x30) ch = 0x20;
06F5:  DECFSZ 25,W
06F6:  GOTO   6FD
06F7:  MOVF   27,W
06F8:  SUBLW  30
06F9:  BTFSS  03.2
06FA:  GOTO   6FD
06FB:  MOVLW  20
06FC:  MOVWF  27
....................    if(is_dot == true) lcd_data(".");
06FD:  DECFSZ 26,W
06FE:  GOTO   708
06FF:  MOVLW  C2
0700:  BCF    03.5
0701:  BSF    03.6
0702:  MOVWF  0D
0703:  MOVLW  00
0704:  MOVWF  0F
0705:  BCF    03.6
0706:  CALL   34F
0707:  BSF    03.5
....................    lcd_data(ch); lcd_data(dv);
0708:  MOVF   27,W
0709:  MOVWF  37
070A:  BCF    03.5
070B:  CALL   332
070C:  BSF    03.5
070D:  MOVF   28,W
070E:  MOVWF  37
070F:  BCF    03.5
0710:  CALL   332
0711:  RETURN
.................... }
.................... 
.................... void lcd_dis_3num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 tr, ch, dv;
....................    lcd_setCursor(x, y); //xxx /10 -> xx 
*
0740:  MOVF   23,W
0741:  MOVWF  34
0742:  MOVF   24,W
0743:  MOVWF  35
0744:  BCF    03.5
0745:  CALL   313
....................    tr = dt/100 + 0x30; 
0746:  BSF    03.5
0747:  MOVF   22,W
0748:  MOVWF  2D
0749:  MOVF   21,W
074A:  MOVWF  2C
074B:  CLRF   2F
074C:  MOVLW  64
074D:  MOVWF  2E
074E:  BCF    03.5
074F:  CALL   50B
0750:  MOVF   79,W
0751:  BSF    03.5
0752:  MOVWF  2B
0753:  MOVF   78,W
0754:  MOVWF  2A
0755:  MOVLW  30
0756:  ADDWF  2A,W
0757:  MOVWF  27
....................    ch = dt/10%10  + 0x30;
0758:  MOVF   22,W
0759:  MOVWF  2D
075A:  MOVF   21,W
075B:  MOVWF  2C
075C:  CLRF   2F
075D:  MOVLW  0A
075E:  MOVWF  2E
075F:  BCF    03.5
0760:  CALL   50B
0761:  MOVF   79,W
0762:  BSF    03.5
0763:  MOVWF  2B
0764:  MOVF   78,W
0765:  MOVWF  2A
0766:  MOVF   2B,W
0767:  MOVWF  2D
0768:  MOVF   2A,W
0769:  MOVWF  2C
076A:  CLRF   2F
076B:  MOVLW  0A
076C:  MOVWF  2E
076D:  BCF    03.5
076E:  CALL   50B
076F:  MOVF   77,W
0770:  BSF    03.5
0771:  MOVWF  2A
0772:  MOVF   7A,W
0773:  MOVWF  2B
0774:  MOVLW  30
0775:  ADDWF  2A,W
0776:  MOVWF  28
....................    dv = dt%10     + 0x30;
0777:  MOVF   22,W
0778:  MOVWF  2D
0779:  MOVF   21,W
077A:  MOVWF  2C
077B:  CLRF   2F
077C:  MOVLW  0A
077D:  MOVWF  2E
077E:  BCF    03.5
077F:  CALL   50B
0780:  MOVF   77,W
0781:  BSF    03.5
0782:  MOVWF  2A
0783:  MOVF   7A,W
0784:  MOVWF  2B
0785:  MOVLW  30
0786:  ADDWF  2A,W
0787:  MOVWF  29
....................    if(is_xvn == true) if(tr == 0x30){
0788:  DECFSZ 25,W
0789:  GOTO   796
078A:  MOVF   27,W
078B:  SUBLW  30
078C:  BTFSS  03.2
078D:  GOTO   796
....................       tr = 0x20;
078E:  MOVLW  20
078F:  MOVWF  27
....................       if(ch == 0x30) ch = 0x20;
0790:  MOVF   28,W
0791:  SUBLW  30
0792:  BTFSS  03.2
0793:  GOTO   796
0794:  MOVLW  20
0795:  MOVWF  28
....................    }
....................    if(is_dot == true) lcd_data(".");
0796:  DECFSZ 26,W
0797:  GOTO   7A1
0798:  MOVLW  C3
0799:  BCF    03.5
079A:  BSF    03.6
079B:  MOVWF  0D
079C:  MOVLW  00
079D:  MOVWF  0F
079E:  BCF    03.6
079F:  CALL   34F
07A0:  BSF    03.5
....................    lcd_data(tr); lcd_data(ch); lcd_data(dv);
07A1:  MOVF   27,W
07A2:  MOVWF  37
07A3:  BCF    03.5
07A4:  CALL   332
07A5:  BSF    03.5
07A6:  MOVF   28,W
07A7:  MOVWF  37
07A8:  BCF    03.5
07A9:  CALL   332
07AA:  BSF    03.5
07AB:  MOVF   29,W
07AC:  MOVWF  37
07AD:  BCF    03.5
07AE:  CALL   332
.................... }
.................... 
.................... void lcd_dis_temperature (int8 x, int8 y, usi16 ng, usi16 th){
....................    lcd_setCursor(x,y);
*
0712:  MOVF   74,W
0713:  BSF    03.5
0714:  MOVWF  34
0715:  MOVF   75,W
0716:  MOVWF  35
0717:  BCF    03.5
0718:  CALL   313
....................    lcd_data("ND: ");
0719:  MOVLW  C4
071A:  BSF    03.6
071B:  MOVWF  0D
071C:  MOVLW  00
071D:  MOVWF  0F
071E:  BCF    03.6
071F:  CALL   34F
....................    lcd_dis_2num_dot(ng, x + 4, y, true, false);
0720:  MOVLW  04
0721:  ADDWF  74,W
0722:  MOVWF  76
0723:  MOVF   7C,W
0724:  BSF    03.5
0725:  MOVWF  22
0726:  MOVF   7B,W
0727:  MOVWF  21
0728:  MOVF   76,W
0729:  MOVWF  23
072A:  MOVF   75,W
072B:  MOVWF  24
072C:  MOVLW  01
072D:  MOVWF  25
072E:  CLRF   26
072F:  BCF    03.5
0730:  CALL   6CB
....................    lcd_dis_3num_dot(th, x + 6, y, false, true);
0731:  MOVLW  06
0732:  ADDWF  74,W
0733:  MOVWF  76
0734:  MOVF   7E,W
0735:  BSF    03.5
0736:  MOVWF  22
0737:  MOVF   7D,W
0738:  MOVWF  21
0739:  MOVF   76,W
073A:  MOVWF  23
073B:  MOVF   75,W
073C:  MOVWF  24
073D:  CLRF   25
073E:  MOVLW  01
073F:  MOVWF  26
....................    lcd_data(" oC");
*
07AF:  MOVLW  C7
07B0:  BSF    03.6
07B1:  MOVWF  0D
07B2:  MOVLW  00
07B3:  MOVWF  0F
07B4:  BCF    03.6
07B5:  CALL   34F
07B6:  RETURN
.................... }
.................... 
.................... void lcd_dis_temperature_limit (int8 x, int8 y, usi16 ng){
....................    lcd_setCursor(x,y);
*
1279:  MOVF   74,W
127A:  BSF    03.5
127B:  MOVWF  34
127C:  MOVF   75,W
127D:  MOVWF  35
127E:  BCF    0A.4
127F:  BCF    03.5
1280:  CALL   313
1281:  BSF    0A.4
....................    lcd_data("ND-GH: ");
1282:  MOVLW  C9
1283:  BSF    03.6
1284:  MOVWF  0D
1285:  MOVLW  00
1286:  MOVWF  0F
1287:  BCF    0A.4
1288:  BCF    03.6
1289:  CALL   34F
128A:  BSF    0A.4
....................    lcd_dis_2num_dot(ng, x + 7, y, true, false);
128B:  MOVLW  07
128C:  ADDWF  74,W
128D:  MOVWF  76
128E:  MOVF   7C,W
128F:  BSF    03.5
1290:  MOVWF  22
1291:  MOVF   7B,W
1292:  MOVWF  21
1293:  MOVF   76,W
1294:  MOVWF  23
1295:  MOVF   75,W
1296:  MOVWF  24
1297:  MOVLW  01
1298:  MOVWF  25
1299:  CLRF   26
129A:  BCF    0A.4
129B:  BCF    03.5
129C:  CALL   6CB
129D:  BSF    0A.4
....................    lcd_data(" oC");
129E:  MOVLW  CD
129F:  BSF    03.6
12A0:  MOVWF  0D
12A1:  MOVLW  00
12A2:  MOVWF  0F
12A3:  BCF    0A.4
12A4:  BCF    03.6
12A5:  CALL   34F
12A6:  BSF    0A.4
.................... }
.................... 
.................... #include <library_ds1307_i2c.c>
.................... #define ds13_addr_wr 0xd0
.................... #define ds13_addr_rd 0xd1
.................... 
.................... //cap nhat time: giay-phut-gio-thu-ngay-thang-nam-madk_msds
.................... usi8 time_w[9]={0x31,0x15,0x15,0x04,0x25,0x10,0x23,0x90,0x91};
*
103A:  MOVLW  31
103B:  MOVWF  62
103C:  MOVLW  15
103D:  MOVWF  63
103E:  MOVWF  64
103F:  MOVLW  04
1040:  MOVWF  65
1041:  MOVLW  25
1042:  MOVWF  66
1043:  MOVLW  10
1044:  MOVWF  67
1045:  MOVLW  23
1046:  MOVWF  68
1047:  MOVLW  90
1048:  MOVWF  69
1049:  MOVLW  91
104A:  MOVWF  6A
.................... usi8 time_r[9]={0x30,0x30,0x10,0x08,0x20,0x02,0x20,0x90,0x91};
104B:  MOVLW  30
104C:  MOVWF  6B
104D:  MOVWF  6C
104E:  MOVLW  10
104F:  MOVWF  6D
1050:  MOVLW  08
1051:  MOVWF  6E
1052:  MOVLW  20
1053:  MOVWF  6F
1054:  MOVLW  02
1055:  MOVWF  70
1056:  MOVLW  20
1057:  MOVWF  71
1058:  MOVLW  90
1059:  MOVWF  72
105A:  MOVLW  91
105B:  MOVWF  73
.................... 
.................... #define dec_giay_eat  ds1307_bcdToDec(eat_ss)
.................... #define dec_phut_eat  ds1307_bcdToDec(eat_pp)
.................... #define dec_gio_eat   ds1307_bcdToDec(eat_hh)
.................... 
.................... #define dec_giay_ds  ds1307_bcdToDec(time_r[0])
.................... #define dec_phut_ds  ds1307_bcdToDec(time_r[1])
.................... #define dec_gio_ds   ds1307_bcdToDec(time_r[2])
.................... #define dec_thu_ds   ds1307_bcdToDec(time_r[3])
.................... #define dec_ngay_ds  ds1307_bcdToDec(time_r[4])
.................... #define dec_thang_ds ds1307_bcdToDec(time_r[5])
.................... #define dec_nam_ds   ds1307_bcdToDec(time_r[6])
.................... 
.................... #define giay_ds  time_r[0]
.................... #define phut_ds  time_r[1]
.................... #define gio_ds   time_r[2]
.................... #define thu_ds   time_r[3]
.................... #define ngay_ds  time_r[4]
.................... #define thang_ds time_r[5]
.................... #define nam_ds   time_r[6]
.................... 
.................... #define ma_qd   time_w[8]
.................... #define ma_ds   time_r[8]
.................... 
.................... usi8 ds1307_decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
.................... }
.................... 
.................... usi8 ds1307_bcdToDec(usi8 val) {
....................     return ((val / 16 * 10) + (val % 16));
*
060B:  BSF    03.5
060C:  SWAPF  22,W
060D:  MOVWF  77
060E:  MOVLW  0F
060F:  ANDWF  77,F
0610:  MOVF   77,W
0611:  MOVWF  24
0612:  MOVWF  25
0613:  MOVLW  0A
0614:  MOVWF  26
0615:  BCF    03.5
0616:  CALL   5E4
0617:  MOVF   78,W
0618:  BSF    03.5
0619:  MOVWF  23
061A:  MOVF   22,W
061B:  ANDLW  0F
061C:  ADDWF  23,W
061D:  MOVWF  78
061E:  BCF    03.5
061F:  RETURN
.................... }
.................... 
.................... void ds1307_read_time(usi8 j)     
.................... {   
....................    usi8 i; 
....................    i2c_start();
*
0167:  BSF    03.5
0168:  BSF    11.0
0169:  BTFSC  11.0
016A:  GOTO   169
....................    i2c_write(ds13_addr_wr);
016B:  MOVLW  D0
016C:  MOVWF  47
016D:  BCF    03.5
016E:  CALL   145
....................    i2c_write(0x00);                     
016F:  BSF    03.5
0170:  CLRF   47
0171:  BCF    03.5
0172:  CALL   145
....................    i2c_start();               
0173:  BSF    03.5
0174:  BSF    11.1
0175:  BTFSC  11.1
0176:  GOTO   175
....................    i2c_write(ds13_addr_rd);                              
0177:  MOVLW  D1
0178:  MOVWF  47
0179:  BCF    03.5
017A:  CALL   145
....................    for(i=0;i<j;i++) time_r[i]=i2c_read();
017B:  CLRF   75
017C:  MOVF   74,W
017D:  SUBWF  75,W
017E:  BTFSC  03.0
017F:  GOTO   18B
0180:  MOVLW  6B
0181:  ADDWF  75,W
0182:  MOVWF  04
0183:  BCF    03.7
0184:  MOVLW  01
0185:  MOVWF  77
0186:  CALL   157
0187:  MOVF   78,W
0188:  MOVWF  00
0189:  INCF   75,F
018A:  GOTO   17C
....................                                  
....................    i = i2c_read(0); //not ack, don't care i  
018B:  CLRF   77
018C:  CALL   157
018D:  MOVF   78,W
018E:  MOVWF  75
....................    i2c_stop();
018F:  BSF    03.5
0190:  BSF    11.2
0191:  BTFSC  11.2
0192:  GOTO   191
0193:  BCF    03.5
0194:  RETURN
.................... }
.................... 
.................... void ds1307_update_time(int1 sel)                 
.................... {         
....................    usi8 i;
....................    i2c_start();
*
019E:  BSF    03.5
019F:  BSF    11.0
01A0:  BTFSC  11.0
01A1:  GOTO   1A0
....................    i2c_write(ds13_addr_wr);
01A2:  MOVLW  D0
01A3:  MOVWF  47
01A4:  BCF    03.5
01A5:  CALL   145
....................    i2c_write(0x00);
01A6:  BSF    03.5
01A7:  CLRF   47
01A8:  BCF    03.5
01A9:  CALL   145
....................    for(i=0;i<9;i++)                          
01AA:  CLRF   75
01AB:  MOVF   75,W
01AC:  SUBLW  08
01AD:  BTFSS  03.0
01AE:  GOTO   1C9
....................    {  
....................       if(sel)  i2c_write(time_w[i]);
01AF:  MOVF   74,F
01B0:  BTFSC  03.2
01B1:  GOTO   1BD
01B2:  MOVLW  62
01B3:  ADDWF  75,W
01B4:  MOVWF  04
01B5:  BCF    03.7
01B6:  MOVF   00,W
01B7:  MOVWF  76
01B8:  BSF    03.5
01B9:  MOVWF  47
01BA:  BCF    03.5
01BB:  CALL   145
01BC:  GOTO   1C7
....................       else     i2c_write(time_r[i]);
01BD:  MOVLW  6B
01BE:  ADDWF  75,W
01BF:  MOVWF  04
01C0:  BCF    03.7
01C1:  MOVF   00,W
01C2:  MOVWF  76
01C3:  BSF    03.5
01C4:  MOVWF  47
01C5:  BCF    03.5
01C6:  CALL   145
01C7:  INCF   75,F
01C8:  GOTO   1AB
....................    }                                 
....................    i2c_stop();        
01C9:  BSF    03.5
01CA:  BSF    11.2
01CB:  BTFSC  11.2
01CC:  GOTO   1CB
01CD:  BCF    03.5
.................... }  
.................... 
.................... void ds1307_setup()
.................... {                                              
....................    ds1307_read_time(9);          
*
0195:  MOVLW  09
0196:  MOVWF  74
0197:  CALL   167
....................    if(ma_qd!=ma_ds)
0198:  MOVF   73,W
0199:  SUBWF  6A,W
019A:  BTFSC  03.2
019B:  GOTO   1CE
....................    {
....................       ds1307_update_time(1);
019C:  MOVLW  01
019D:  MOVWF  74
....................    }
*
01CE:  BCF    0A.3
01CF:  BSF    0A.4
01D0:  GOTO   061 (RETURN)
.................... }
.................... 
.................... void ds1307_save_ds(usi8 dcdt,dt)                 
.................... {           
....................    i2c_start();
*
093A:  BSF    03.5
093B:  BSF    11.0
093C:  BTFSC  11.0
093D:  GOTO   13C
....................    i2c_write(ds13_addr_wr);        
093E:  MOVLW  D0
093F:  MOVWF  47
0940:  BCF    0A.3
0941:  BCF    03.5
0942:  CALL   145
0943:  BSF    0A.3
....................    i2c_write(dcdt);    
0944:  MOVF   74,W
0945:  BSF    03.5
0946:  MOVWF  47
0947:  BCF    0A.3
0948:  BCF    03.5
0949:  CALL   145
094A:  BSF    0A.3
....................    i2c_write(dt);
094B:  MOVF   75,W
094C:  BSF    03.5
094D:  MOVWF  47
094E:  BCF    0A.3
094F:  BCF    03.5
0950:  CALL   145
0951:  BSF    0A.3
....................    i2c_stop();
0952:  BSF    03.5
0953:  BSF    11.2
0954:  BTFSC  11.2
0955:  GOTO   154
0956:  BCF    03.5
0957:  RETURN
.................... }
.................... 
.................... #include <library_ds18b20.c>
.................... #include <touch.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                        Dallas Touch Driver                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    ////
.................... ////                                                                   ////
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  present = touch_present()   Issues a reset and returns true      ////
.................... ////                              if the touch device is there.        ////
.................... ////                                                                   ////
.................... ////  reset_pulse()               Issues a reset and waits for a       ////
.................... ////                              present pulse.                       ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef  TOUCH_C
.................... #define  TOUCH_C
.................... 
.................... #ifndef TOUCH_PIN
....................    #define TOUCH_PIN  PIN_B0
.................... #endif
.................... 
.................... #define TOUCH_PIN_LOW()    output_drive(TOUCH_PIN); output_low(TOUCH_PIN)
.................... #define TOUCH_PIN_HIGH()    output_drive(TOUCH_PIN); output_high(TOUCH_PIN)
.................... #define TOUCH_PIN_FLOAT()  output_float(TOUCH_PIN)
.................... #define TOUCH_PIN_READ()      input_state(TOUCH_PIN)
.................... 
.................... /////////////////////////////
.................... ////                     ////
.................... //// Function Prototypes ////
.................... ////                     ////
.................... /////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit();
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte();
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data);
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data);
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present();
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse();
.................... 
.................... //////////////////////////////////
.................... ////                          ////
.................... //// Function Implementations ////
.................... ////                          ////
.................... //////////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit()
.................... {
....................    int1 data;
.................... 
....................    TOUCH_PIN_LOW();
....................    delay_us(14);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    data = TOUCH_PIN_READ();
....................    delay_us(100);
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte()
.................... {
....................    BYTE i,data;
.................... 
....................    for(i=1; i <= 8; ++i)
....................       shift_right(&data, 1, touch_read_bit());
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data)
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(10);
....................    if(data)
....................    {
....................       TOUCH_PIN_HIGH();
....................       delay_us(10);
....................       if(!TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    else
....................    {
....................       TOUCH_PIN_LOW();
....................       delay_us(10);
....................       if(TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    delay_us(50);
....................    TOUCH_PIN_HIGH();
....................    delay_us(50);
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data)
.................... {
....................    BYTE i;
.................... 
....................    for(i=1; i<=8; ++i)
....................       if(!touch_write_bit(shift_right(&data, 1, 0)))
....................          return FALSE;
.................... 
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present()
.................... {
....................    BOOLEAN present;
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
.................... 
....................    if(!TOUCH_PIN_READ())
....................       return FALSE;
.................... 
....................    delay_us(65);
....................    present = !TOUCH_PIN_READ();
....................    delay_us(240);
....................    return present;
.................... }
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse()
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    while(!touch_present());
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define search_rom       0xf0
.................... #define read_rom         0x33
.................... #define match_rom        0x55
.................... #define skip_rom         0xcc
.................... #define alarm_search     0xec
.................... #define read_scratchpad  0xbe
.................... #define write_scratchpad 0x4e
.................... #define copy_scratchpad  0x48
.................... #define convert_t        0x44
.................... 
.................... bool ds18b20_start(){
....................    output_low(pin_ds18b20);
*
0474:  BSF    03.5
0475:  BCF    05.0
0476:  BCF    03.5
0477:  BCF    05.0
....................    output_drive(pin_ds18b20);
0478:  BSF    03.5
0479:  BCF    05.0
....................    delay_us(500);
047A:  MOVLW  02
047B:  MOVWF  20
047C:  MOVLW  F9
047D:  MOVWF  21
047E:  BCF    03.5
047F:  CALL   2DC
0480:  BSF    03.5
0481:  DECFSZ 20,F
0482:  GOTO   47C
....................    output_float(pin_ds18b20);
0483:  BSF    05.0
....................    delay_us(100);
0484:  MOVLW  A6
0485:  MOVWF  77
0486:  DECFSZ 77,F
0487:  GOTO   486
0488:  NOP
....................    if(!input(pin_ds18b20)){
0489:  BSF    05.0
048A:  BCF    03.5
048B:  BTFSC  05.0
048C:  GOTO   49B
....................       delay_us(400);
048D:  MOVLW  02
048E:  BSF    03.5
048F:  MOVWF  20
0490:  MOVLW  C7
0491:  MOVWF  21
0492:  BCF    03.5
0493:  CALL   2DC
0494:  BSF    03.5
0495:  DECFSZ 20,F
0496:  GOTO   490
....................       return true;
0497:  MOVLW  01
0498:  MOVWF  78
0499:  GOTO   49E
049A:  BCF    03.5
....................    }
....................    return false;
049B:  MOVLW  00
049C:  MOVWF  78
049D:  BSF    03.5
049E:  BCF    03.5
049F:  RETURN
.................... }
.................... 
.................... void ds18b20_write_bit(bool value){
....................    output_low(pin_ds18b20);
*
04B6:  BCF    05.0
04B7:  BCF    03.5
04B8:  BCF    05.0
....................    output_drive(pin_ds18b20);
04B9:  BSF    03.5
04BA:  BCF    05.0
....................    delay_us(2);
04BB:  MOVLW  03
04BC:  MOVWF  77
04BD:  DECFSZ 77,F
04BE:  GOTO   4BD
....................    output_bit(pin_ds18b20, value);
04BF:  MOVF   23,F
04C0:  BTFSS  03.2
04C1:  GOTO   4C6
04C2:  BCF    03.5
04C3:  BCF    05.0
04C4:  GOTO   4C8
04C5:  BSF    03.5
04C6:  BCF    03.5
04C7:  BSF    05.0
04C8:  BSF    03.5
04C9:  BCF    05.0
....................    delay_us(80);
04CA:  MOVLW  85
04CB:  MOVWF  77
04CC:  DECFSZ 77,F
04CD:  GOTO   4CC
....................    output_float(pin_ds18b20);
04CE:  BSF    05.0
....................    delay_us(2);
04CF:  MOVLW  03
04D0:  MOVWF  77
04D1:  DECFSZ 77,F
04D2:  GOTO   4D1
.................... }
.................... 
.................... void ds18b20_write_byte(int8 value){
....................    for(int8 i = 0; i < 8; i++)
*
04A0:  BSF    03.5
04A1:  CLRF   21
04A2:  MOVF   21,W
04A3:  SUBLW  07
04A4:  BTFSS  03.0
04A5:  GOTO   4D5
....................       ds18b20_write_bit(bit_test(value,i));
04A6:  MOVF   20,W
04A7:  MOVWF  77
04A8:  MOVF   21,W
04A9:  MOVWF  78
04AA:  BTFSC  03.2
04AB:  GOTO   4B0
04AC:  BCF    03.0
04AD:  RRF    77,F
04AE:  DECFSZ 78,F
04AF:  GOTO   4AC
04B0:  MOVLW  00
04B1:  BTFSC  77.0
04B2:  MOVLW  01
04B3:  MOVWF  22
04B4:  MOVF   22,W
04B5:  MOVWF  23
*
04D3:  INCF   21,F
04D4:  GOTO   4A2
04D5:  BCF    03.5
04D6:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_bit(){
....................    bool value;
....................    output_low(pin_ds18b20);
*
04DE:  BCF    05.0
04DF:  BCF    03.5
04E0:  BCF    05.0
....................    output_drive(pin_ds18b20);
04E1:  BSF    03.5
04E2:  BCF    05.0
....................    delay_us(2);
04E3:  MOVLW  03
04E4:  MOVWF  77
04E5:  DECFSZ 77,F
04E6:  GOTO   4E5
....................    output_float(pin_ds18b20);
04E7:  BSF    05.0
....................    delay_us(5);
04E8:  MOVLW  08
04E9:  MOVWF  77
04EA:  DECFSZ 77,F
04EB:  GOTO   4EA
....................    value = input(pin_ds18b20);
04EC:  BSF    05.0
04ED:  BCF    26.0
04EE:  BCF    03.5
04EF:  BTFSS  05.0
04F0:  GOTO   4F4
04F1:  BSF    03.5
04F2:  BSF    26.0
04F3:  BCF    03.5
....................    delay_us(100);
04F4:  MOVLW  A6
04F5:  MOVWF  77
04F6:  DECFSZ 77,F
04F7:  GOTO   4F6
04F8:  NOP
....................    return value;
04F9:  MOVLW  00
04FA:  BSF    03.5
04FB:  BTFSC  26.0
04FC:  MOVLW  01
04FD:  MOVWF  78
.................... }
.................... 
.................... int8 ds18b20_read_byte(){
*
04D7:  BSF    03.5
04D8:  CLRF   24
....................    int8 value = 0;
....................    for(int8 i = 0; i < 8; i++)
04D9:  CLRF   25
04DA:  MOVF   25,W
04DB:  SUBLW  07
04DC:  BTFSS  03.0
04DD:  GOTO   507
....................       shift_right(&value,1,ds18b20_read_bit());
*
04FE:  MOVF   78,F
04FF:  BTFSS  03.2
0500:  GOTO   503
0501:  BCF    03.0
0502:  GOTO   504
0503:  BSF    03.0
0504:  RRF    24,F
0505:  INCF   25,F
0506:  GOTO   4DA
....................    return value;
0507:  MOVF   24,W
0508:  MOVWF  78
0509:  BCF    03.5
050A:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_temp_c2(usi16 *raw_temp_value){
....................    if(!ds18b20_start())
*
0535:  CALL   474
0536:  MOVF   78,F
0537:  BTFSS  03.2
0538:  GOTO   53C
....................       return false;
0539:  MOVLW  00
053A:  MOVWF  78
053B:  GOTO   59F
....................    ds18b20_write_byte(skip_rom);
053C:  MOVLW  CC
053D:  BSF    03.5
053E:  MOVWF  20
053F:  BCF    03.5
0540:  CALL   4A0
....................    ds18b20_write_byte(convert_t);
0541:  MOVLW  44
0542:  BSF    03.5
0543:  MOVWF  20
0544:  BCF    03.5
0545:  CALL   4A0
....................    while(ds18b20_read_byte() == 0);
0546:  CALL   4D7
0547:  MOVF   78,F
0548:  BTFSC  03.2
0549:  GOTO   546
....................    if(!ds18b20_start())
054A:  CALL   474
054B:  MOVF   78,F
054C:  BTFSS  03.2
054D:  GOTO   551
....................       return false;
054E:  MOVLW  00
054F:  MOVWF  78
0550:  GOTO   59F
....................    ds18b20_write_byte(skip_rom);
0551:  MOVLW  CC
0552:  BSF    03.5
0553:  MOVWF  20
0554:  BCF    03.5
0555:  CALL   4A0
....................    ds18b20_write_byte(read_scratchpad);
0556:  MOVLW  BE
0557:  BSF    03.5
0558:  MOVWF  20
0559:  BCF    03.5
055A:  CALL   4A0
....................    *raw_temp_value = ds18b20_read_byte();
055B:  MOVF   75,W
055C:  MOVWF  7A
055D:  MOVF   74,W
055E:  BSF    03.5
055F:  MOVWF  20
0560:  MOVF   75,W
0561:  MOVWF  21
0562:  BCF    03.5
0563:  CALL   4D7
0564:  BSF    03.5
0565:  MOVF   20,W
0566:  MOVWF  04
0567:  BCF    03.7
0568:  BTFSC  21.0
0569:  BSF    03.7
056A:  INCF   04,F
056B:  CLRF   00
056C:  DECF   04,F
056D:  MOVF   78,W
056E:  MOVWF  00
....................    *raw_temp_value |= (int16)(ds18b20_read_byte()) << 8;
056F:  MOVF   75,W
0570:  MOVWF  7A
0571:  MOVF   74,W
0572:  MOVWF  20
0573:  MOVF   75,W
0574:  MOVWF  21
0575:  MOVF   20,W
0576:  MOVWF  04
0577:  BCF    03.7
0578:  BTFSC  21.0
0579:  BSF    03.7
057A:  INCF   04,F
057B:  MOVF   00,W
057C:  MOVWF  23
057D:  DECF   04,F
057E:  MOVF   00,W
057F:  MOVWF  22
0580:  BCF    03.5
0581:  CALL   4D7
0582:  BSF    03.5
0583:  CLRF   25
0584:  MOVF   78,W
0585:  MOVWF  24
0586:  MOVWF  7A
0587:  MOVLW  00
0588:  IORWF  22,W
0589:  MOVWF  77
058A:  MOVF   7A,W
058B:  IORWF  23,W
058C:  MOVWF  7A
058D:  MOVF   77,W
058E:  MOVWF  22
058F:  MOVF   7A,W
0590:  MOVWF  23
0591:  MOVF   20,W
0592:  MOVWF  04
0593:  BCF    03.7
0594:  BTFSC  21.0
0595:  BSF    03.7
0596:  INCF   04,F
0597:  MOVF   23,W
0598:  MOVWF  00
0599:  DECF   04,F
059A:  MOVF   22,W
059B:  MOVWF  00
....................    return true;
059C:  MOVLW  01
059D:  MOVWF  78
059E:  BCF    03.5
.................... }
.................... 
.................... void ds18b20_read_temp(){
....................    if(ds18b20_read_temp_c2(&temperature)){
*
0532:  CLRF   75
0533:  MOVLW  3B
0534:  MOVWF  74
*
059F:  MOVF   78,F
05A0:  BTFSC  03.2
05A1:  GOTO   5E2
....................       isDs18b20 = true;
05A2:  BSF    2C.1
....................       dt_ng = temperature>>4;
05A3:  RRF    3C,W
05A4:  MOVWF  7A
05A5:  RRF    3B,W
05A6:  MOVWF  79
05A7:  RRF    7A,F
05A8:  RRF    79,F
05A9:  RRF    7A,F
05AA:  RRF    79,F
05AB:  RRF    7A,F
05AC:  RRF    79,F
05AD:  MOVF   79,W
05AE:  MOVWF  3D
....................       tt = temperature & 0x000f;
05AF:  MOVF   3B,W
05B0:  ANDLW  0F
05B1:  MOVWF  40
05B2:  CLRF   41
....................       dt_tp = (tt*625)/10;
05B3:  MOVF   41,W
05B4:  MOVWF  75
05B5:  MOVF   40,W
05B6:  MOVWF  74
05B7:  MOVLW  02
05B8:  MOVWF  7C
05B9:  MOVLW  71
05BA:  MOVWF  7B
*
05CF:  MOVF   79,W
05D0:  MOVWF  75
05D1:  MOVF   78,W
05D2:  MOVWF  74
05D3:  MOVF   79,W
05D4:  BSF    03.5
05D5:  MOVWF  2D
05D6:  MOVF   78,W
05D7:  MOVWF  2C
05D8:  CLRF   2F
05D9:  MOVLW  0A
05DA:  MOVWF  2E
05DB:  BCF    03.5
05DC:  CALL   50B
05DD:  MOVF   79,W
05DE:  MOVWF  3F
05DF:  MOVF   78,W
05E0:  MOVWF  3E
....................    }
05E1:  GOTO   5E3
....................    else isDs18b20 = false;
05E2:  BCF    2C.1
05E3:  RETURN
.................... }
.................... 
.................... #include <library_change_rtc.c>
.................... 
.................... usi8 tang_or_giam_bcd(unsigned int8 x, int1 sel){
....................    usi8 y, dv, ch, v;
....................    ch = (x>>4);
*
0901:  SWAPF  74,W
0902:  MOVWF  7C
0903:  MOVLW  0F
0904:  ANDWF  7C,F
....................    dv = x& 0x0f;
0905:  MOVF   74,W
0906:  ANDLW  0F
0907:  MOVWF  7B
....................    y = ch*10 + dv;
0908:  MOVF   7C,W
0909:  BSF    03.5
090A:  MOVWF  25
090B:  MOVLW  0A
090C:  MOVWF  26
090D:  BCF    0A.3
090E:  BCF    03.5
090F:  CALL   5E4
0910:  BSF    0A.3
0911:  MOVF   7B,W
0912:  ADDWF  78,W
0913:  MOVWF  76
....................    if(sel == 0) y++;
0914:  MOVF   75,F
0915:  BTFSS  03.2
0916:  GOTO   119
0917:  INCF   76,F
0918:  GOTO   11A
....................    else         y--;
0919:  DECF   76,F
....................    ch = y/10; dv = y%10;
091A:  MOVF   76,W
091B:  BSF    03.5
091C:  MOVWF  34
091D:  MOVLW  0A
091E:  MOVWF  35
091F:  BCF    0A.3
0920:  BCF    03.5
0921:  CALL   620
0922:  BSF    0A.3
0923:  MOVF   78,W
0924:  MOVWF  7C
0925:  MOVF   76,W
0926:  BSF    03.5
0927:  MOVWF  34
0928:  MOVLW  0A
0929:  MOVWF  35
092A:  BCF    0A.3
092B:  BCF    03.5
092C:  CALL   620
092D:  BSF    0A.3
092E:  MOVF   77,W
092F:  MOVWF  7B
....................    v = (ch<<4)|dv;
0930:  SWAPF  7C,W
0931:  MOVWF  77
0932:  MOVLW  F0
0933:  ANDWF  77,F
0934:  MOVF   77,W
0935:  IORWF  7B,W
0936:  MOVWF  7D
....................    return v;
0937:  MOVF   7D,W
0938:  MOVWF  78
0939:  RETURN
.................... }
.................... 
.................... void tat_bat_2led_chinh(){
....................    if(gt_mod == 1 || gt_mod == 4) { e_11 = ~e_11; e_22 = true; e_33 = true;}
*
0803:  DECFSZ 33,W
0804:  GOTO   006
0805:  GOTO   00A
0806:  MOVF   33,W
0807:  SUBLW  04
0808:  BTFSS  03.2
0809:  GOTO   00F
080A:  MOVLW  04
080B:  XORWF  2C,F
080C:  BSF    2C.3
080D:  BSF    2C.4
080E:  GOTO   02C
....................    else if(gt_mod == 2 || gt_mod == 5) { e_11 = true; e_22 = ~e_22; e_33 = true;}
080F:  MOVF   33,W
0810:  SUBLW  02
0811:  BTFSC  03.2
0812:  GOTO   017
0813:  MOVF   33,W
0814:  SUBLW  05
0815:  BTFSS  03.2
0816:  GOTO   01C
0817:  BSF    2C.2
0818:  MOVLW  08
0819:  XORWF  2C,F
081A:  BSF    2C.4
081B:  GOTO   02C
....................    else if(gt_mod == 3 || gt_mod == 6) { e_11 = true; e_22 = true; e_33 = ~e_33;}
081C:  MOVF   33,W
081D:  SUBLW  03
081E:  BTFSC  03.2
081F:  GOTO   024
0820:  MOVF   33,W
0821:  SUBLW  06
0822:  BTFSS  03.2
0823:  GOTO   029
0824:  BSF    2C.2
0825:  BSF    2C.3
0826:  MOVLW  10
0827:  XORWF  2C,F
0828:  GOTO   02C
....................    else { e_11 = true; e_22 = true; e_33 = true;}
0829:  BSF    2C.2
082A:  BSF    2C.3
082B:  BSF    2C.4
.................... }
.................... 
.................... void giai_ma_gpg_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_ds,dec_phut_ds,dec_giay_ds,e_33, e_22, e_11);
*
0831:  MOVF   6D,W
0832:  BSF    03.5
0833:  MOVWF  22
0834:  BCF    0A.3
0835:  BCF    03.5
0836:  CALL   60B
0837:  BSF    0A.3
0838:  MOVF   78,W
0839:  BSF    03.5
083A:  MOVWF  20
083B:  BCF    03.5
083C:  MOVF   6C,W
083D:  BSF    03.5
083E:  MOVWF  22
083F:  BCF    0A.3
0840:  BCF    03.5
0841:  CALL   60B
0842:  BSF    0A.3
0843:  MOVF   78,W
0844:  BSF    03.5
0845:  MOVWF  21
0846:  BCF    03.5
0847:  MOVF   6B,W
0848:  BSF    03.5
0849:  MOVWF  22
084A:  BCF    0A.3
084B:  BCF    03.5
084C:  CALL   60B
084D:  BSF    0A.3
084E:  MOVF   78,W
084F:  BSF    03.5
0850:  MOVWF  22
0851:  MOVLW  00
0852:  BCF    03.5
0853:  BTFSC  2C.4
0854:  MOVLW  01
0855:  BSF    03.5
0856:  MOVWF  23
0857:  MOVLW  00
0858:  BCF    03.5
0859:  BTFSC  2C.3
085A:  MOVLW  01
085B:  BSF    03.5
085C:  MOVWF  24
085D:  MOVLW  00
085E:  BCF    03.5
085F:  BTFSC  2C.2
0860:  MOVLW  01
0861:  BSF    03.5
0862:  MOVWF  25
0863:  MOVLW  04
0864:  MOVWF  26
0865:  MOVLW  01
0866:  MOVWF  27
0867:  MOVF   20,W
0868:  MOVWF  28
0869:  MOVF   21,W
086A:  MOVWF  29
086B:  MOVF   22,W
086C:  MOVWF  2A
086D:  MOVF   23,W
086E:  MOVWF  2B
086F:  MOVF   24,W
0870:  MOVWF  2C
0871:  MOVF   25,W
0872:  MOVWF  2D
0873:  BCF    0A.3
0874:  BCF    03.5
0875:  CALL   637
0876:  BSF    0A.3
0877:  RETURN
.................... }
.................... 
.................... void giai_ma_ntn_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_ngay_ds,dec_thang_ds,dec_nam_ds,e_33, e_22, e_11);
0878:  MOVF   6F,W
0879:  BSF    03.5
087A:  MOVWF  22
087B:  BCF    0A.3
087C:  BCF    03.5
087D:  CALL   60B
087E:  BSF    0A.3
087F:  MOVF   78,W
0880:  BSF    03.5
0881:  MOVWF  20
0882:  MOVF   70,W
0883:  MOVWF  22
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  CALL   60B
0887:  BSF    0A.3
0888:  MOVF   78,W
0889:  BSF    03.5
088A:  MOVWF  21
088B:  MOVF   71,W
088C:  MOVWF  22
088D:  BCF    0A.3
088E:  BCF    03.5
088F:  CALL   60B
0890:  BSF    0A.3
0891:  MOVF   78,W
0892:  BSF    03.5
0893:  MOVWF  22
0894:  MOVLW  00
0895:  BCF    03.5
0896:  BTFSC  2C.4
0897:  MOVLW  01
0898:  BSF    03.5
0899:  MOVWF  23
089A:  MOVLW  00
089B:  BCF    03.5
089C:  BTFSC  2C.3
089D:  MOVLW  01
089E:  BSF    03.5
089F:  MOVWF  24
08A0:  MOVLW  00
08A1:  BCF    03.5
08A2:  BTFSC  2C.2
08A3:  MOVLW  01
08A4:  BSF    03.5
08A5:  MOVWF  25
08A6:  MOVLW  04
08A7:  MOVWF  26
08A8:  MOVLW  01
08A9:  MOVWF  27
08AA:  MOVF   20,W
08AB:  MOVWF  28
08AC:  MOVF   21,W
08AD:  MOVWF  29
08AE:  MOVF   22,W
08AF:  MOVWF  2A
08B0:  MOVF   23,W
08B1:  MOVWF  2B
08B2:  MOVF   24,W
08B3:  MOVWF  2C
08B4:  MOVF   25,W
08B5:  MOVWF  2D
08B6:  BCF    0A.3
08B7:  BCF    03.5
08B8:  CALL   637
08B9:  BSF    0A.3
08BA:  RETURN
.................... }
.................... 
.................... void giai_ma_thu_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,0x00,dec_thu_ds,0x00,0, e_22, 0);
08BB:  MOVF   6E,W
08BC:  BSF    03.5
08BD:  MOVWF  22
08BE:  BCF    0A.3
08BF:  BCF    03.5
08C0:  CALL   60B
08C1:  BSF    0A.3
08C2:  MOVF   78,W
08C3:  MOVWF  74
08C4:  MOVLW  00
08C5:  BTFSC  2C.3
08C6:  MOVLW  01
08C7:  MOVWF  75
08C8:  MOVLW  04
08C9:  BSF    03.5
08CA:  MOVWF  26
08CB:  MOVLW  01
08CC:  MOVWF  27
08CD:  CLRF   28
08CE:  MOVF   78,W
08CF:  MOVWF  29
08D0:  CLRF   2A
08D1:  CLRF   2B
08D2:  MOVF   75,W
08D3:  MOVWF  2C
08D4:  CLRF   2D
08D5:  BCF    0A.3
08D6:  BCF    03.5
08D7:  CALL   637
08D8:  BSF    0A.3
08D9:  RETURN
.................... }
.................... 
.................... void giai_ma_gpg_ntn_thu_lcd(){
....................    if(gt_mod == 0){
08DA:  MOVF   33,F
08DB:  BTFSS  03.2
08DC:  GOTO   0EC
....................       if(tt_ht == 0 || tt_ht == 1) giai_ma_gpg_lcd();
08DD:  MOVF   32,F
08DE:  BTFSC  03.2
08DF:  GOTO   0E2
08E0:  DECFSZ 32,W
08E1:  GOTO   0E3
08E2:  CALL   031
....................       if(tt_ht == 2) giai_ma_ntn_lcd();
08E3:  MOVF   32,W
08E4:  SUBLW  02
08E5:  BTFSC  03.2
08E6:  CALL   078
....................       if(tt_ht == 3) giai_ma_thu_lcd();
08E7:  MOVF   32,W
08E8:  SUBLW  03
08E9:  BTFSC  03.2
08EA:  CALL   0BB
....................    }
08EB:  GOTO   100
....................    else{
....................       if(gt_mod < 4)       giai_ma_gpg_lcd();
08EC:  BTFSC  33.7
08ED:  GOTO   0F2
08EE:  MOVF   33,W
08EF:  SUBLW  03
08F0:  BTFSS  03.0
08F1:  GOTO   0F4
08F2:  CALL   031
08F3:  GOTO   100
....................       else if(gt_mod < 7)  giai_ma_ntn_lcd();
08F4:  BTFSC  33.7
08F5:  GOTO   0FA
08F6:  MOVF   33,W
08F7:  SUBLW  06
08F8:  BTFSS  03.0
08F9:  GOTO   0FC
08FA:  CALL   078
08FB:  GOTO   100
....................       else if(gt_mod == 7) giai_ma_thu_lcd();
08FC:  MOVF   33,W
08FD:  SUBLW  07
08FE:  BTFSC  03.2
08FF:  CALL   0BB
....................    }
0900:  RETURN
.................... }
.................... 
.................... void xu_ly_choptat(){
....................    if(gt_mod != 0){
*
0800:  MOVF   33,F
0801:  BTFSC  03.2
0802:  GOTO   02D
....................       tat_bat_2led_chinh();
....................    }
*
082C:  GOTO   030
....................    else { e_11 = true; e_22 = true; e_33 = true;}
082D:  BSF    2C.2
082E:  BSF    2C.3
082F:  BSF    2C.4
0830:  RETURN
....................    
.................... }
.................... 
.................... void phim_chon_hthi_mode(){
....................    if(tick_btn(2, bt3)){
*
12D5:  MOVLW  02
12D6:  MOVWF  74
12D7:  MOVLW  33
12D8:  MOVWF  75
12D9:  BCF    0A.4
12DA:  CALL   7D5
12DB:  BSF    0A.4
12DC:  MOVF   78,F
12DD:  BTFSC  03.2
12DE:  GOTO   306
....................       tt_ht = 1;
12DF:  MOVLW  01
12E0:  MOVWF  32
....................       if(tt_ht == 1){
12E1:  DECFSZ 32,W
12E2:  GOTO   300
....................          gt_mod++;
12E3:  INCF   33,F
....................          if(gt_mod < 4) tt_ht = 1;
12E4:  BTFSC  33.7
12E5:  GOTO   2EA
12E6:  MOVF   33,W
12E7:  SUBLW  03
12E8:  BTFSS  03.0
12E9:  GOTO   2ED
12EA:  MOVLW  01
12EB:  MOVWF  32
12EC:  GOTO   300
....................          else if(gt_mod < 7) tt_ht = 2;
12ED:  BTFSC  33.7
12EE:  GOTO   2F3
12EF:  MOVF   33,W
12F0:  SUBLW  06
12F1:  BTFSS  03.0
12F2:  GOTO   2F6
12F3:  MOVLW  02
12F4:  MOVWF  32
12F5:  GOTO   300
....................          else if(gt_mod == 7) tt_ht = 3;
12F6:  MOVF   33,W
12F7:  SUBLW  07
12F8:  BTFSS  03.2
12F9:  GOTO   2FD
12FA:  MOVLW  03
12FB:  MOVWF  32
12FC:  GOTO   300
....................          else{
....................             gt_mod = 0;
12FD:  CLRF   33
....................             tt_ht = 0;
12FE:  CLRF   32
....................             countLevel = 0;
12FF:  CLRF   38
....................          }
....................       }
....................       tg_chinh = 0;
1300:  CLRF   34
....................       giai_ma_gpg_ntn_thu_lcd();
1301:  BCF    0A.4
1302:  BSF    0A.3
1303:  CALL   0DA
1304:  BSF    0A.4
1305:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay(){
....................    if(giay_ds == 0x59) giay_ds = 0;
*
1322:  MOVF   6B,W
1323:  SUBLW  59
1324:  BTFSS  03.2
1325:  GOTO   328
1326:  CLRF   6B
1327:  GOTO   332
....................    else giay_ds = tang_or_giam_bcd(giay_ds, tang);
1328:  MOVF   6B,W
1329:  MOVWF  74
132A:  CLRF   75
132B:  BCF    0A.4
132C:  BSF    0A.3
132D:  CALL   101
132E:  BSF    0A.4
132F:  BCF    0A.3
1330:  MOVF   78,W
1331:  MOVWF  6B
....................    ds1307_save_ds(0,giay_ds);
1332:  CLRF   74
1333:  MOVF   6B,W
1334:  MOVWF  75
1335:  BCF    0A.4
1336:  BSF    0A.3
1337:  CALL   13A
1338:  BSF    0A.4
1339:  BCF    0A.3
.................... }
.................... void tang_phut(){
....................    if(phut_ds == 0x59) phut_ds = 0;
*
133B:  MOVF   6C,W
133C:  SUBLW  59
133D:  BTFSS  03.2
133E:  GOTO   341
133F:  CLRF   6C
1340:  GOTO   34B
....................    else phut_ds = tang_or_giam_bcd(phut_ds, tang);
1341:  MOVF   6C,W
1342:  MOVWF  74
1343:  CLRF   75
1344:  BCF    0A.4
1345:  BSF    0A.3
1346:  CALL   101
1347:  BSF    0A.4
1348:  BCF    0A.3
1349:  MOVF   78,W
134A:  MOVWF  6C
....................    ds1307_save_ds(1,phut_ds);
134B:  MOVLW  01
134C:  MOVWF  74
134D:  MOVF   6C,W
134E:  MOVWF  75
134F:  BCF    0A.4
1350:  BSF    0A.3
1351:  CALL   13A
1352:  BSF    0A.4
1353:  BCF    0A.3
.................... }
.................... void tang_gio(){
....................    if(gio_ds == 0x23) gio_ds = 0;
*
1355:  MOVF   6D,W
1356:  SUBLW  23
1357:  BTFSS  03.2
1358:  GOTO   35B
1359:  CLRF   6D
135A:  GOTO   365
....................    else gio_ds = tang_or_giam_bcd(gio_ds, tang);
135B:  MOVF   6D,W
135C:  MOVWF  74
135D:  CLRF   75
135E:  BCF    0A.4
135F:  BSF    0A.3
1360:  CALL   101
1361:  BSF    0A.4
1362:  BCF    0A.3
1363:  MOVF   78,W
1364:  MOVWF  6D
....................    ds1307_save_ds(2,gio_ds);
1365:  MOVLW  02
1366:  MOVWF  74
1367:  MOVF   6D,W
1368:  MOVWF  75
1369:  BCF    0A.4
136A:  BSF    0A.3
136B:  CALL   13A
136C:  BSF    0A.4
136D:  BCF    0A.3
.................... }
.................... void chinh_tang_gpg(){
....................    switch(gt_mod){
*
1317:  MOVF   33,W
1318:  XORLW  01
1319:  BTFSC  03.2
131A:  GOTO   322
131B:  XORLW  03
131C:  BTFSC  03.2
131D:  GOTO   33B
131E:  XORLW  01
131F:  BTFSC  03.2
1320:  GOTO   355
1321:  GOTO   36F
....................       case 1:
....................          tang_giay();
....................          break;
*
133A:  GOTO   370
....................       case 2:
....................          tang_phut();
....................          break;
*
1354:  GOTO   370
....................       case 3:
....................          tang_gio();
....................          break;
*
136E:  GOTO   370
....................       default: break;
136F:  GOTO   370
....................    }
.................... }
.................... void tang_nam(){
....................    if(nam_ds == 0x99) nam_ds = 0;
*
1382:  MOVF   71,W
1383:  SUBLW  99
1384:  BTFSS  03.2
1385:  GOTO   388
1386:  CLRF   71
1387:  GOTO   392
....................    else nam_ds = tang_or_giam_bcd(nam_ds, tang);
1388:  MOVF   71,W
1389:  MOVWF  74
138A:  CLRF   75
138B:  BCF    0A.4
138C:  BSF    0A.3
138D:  CALL   101
138E:  BSF    0A.4
138F:  BCF    0A.3
1390:  MOVF   78,W
1391:  MOVWF  71
....................    ds1307_save_ds(6,nam_ds);
1392:  MOVLW  06
1393:  MOVWF  74
1394:  MOVF   71,W
1395:  MOVWF  75
1396:  BCF    0A.4
1397:  BSF    0A.3
1398:  CALL   13A
1399:  BSF    0A.4
139A:  BCF    0A.3
.................... }
.................... void tang_thang(){
....................    if(thang_ds == 0x12) thang_ds = 1;
*
139C:  MOVF   70,W
139D:  SUBLW  12
139E:  BTFSS  03.2
139F:  GOTO   3A3
13A0:  MOVLW  01
13A1:  MOVWF  70
13A2:  GOTO   3AD
....................    else thang_ds = tang_or_giam_bcd(thang_ds, tang);
13A3:  MOVF   70,W
13A4:  MOVWF  74
13A5:  CLRF   75
13A6:  BCF    0A.4
13A7:  BSF    0A.3
13A8:  CALL   101
13A9:  BSF    0A.4
13AA:  BCF    0A.3
13AB:  MOVF   78,W
13AC:  MOVWF  70
....................    ds1307_save_ds(5,thang_ds);
13AD:  MOVLW  05
13AE:  MOVWF  74
13AF:  MOVF   70,W
13B0:  MOVWF  75
13B1:  BCF    0A.4
13B2:  BSF    0A.3
13B3:  CALL   13A
13B4:  BSF    0A.4
13B5:  BCF    0A.3
.................... }
.................... void tang_ngay(){
....................    if(ngay_ds == 0x31) ngay_ds = 1;
*
13B7:  MOVF   6F,W
13B8:  SUBLW  31
13B9:  BTFSS  03.2
13BA:  GOTO   3BE
13BB:  MOVLW  01
13BC:  MOVWF  6F
13BD:  GOTO   3C8
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, tang);
13BE:  MOVF   6F,W
13BF:  MOVWF  74
13C0:  CLRF   75
13C1:  BCF    0A.4
13C2:  BSF    0A.3
13C3:  CALL   101
13C4:  BSF    0A.4
13C5:  BCF    0A.3
13C6:  MOVF   78,W
13C7:  MOVWF  6F
....................    ds1307_save_ds(4,ngay_ds);
13C8:  MOVLW  04
13C9:  MOVWF  74
13CA:  MOVF   6F,W
13CB:  MOVWF  75
13CC:  BCF    0A.4
13CD:  BSF    0A.3
13CE:  CALL   13A
13CF:  BSF    0A.4
13D0:  BCF    0A.3
.................... }
.................... void chinh_tang_ntn(){
....................    switch(gt_mod){
*
1377:  MOVF   33,W
1378:  XORLW  04
1379:  BTFSC  03.2
137A:  GOTO   382
137B:  XORLW  01
137C:  BTFSC  03.2
137D:  GOTO   39C
137E:  XORLW  03
137F:  BTFSC  03.2
1380:  GOTO   3B7
1381:  GOTO   3D2
....................       case 4:
....................          tang_nam();
....................          break;
*
139B:  GOTO   3D3
....................       case 5:
....................          tang_thang();
....................          break;
*
13B6:  GOTO   3D3
....................       case 6:
....................          tang_ngay();
....................          break;
*
13D1:  GOTO   3D3
....................       default: break;
13D2:  GOTO   3D3
....................    }
.................... }
.................... void chinh_tang_thu(){
....................    if(thu_ds == 8) thu_ds = 2;
*
13D8:  MOVF   6E,W
13D9:  SUBLW  08
13DA:  BTFSS  03.2
13DB:  GOTO   3DF
13DC:  MOVLW  02
13DD:  MOVWF  6E
13DE:  GOTO   3E0
....................    else thu_ds++;
13DF:  INCF   6E,F
....................    ds1307_save_ds(3,thu_ds);
13E0:  MOVLW  03
13E1:  MOVWF  74
13E2:  MOVF   6E,W
13E3:  MOVWF  75
13E4:  BCF    0A.4
13E5:  BSF    0A.3
13E6:  CALL   13A
13E7:  BSF    0A.4
13E8:  BCF    0A.3
.................... }
.................... 
.................... void phim_up(){
....................    if(tick_btn(1, bt1)){
*
1306:  MOVLW  01
1307:  MOVWF  74
1308:  MOVLW  31
1309:  MOVWF  75
130A:  BCF    0A.4
130B:  CALL   7D5
130C:  BSF    0A.4
130D:  MOVF   78,F
130E:  BTFSC  03.2
130F:  GOTO   3F1
....................       tg_chinh = 0;
1310:  CLRF   34
....................       if(gt_mod<4) chinh_tang_gpg();
1311:  BTFSC  33.7
1312:  GOTO   317
1313:  MOVF   33,W
1314:  SUBLW  03
1315:  BTFSS  03.0
1316:  GOTO   371
*
1370:  GOTO   3E9
....................       else if(gt_mod<7) chinh_tang_ntn();
1371:  BTFSC  33.7
1372:  GOTO   377
1373:  MOVF   33,W
1374:  SUBLW  06
1375:  BTFSS  03.0
1376:  GOTO   3D4
*
13D3:  GOTO   3E9
....................       else if(gt_mod==7) chinh_tang_thu();
13D4:  MOVF   33,W
13D5:  SUBLW  07
13D6:  BTFSS  03.2
13D7:  GOTO   3E9
....................       e_11 = true; e_22 = true; e_33 = true;
*
13E9:  BSF    2C.2
13EA:  BSF    2C.3
13EB:  BSF    2C.4
....................       giai_ma_gpg_ntn_thu_lcd();
13EC:  BCF    0A.4
13ED:  BSF    0A.3
13EE:  CALL   0DA
13EF:  BSF    0A.4
13F0:  BCF    0A.3
....................    }
.................... }
.................... void giam_giay(){
....................    if(giay_ds == 0) giay_ds = 0x59;
*
140D:  MOVF   6B,F
140E:  BTFSS  03.2
140F:  GOTO   413
1410:  MOVLW  59
1411:  MOVWF  6B
1412:  GOTO   41E
....................    else giay_ds = tang_or_giam_bcd(giay_ds,giam);
1413:  MOVF   6B,W
1414:  MOVWF  74
1415:  MOVLW  01
1416:  MOVWF  75
1417:  BCF    0A.4
1418:  BSF    0A.3
1419:  CALL   101
141A:  BSF    0A.4
141B:  BCF    0A.3
141C:  MOVF   78,W
141D:  MOVWF  6B
....................    ds1307_save_ds(0,giay_ds);
141E:  CLRF   74
141F:  MOVF   6B,W
1420:  MOVWF  75
1421:  BCF    0A.4
1422:  BSF    0A.3
1423:  CALL   13A
1424:  BSF    0A.4
1425:  BCF    0A.3
.................... }
.................... void giam_phut(){
....................    if(phut_ds == 0) phut_ds = 0x59;
*
1427:  MOVF   6C,F
1428:  BTFSS  03.2
1429:  GOTO   42D
142A:  MOVLW  59
142B:  MOVWF  6C
142C:  GOTO   438
....................    else phut_ds = tang_or_giam_bcd(phut_ds,giam);
142D:  MOVF   6C,W
142E:  MOVWF  74
142F:  MOVLW  01
1430:  MOVWF  75
1431:  BCF    0A.4
1432:  BSF    0A.3
1433:  CALL   101
1434:  BSF    0A.4
1435:  BCF    0A.3
1436:  MOVF   78,W
1437:  MOVWF  6C
....................    ds1307_save_ds(1,phut_ds);
1438:  MOVLW  01
1439:  MOVWF  74
143A:  MOVF   6C,W
143B:  MOVWF  75
143C:  BCF    0A.4
143D:  BSF    0A.3
143E:  CALL   13A
143F:  BSF    0A.4
1440:  BCF    0A.3
.................... }
.................... void giam_gio(){
....................    if(gio_ds == 0) gio_ds = 0x23;
*
1442:  MOVF   6D,F
1443:  BTFSS  03.2
1444:  GOTO   448
1445:  MOVLW  23
1446:  MOVWF  6D
1447:  GOTO   453
....................    else gio_ds = tang_or_giam_bcd(gio_ds,giam);
1448:  MOVF   6D,W
1449:  MOVWF  74
144A:  MOVLW  01
144B:  MOVWF  75
144C:  BCF    0A.4
144D:  BSF    0A.3
144E:  CALL   101
144F:  BSF    0A.4
1450:  BCF    0A.3
1451:  MOVF   78,W
1452:  MOVWF  6D
....................    ds1307_save_ds(2,gio_ds);
1453:  MOVLW  02
1454:  MOVWF  74
1455:  MOVF   6D,W
1456:  MOVWF  75
1457:  BCF    0A.4
1458:  BSF    0A.3
1459:  CALL   13A
145A:  BSF    0A.4
145B:  BCF    0A.3
.................... }
.................... void chinh_giam_gpg(){
....................    switch(gt_mod){
*
1402:  MOVF   33,W
1403:  XORLW  01
1404:  BTFSC  03.2
1405:  GOTO   40D
1406:  XORLW  03
1407:  BTFSC  03.2
1408:  GOTO   427
1409:  XORLW  01
140A:  BTFSC  03.2
140B:  GOTO   442
140C:  GOTO   45D
....................       case 1:
....................          giam_giay();
....................          break;
*
1426:  GOTO   45E
....................       case 2:
....................          giam_phut();
....................          break;
*
1441:  GOTO   45E
....................       case 3:
....................          giam_gio();
....................          break;
*
145C:  GOTO   45E
....................       default: break;
145D:  GOTO   45E
....................    }
.................... }
.................... void giam_nam(){
....................    if(nam_ds == 0x0) nam_ds = 0x99;
*
1470:  MOVF   71,F
1471:  BTFSS  03.2
1472:  GOTO   476
1473:  MOVLW  99
1474:  MOVWF  71
1475:  GOTO   481
....................    else nam_ds = tang_or_giam_bcd(nam_ds, giam);
1476:  MOVF   71,W
1477:  MOVWF  74
1478:  MOVLW  01
1479:  MOVWF  75
147A:  BCF    0A.4
147B:  BSF    0A.3
147C:  CALL   101
147D:  BSF    0A.4
147E:  BCF    0A.3
147F:  MOVF   78,W
1480:  MOVWF  71
....................    ds1307_save_ds(6,nam_ds);
1481:  MOVLW  06
1482:  MOVWF  74
1483:  MOVF   71,W
1484:  MOVWF  75
1485:  BCF    0A.4
1486:  BSF    0A.3
1487:  CALL   13A
1488:  BSF    0A.4
1489:  BCF    0A.3
.................... }
.................... void giam_thang(){
....................    if(thang_ds == 0x1) thang_ds = 12;
*
148B:  DECFSZ 70,W
148C:  GOTO   490
148D:  MOVLW  0C
148E:  MOVWF  70
148F:  GOTO   49B
....................    else thang_ds = tang_or_giam_bcd(thang_ds, giam);
1490:  MOVF   70,W
1491:  MOVWF  74
1492:  MOVLW  01
1493:  MOVWF  75
1494:  BCF    0A.4
1495:  BSF    0A.3
1496:  CALL   101
1497:  BSF    0A.4
1498:  BCF    0A.3
1499:  MOVF   78,W
149A:  MOVWF  70
....................    ds1307_save_ds(5,thang_ds);
149B:  MOVLW  05
149C:  MOVWF  74
149D:  MOVF   70,W
149E:  MOVWF  75
149F:  BCF    0A.4
14A0:  BSF    0A.3
14A1:  CALL   13A
14A2:  BSF    0A.4
14A3:  BCF    0A.3
.................... }
.................... void giam_ngay(){
....................    if(ngay_ds == 0x1) ngay_ds = 21;
*
14A5:  DECFSZ 6F,W
14A6:  GOTO   4AA
14A7:  MOVLW  15
14A8:  MOVWF  6F
14A9:  GOTO   4B5
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, giam);
14AA:  MOVF   6F,W
14AB:  MOVWF  74
14AC:  MOVLW  01
14AD:  MOVWF  75
14AE:  BCF    0A.4
14AF:  BSF    0A.3
14B0:  CALL   101
14B1:  BSF    0A.4
14B2:  BCF    0A.3
14B3:  MOVF   78,W
14B4:  MOVWF  6F
....................    ds1307_save_ds(4,ngay_ds);
14B5:  MOVLW  04
14B6:  MOVWF  74
14B7:  MOVF   6F,W
14B8:  MOVWF  75
14B9:  BCF    0A.4
14BA:  BSF    0A.3
14BB:  CALL   13A
14BC:  BSF    0A.4
14BD:  BCF    0A.3
.................... }
.................... void chinh_giam_ntn(){
....................    switch(gt_mod){
*
1465:  MOVF   33,W
1466:  XORLW  01
1467:  BTFSC  03.2
1468:  GOTO   470
1469:  XORLW  03
146A:  BTFSC  03.2
146B:  GOTO   48B
146C:  XORLW  01
146D:  BTFSC  03.2
146E:  GOTO   4A5
146F:  GOTO   4BF
....................       case 1:
....................          giam_nam();
....................          break;
*
148A:  GOTO   4C0
....................       case 2:
....................          giam_thang();
....................          break;
*
14A4:  GOTO   4C0
....................       case 3:
....................          giam_ngay();
....................          break;
*
14BE:  GOTO   4C0
....................       default: break;
14BF:  GOTO   4C0
....................    }
.................... }
.................... void chinh_giam_thu(){
....................    if(thu_ds == 2) thu_ds = 8;
*
14C5:  MOVF   6E,W
14C6:  SUBLW  02
14C7:  BTFSS  03.2
14C8:  GOTO   4CC
14C9:  MOVLW  08
14CA:  MOVWF  6E
14CB:  GOTO   4CD
....................    else thu_ds--;
14CC:  DECF   6E,F
....................    ds1307_save_ds(3,thu_ds);
14CD:  MOVLW  03
14CE:  MOVWF  74
14CF:  MOVF   6E,W
14D0:  MOVWF  75
14D1:  BCF    0A.4
14D2:  BSF    0A.3
14D3:  CALL   13A
14D4:  BSF    0A.4
14D5:  BCF    0A.3
.................... }
.................... void phim_dw(){
....................    if(tick_btn(1, bt2)){
*
13F1:  MOVLW  01
13F2:  MOVWF  74
13F3:  MOVLW  32
13F4:  MOVWF  75
13F5:  BCF    0A.4
13F6:  CALL   7D5
13F7:  BSF    0A.4
13F8:  MOVF   78,F
13F9:  BTFSC  03.2
13FA:  GOTO   4DE
....................       tg_chinh = 0;
13FB:  CLRF   34
....................       if(gt_mod<4) chinh_giam_gpg();
13FC:  BTFSC  33.7
13FD:  GOTO   402
13FE:  MOVF   33,W
13FF:  SUBLW  03
1400:  BTFSS  03.0
1401:  GOTO   45F
*
145E:  GOTO   4D6
....................       else if(gt_mod<7) chinh_giam_ntn();
145F:  BTFSC  33.7
1460:  GOTO   465
1461:  MOVF   33,W
1462:  SUBLW  06
1463:  BTFSS  03.0
1464:  GOTO   4C1
*
14C0:  GOTO   4D6
....................       else if(gt_mod==7) chinh_giam_thu();
14C1:  MOVF   33,W
14C2:  SUBLW  07
14C3:  BTFSS  03.2
14C4:  GOTO   4D6
....................       e_11 = true; e_22 = true; e_33 = true;
*
14D6:  BSF    2C.2
14D7:  BSF    2C.3
14D8:  BSF    2C.4
....................       giai_ma_gpg_ntn_thu_lcd();
14D9:  BCF    0A.4
14DA:  BSF    0A.3
14DB:  CALL   0DA
14DC:  BSF    0A.4
14DD:  BCF    0A.3
....................    }
.................... }
.................... void log_mode(){
....................    lcd_setCursor(0, 1);
*
14FC:  BSF    03.5
14FD:  CLRF   34
14FE:  MOVLW  01
14FF:  MOVWF  35
1500:  BCF    0A.4
1501:  BCF    03.5
1502:  CALL   313
1503:  BSF    0A.4
....................    if(tt_ht == 0) lcd_data(" N ");
1504:  MOVF   32,F
1505:  BTFSS  03.2
1506:  GOTO   511
1507:  MOVLW  CF
1508:  BSF    03.6
1509:  MOVWF  0D
150A:  MOVLW  00
150B:  MOVWF  0F
150C:  BCF    0A.4
150D:  BCF    03.6
150E:  CALL   34F
150F:  BSF    0A.4
1510:  GOTO   538
....................    else if(tt_ht == 1) lcd_data("GPG");
1511:  DECFSZ 32,W
1512:  GOTO   51D
1513:  MOVLW  D1
1514:  BSF    03.6
1515:  MOVWF  0D
1516:  MOVLW  00
1517:  MOVWF  0F
1518:  BCF    0A.4
1519:  BCF    03.6
151A:  CALL   34F
151B:  BSF    0A.4
151C:  GOTO   538
....................    else if(tt_ht == 2) lcd_data("NTN");
151D:  MOVF   32,W
151E:  SUBLW  02
151F:  BTFSS  03.2
1520:  GOTO   52B
1521:  MOVLW  D3
1522:  BSF    03.6
1523:  MOVWF  0D
1524:  MOVLW  00
1525:  MOVWF  0F
1526:  BCF    0A.4
1527:  BCF    03.6
1528:  CALL   34F
1529:  BSF    0A.4
152A:  GOTO   538
....................    else if(tt_ht == 3) lcd_data(" T ");
152B:  MOVF   32,W
152C:  SUBLW  03
152D:  BTFSS  03.2
152E:  GOTO   538
152F:  MOVLW  D5
1530:  BSF    03.6
1531:  MOVWF  0D
1532:  MOVLW  00
1533:  MOVWF  0F
1534:  BCF    0A.4
1535:  BCF    03.6
1536:  CALL   34F
1537:  BSF    0A.4
....................    lcd_setCursor(13, 1);
1538:  MOVLW  0D
1539:  BSF    03.5
153A:  MOVWF  34
153B:  MOVLW  01
153C:  MOVWF  35
153D:  BCF    0A.4
153E:  BCF    03.5
153F:  CALL   313
1540:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
1541:  MOVLW  30
1542:  ADDWF  33,W
1543:  MOVWF  74
1544:  BSF    03.5
1545:  MOVWF  37
1546:  BCF    0A.4
1547:  BCF    03.5
1548:  CALL   332
1549:  BSF    0A.4
....................    if(gt_mod != 0){
154A:  MOVF   33,F
154B:  BTFSC  03.2
154C:  GOTO   572
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
154D:  MOVF   34,W
154E:  MOVWF  74
154F:  MOVLW  0A
1550:  MOVWF  75
1551:  BCF    0A.4
1552:  BSF    0A.3
1553:  CALL   158
1554:  BSF    0A.4
1555:  BCF    0A.3
1556:  MOVLW  30
1557:  ADDWF  78,W
1558:  MOVWF  74
1559:  BSF    03.5
155A:  MOVWF  37
155B:  BCF    0A.4
155C:  BCF    03.5
155D:  CALL   332
155E:  BSF    0A.4
155F:  MOVF   34,W
1560:  MOVWF  74
1561:  MOVLW  0A
1562:  MOVWF  75
1563:  BCF    0A.4
1564:  BSF    0A.3
1565:  CALL   158
1566:  BSF    0A.4
1567:  BCF    0A.3
1568:  MOVLW  30
1569:  ADDWF  77,W
156A:  MOVWF  74
156B:  BSF    03.5
156C:  MOVWF  37
156D:  BCF    0A.4
156E:  BCF    03.5
156F:  CALL   332
1570:  BSF    0A.4
....................    }
1571:  GOTO   57B
....................    else
....................       lcd_data("__");
1572:  MOVLW  D7
1573:  BSF    03.6
1574:  MOVWF  0D
1575:  MOVLW  00
1576:  MOVWF  0F
1577:  BCF    0A.4
1578:  BCF    03.6
1579:  CALL   34F
157A:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_change_alarm_eat.c>
.................... void giai_ma_gpg_alarm_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_eat,dec_phut_eat,dec_giay_eat,e_33, e_22, e_11);
*
097D:  MOVF   35,W
097E:  BSF    03.5
097F:  MOVWF  22
0980:  BCF    0A.3
0981:  BCF    03.5
0982:  CALL   60B
0983:  BSF    0A.3
0984:  MOVF   78,W
0985:  BSF    03.5
0986:  MOVWF  20
0987:  BCF    03.5
0988:  MOVF   36,W
0989:  BSF    03.5
098A:  MOVWF  22
098B:  BCF    0A.3
098C:  BCF    03.5
098D:  CALL   60B
098E:  BSF    0A.3
098F:  MOVF   78,W
0990:  BSF    03.5
0991:  MOVWF  21
0992:  BCF    03.5
0993:  MOVF   37,W
0994:  BSF    03.5
0995:  MOVWF  22
0996:  BCF    0A.3
0997:  BCF    03.5
0998:  CALL   60B
0999:  BSF    0A.3
099A:  MOVF   78,W
099B:  BSF    03.5
099C:  MOVWF  22
099D:  MOVLW  00
099E:  BCF    03.5
099F:  BTFSC  2C.4
09A0:  MOVLW  01
09A1:  BSF    03.5
09A2:  MOVWF  23
09A3:  MOVLW  00
09A4:  BCF    03.5
09A5:  BTFSC  2C.3
09A6:  MOVLW  01
09A7:  BSF    03.5
09A8:  MOVWF  24
09A9:  MOVLW  00
09AA:  BCF    03.5
09AB:  BTFSC  2C.2
09AC:  MOVLW  01
09AD:  BSF    03.5
09AE:  MOVWF  25
09AF:  MOVLW  04
09B0:  MOVWF  26
09B1:  MOVLW  01
09B2:  MOVWF  27
09B3:  MOVF   20,W
09B4:  MOVWF  28
09B5:  MOVF   21,W
09B6:  MOVWF  29
09B7:  MOVF   22,W
09B8:  MOVWF  2A
09B9:  MOVF   23,W
09BA:  MOVWF  2B
09BB:  MOVF   24,W
09BC:  MOVWF  2C
09BD:  MOVF   25,W
09BE:  MOVWF  2D
09BF:  BCF    0A.3
09C0:  BCF    03.5
09C1:  CALL   637
09C2:  BSF    0A.3
09C3:  RETURN
.................... }
.................... void phim_chon_mode_alarm(){
....................    if(tick_btn(2, bt3)){
*
1599:  MOVLW  02
159A:  MOVWF  74
159B:  MOVLW  33
159C:  MOVWF  75
159D:  BCF    0A.4
159E:  CALL   7D5
159F:  BSF    0A.4
15A0:  MOVF   78,F
15A1:  BTFSC  03.2
15A2:  GOTO   5B3
....................       if(gt_mod < 3) gt_mod++;
15A3:  BTFSC  33.7
15A4:  GOTO   5A9
15A5:  MOVF   33,W
15A6:  SUBLW  02
15A7:  BTFSS  03.0
15A8:  GOTO   5AB
15A9:  INCF   33,F
15AA:  GOTO   5AD
....................       else{
....................          gt_mod = 0;
15AB:  CLRF   33
....................          countLevel = 0;
15AC:  CLRF   38
....................       }
....................       tg_chinh = 0;
15AD:  CLRF   34
....................       giai_ma_gpg_alarm_lcd();
15AE:  BCF    0A.4
15AF:  BSF    0A.3
15B0:  CALL   17D
15B1:  BSF    0A.4
15B2:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay_eat(){
....................    if(eat_ss == 0x59) eat_ss = 0x00;
*
15C9:  MOVF   37,W
15CA:  SUBLW  59
15CB:  BTFSS  03.2
15CC:  GOTO   5CF
15CD:  CLRF   37
15CE:  GOTO   5D9
....................    else eat_ss = tang_or_giam_bcd(eat_ss, tang);
15CF:  MOVF   37,W
15D0:  MOVWF  74
15D1:  CLRF   75
15D2:  BCF    0A.4
15D3:  BSF    0A.3
15D4:  CALL   101
15D5:  BSF    0A.4
15D6:  BCF    0A.3
15D7:  MOVF   78,W
15D8:  MOVWF  37
.................... }
.................... void tang_phut_eat(){
....................    if(eat_pp == 0x59) eat_pp = 0x00;
*
15DA:  MOVF   36,W
15DB:  SUBLW  59
15DC:  BTFSS  03.2
15DD:  GOTO   5E0
15DE:  CLRF   36
15DF:  GOTO   5EA
....................    else eat_pp = tang_or_giam_bcd(eat_pp, tang);
15E0:  MOVF   36,W
15E1:  MOVWF  74
15E2:  CLRF   75
15E3:  BCF    0A.4
15E4:  BSF    0A.3
15E5:  CALL   101
15E6:  BSF    0A.4
15E7:  BCF    0A.3
15E8:  MOVF   78,W
15E9:  MOVWF  36
.................... }
.................... void tang_gio_eat(){
....................    if(eat_hh == 0x23) eat_hh = 0x00;
*
15EB:  MOVF   35,W
15EC:  SUBLW  23
15ED:  BTFSS  03.2
15EE:  GOTO   5F1
15EF:  CLRF   35
15F0:  GOTO   5FB
....................    else eat_hh = tang_or_giam_bcd(eat_hh, tang);
15F1:  MOVF   35,W
15F2:  MOVWF  74
15F3:  CLRF   75
15F4:  BCF    0A.4
15F5:  BSF    0A.3
15F6:  CALL   101
15F7:  BSF    0A.4
15F8:  BCF    0A.3
15F9:  MOVF   78,W
15FA:  MOVWF  35
.................... }
.................... void chinh_tang_gpg_eat(){
....................    switch(gt_mod){
*
15BE:  MOVF   33,W
15BF:  XORLW  01
15C0:  BTFSC  03.2
15C1:  GOTO   5C9
15C2:  XORLW  03
15C3:  BTFSC  03.2
15C4:  GOTO   5DA
15C5:  XORLW  01
15C6:  BTFSC  03.2
15C7:  GOTO   5EB
15C8:  GOTO   5FC
....................       case 1:
....................          tang_giay_eat();
....................          break;
*
15D9:  GOTO   5FD
....................       case 2:
....................          tang_phut_eat();
....................          break;
*
15EA:  GOTO   5FD
....................       case 3:
....................          tang_gio_eat();
....................          break;
*
15FB:  GOTO   5FD
....................       default: break;
15FC:  GOTO   5FD
....................    }
.................... }
.................... 
.................... void phim_up_eat(){
....................    if(tick_btn(1, bt1)){
*
15B3:  MOVLW  01
15B4:  MOVWF  74
15B5:  MOVLW  31
15B6:  MOVWF  75
15B7:  BCF    0A.4
15B8:  CALL   7D5
15B9:  BSF    0A.4
15BA:  MOVF   78,F
15BB:  BTFSC  03.2
15BC:  GOTO   605
....................       tg_chinh = 0;
15BD:  CLRF   34
....................       chinh_tang_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
15FD:  BSF    2C.2
15FE:  BSF    2C.3
15FF:  BSF    2C.4
....................       giai_ma_gpg_alarm_lcd();
1600:  BCF    0A.4
1601:  BSF    0A.3
1602:  CALL   17D
1603:  BSF    0A.4
1604:  BCF    0A.3
....................    }
.................... }
.................... 
.................... void giam_giay_eat(){
....................    if(eat_ss == 0) eat_ss = 0x59;
*
161B:  MOVF   37,F
161C:  BTFSS  03.2
161D:  GOTO   621
161E:  MOVLW  59
161F:  MOVWF  37
1620:  GOTO   62C
....................    else eat_ss = tang_or_giam_bcd(eat_ss,giam);
1621:  MOVF   37,W
1622:  MOVWF  74
1623:  MOVLW  01
1624:  MOVWF  75
1625:  BCF    0A.4
1626:  BSF    0A.3
1627:  CALL   101
1628:  BSF    0A.4
1629:  BCF    0A.3
162A:  MOVF   78,W
162B:  MOVWF  37
.................... }
.................... void giam_phut_eat(){
....................    if(eat_pp == 0) eat_pp = 0x59;
*
162D:  MOVF   36,F
162E:  BTFSS  03.2
162F:  GOTO   633
1630:  MOVLW  59
1631:  MOVWF  36
1632:  GOTO   63E
....................    else eat_pp = tang_or_giam_bcd(eat_pp,giam);
1633:  MOVF   36,W
1634:  MOVWF  74
1635:  MOVLW  01
1636:  MOVWF  75
1637:  BCF    0A.4
1638:  BSF    0A.3
1639:  CALL   101
163A:  BSF    0A.4
163B:  BCF    0A.3
163C:  MOVF   78,W
163D:  MOVWF  36
.................... }
.................... void giam_gio_eat(){
....................    if(eat_hh == 0) eat_hh = 0x23;
*
163F:  MOVF   35,F
1640:  BTFSS  03.2
1641:  GOTO   645
1642:  MOVLW  23
1643:  MOVWF  35
1644:  GOTO   650
....................    else eat_hh = tang_or_giam_bcd(eat_hh,giam);
1645:  MOVF   35,W
1646:  MOVWF  74
1647:  MOVLW  01
1648:  MOVWF  75
1649:  BCF    0A.4
164A:  BSF    0A.3
164B:  CALL   101
164C:  BSF    0A.4
164D:  BCF    0A.3
164E:  MOVF   78,W
164F:  MOVWF  35
.................... }
.................... void chinh_giam_gpg_eat(){
....................    switch(gt_mod){
*
1610:  MOVF   33,W
1611:  XORLW  01
1612:  BTFSC  03.2
1613:  GOTO   61B
1614:  XORLW  03
1615:  BTFSC  03.2
1616:  GOTO   62D
1617:  XORLW  01
1618:  BTFSC  03.2
1619:  GOTO   63F
161A:  GOTO   651
....................       case 1:
....................          giam_giay_eat();
....................          break;
*
162C:  GOTO   652
....................       case 2:
....................          giam_phut_eat();
....................          break;
*
163E:  GOTO   652
....................       case 3:
....................          giam_gio_eat();
....................          break;
*
1650:  GOTO   652
....................       default: break;
1651:  GOTO   652
....................    }
.................... }
.................... void phim_dw_eat(){
....................    if(tick_btn(1, bt2)){
*
1605:  MOVLW  01
1606:  MOVWF  74
1607:  MOVLW  32
1608:  MOVWF  75
1609:  BCF    0A.4
160A:  CALL   7D5
160B:  BSF    0A.4
160C:  MOVF   78,F
160D:  BTFSC  03.2
160E:  GOTO   65A
....................       tg_chinh = 0;
160F:  CLRF   34
....................       chinh_giam_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
1652:  BSF    2C.2
1653:  BSF    2C.3
1654:  BSF    2C.4
....................       giai_ma_gpg_alarm_lcd();
1655:  BCF    0A.4
1656:  BSF    0A.3
1657:  CALL   17D
1658:  BSF    0A.4
1659:  BCF    0A.3
....................    }
.................... }
.................... void log_mode_alarm(){
....................    lcd_setCursor(13, 1);
*
1671:  MOVLW  0D
1672:  BSF    03.5
1673:  MOVWF  34
1674:  MOVLW  01
1675:  MOVWF  35
1676:  BCF    0A.4
1677:  BCF    03.5
1678:  CALL   313
1679:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
167A:  MOVLW  30
167B:  ADDWF  33,W
167C:  MOVWF  74
167D:  BSF    03.5
167E:  MOVWF  37
167F:  BCF    0A.4
1680:  BCF    03.5
1681:  CALL   332
1682:  BSF    0A.4
....................    if(gt_mod != 0){
1683:  MOVF   33,F
1684:  BTFSC  03.2
1685:  GOTO   6AB
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
1686:  MOVF   34,W
1687:  MOVWF  74
1688:  MOVLW  0A
1689:  MOVWF  75
168A:  BCF    0A.4
168B:  BSF    0A.3
168C:  CALL   158
168D:  BSF    0A.4
168E:  BCF    0A.3
168F:  MOVLW  30
1690:  ADDWF  78,W
1691:  MOVWF  74
1692:  BSF    03.5
1693:  MOVWF  37
1694:  BCF    0A.4
1695:  BCF    03.5
1696:  CALL   332
1697:  BSF    0A.4
1698:  MOVF   34,W
1699:  MOVWF  74
169A:  MOVLW  0A
169B:  MOVWF  75
169C:  BCF    0A.4
169D:  BSF    0A.3
169E:  CALL   158
169F:  BSF    0A.4
16A0:  BCF    0A.3
16A1:  MOVLW  30
16A2:  ADDWF  77,W
16A3:  MOVWF  74
16A4:  BSF    03.5
16A5:  MOVWF  37
16A6:  BCF    0A.4
16A7:  BCF    03.5
16A8:  CALL   332
16A9:  BSF    0A.4
....................    }
16AA:  GOTO   6B4
....................    else
....................       lcd_data("__");
16AB:  MOVLW  D9
16AC:  BSF    03.6
16AD:  MOVWF  0D
16AE:  MOVLW  00
16AF:  MOVWF  0F
16B0:  BCF    0A.4
16B1:  BCF    03.6
16B2:  CALL   34F
16B3:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_control_chiller.c>
.................... void control_temperature(int8 nd_ss, int8 gh){
....................    if(nd_ss > gh){
*
112F:  MOVF   74,W
1130:  SUBWF  75,W
1131:  BTFSC  03.0
1132:  GOTO   13C
....................    // water is hot
....................       output_bit(pinDLCold, 1);
1133:  BSF    08.6
1134:  BSF    03.5
1135:  BCF    08.6
....................       output_bit(pinDLHot,  0);
1136:  BCF    03.5
1137:  BCF    08.7
1138:  BSF    03.5
1139:  BCF    08.7
....................    }
113A:  GOTO   143
113B:  BCF    03.5
....................    else{
....................    // water is cold
....................       output_bit(pinDLCold, 0);
113C:  BCF    08.6
113D:  BSF    03.5
113E:  BCF    08.6
....................       output_bit(pinDLHot,  1);
113F:  BCF    03.5
1140:  BSF    08.7
1141:  BSF    03.5
1142:  BCF    08.7
....................    }
.................... }
.................... 
.................... void servo_degree_0(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
02ED:  CLRF   74
02EE:  MOVF   74,W
02EF:  SUBLW  31
02F0:  BTFSS  03.0
02F1:  GOTO   312
....................       output_bit(pinServo, 1);
02F2:  BSF    07.1
02F3:  BCF    2B.1
02F4:  MOVF   2B,W
02F5:  BSF    03.5
02F6:  MOVWF  07
....................       Delay_us(800); // pulse of 800us
02F7:  MOVLW  04
02F8:  MOVWF  75
02F9:  MOVLW  C7
02FA:  MOVWF  21
02FB:  BCF    03.5
02FC:  CALL   2DC
02FD:  DECFSZ 75,F
02FE:  GOTO   300
02FF:  GOTO   302
0300:  BSF    03.5
0301:  GOTO   2F9
....................       output_bit(pinServo, 0);
0302:  BCF    07.1
0303:  BCF    2B.1
0304:  MOVF   2B,W
0305:  BSF    03.5
0306:  MOVWF  07
....................       Delay_us(19200);
0307:  MOVLW  13
0308:  MOVWF  75
0309:  BCF    03.5
030A:  CALL   1D1
030B:  MOVLW  C8
030C:  BSF    03.5
030D:  MOVWF  21
030E:  BCF    03.5
030F:  CALL   2DC
0310:  INCF   74,F
0311:  GOTO   2EE
....................    }
0312:  RETURN
.................... }
.................... 
.................... void servo_degree_90(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
1183:  CLRF   74
1184:  MOVF   74,W
1185:  SUBLW  31
1186:  BTFSS  03.0
1187:  GOTO   1B6
....................       output_bit(pinServo, 1);
1188:  BSF    07.1
1189:  BCF    2B.1
118A:  MOVF   2B,W
118B:  BSF    03.5
118C:  MOVWF  07
....................       Delay_us(1500); // pulse of 1500us
118D:  MOVLW  01
118E:  MOVWF  75
118F:  BCF    0A.4
1190:  BCF    03.5
1191:  CALL   1D1
1192:  BSF    0A.4
1193:  MOVLW  02
1194:  MOVWF  75
1195:  MOVLW  F9
1196:  BSF    03.5
1197:  MOVWF  21
1198:  BCF    0A.4
1199:  BCF    03.5
119A:  CALL   2DC
119B:  BSF    0A.4
119C:  DECFSZ 75,F
119D:  GOTO   195
....................       output_bit(pinServo, 0);
119E:  BCF    07.1
119F:  BCF    2B.1
11A0:  MOVF   2B,W
11A1:  BSF    03.5
11A2:  MOVWF  07
....................       Delay_us(18500);
11A3:  MOVLW  12
11A4:  MOVWF  75
11A5:  BCF    0A.4
11A6:  BCF    03.5
11A7:  CALL   1D1
11A8:  BSF    0A.4
11A9:  MOVLW  02
11AA:  MOVWF  75
11AB:  MOVLW  F9
11AC:  BSF    03.5
11AD:  MOVWF  21
11AE:  BCF    0A.4
11AF:  BCF    03.5
11B0:  CALL   2DC
11B1:  BSF    0A.4
11B2:  DECFSZ 75,F
11B3:  GOTO   1AB
11B4:  INCF   74,F
11B5:  GOTO   184
....................    }
.................... }
.................... 
.................... void servo_degree_180(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
....................       output_bit(pinServo, 1);
....................       Delay_us(2200); // pulse of 2200us
....................       output_bit(pinServo, 0);
....................       Delay_us(17800);
....................    }
.................... }
.................... 
.................... void control_servo(){
....................    if(dec_gio_ds == dec_gio_eat && dec_phut_ds == dec_phut_eat && dec_giay_ds == dec_giay_eat){
*
1143:  BCF    03.5
1144:  MOVF   6D,W
1145:  BSF    03.5
1146:  MOVWF  22
1147:  BCF    0A.4
1148:  BCF    03.5
1149:  CALL   60B
114A:  BSF    0A.4
114B:  MOVF   78,W
114C:  MOVWF  74
114D:  MOVF   35,W
114E:  BSF    03.5
114F:  MOVWF  22
1150:  BCF    0A.4
1151:  BCF    03.5
1152:  CALL   60B
1153:  BSF    0A.4
1154:  MOVF   78,W
1155:  SUBWF  74,W
1156:  BTFSS  03.2
1157:  GOTO   181
1158:  MOVF   6C,W
1159:  BSF    03.5
115A:  MOVWF  22
115B:  BCF    0A.4
115C:  BCF    03.5
115D:  CALL   60B
115E:  BSF    0A.4
115F:  MOVF   78,W
1160:  MOVWF  74
1161:  MOVF   36,W
1162:  BSF    03.5
1163:  MOVWF  22
1164:  BCF    0A.4
1165:  BCF    03.5
1166:  CALL   60B
1167:  BSF    0A.4
1168:  MOVF   78,W
1169:  SUBWF  74,W
116A:  BTFSS  03.2
116B:  GOTO   181
116C:  MOVF   6B,W
116D:  BSF    03.5
116E:  MOVWF  22
116F:  BCF    0A.4
1170:  BCF    03.5
1171:  CALL   60B
1172:  BSF    0A.4
1173:  MOVF   78,W
1174:  MOVWF  74
1175:  MOVF   37,W
1176:  BSF    03.5
1177:  MOVWF  22
1178:  BCF    0A.4
1179:  BCF    03.5
117A:  CALL   60B
117B:  BSF    0A.4
117C:  MOVF   78,W
117D:  SUBWF  74,W
117E:  BTFSS  03.2
117F:  GOTO   181
....................       flag_servo = true;
1180:  BSF    2C.5
....................    }
....................    if(flag_servo){
1181:  BTFSS  2C.5
1182:  GOTO   1B7
....................       servo_degree_90();
....................    }
*
11B6:  GOTO   1BA
....................    else{
....................       servo_degree_0();
11B7:  BCF    0A.4
11B8:  CALL   2ED
11B9:  BSF    0A.4
....................    }
.................... }
.................... 
.................... 
.................... #include <library_menu.c>
.................... 
.................... void menu(){
....................    if (push_btn(false,bt0)) countLevel++;
*
1074:  CLRF   74
1075:  MOVLW  30
1076:  MOVWF  75
*
10C6:  MOVF   78,F
10C7:  BTFSC  03.2
10C8:  GOTO   0CA
10C9:  INCF   38,F
.................... 
....................    if (countLevel >= maxLevel) countLevel = 0;
10CA:  MOVF   38,W
10CB:  SUBLW  05
10CC:  BTFSC  03.0
10CD:  GOTO   0CF
10CE:  CLRF   38
....................    
....................    if(countLevel != countLevelRev){
10CF:  MOVF   39,W
10D0:  SUBWF  38,W
10D1:  BTFSC  03.2
10D2:  GOTO   0D8
....................       countLevelRev = countLevel;
10D3:  MOVF   38,W
10D4:  MOVWF  39
....................       lcd_clear();
10D5:  BCF    0A.4
10D6:  CALL   25E
10D7:  BSF    0A.4
....................    }
....................    
....................    switch(countLevel){
10D8:  MOVF   38,W
10D9:  BTFSC  03.2
10DA:  GOTO   0E8
10DB:  XORLW  01
10DC:  BTFSC  03.2
10DD:  GOTO   250
10DE:  XORLW  03
10DF:  BTFSC  03.2
10E0:  GOTO   2B3
10E1:  XORLW  01
10E2:  BTFSC  03.2
10E3:  GOTO   57C
10E4:  XORLW  07
10E5:  BTFSC  03.2
10E6:  GOTO   6B5
10E7:  GOTO   6EB
....................       case 0:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
10E8:  MOVLW  08
10E9:  MOVWF  74
10EA:  BCF    0A.4
10EB:  CALL   167
10EC:  BSF    0A.4
.................... 
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
10ED:  BCF    0A.4
10EE:  CALL   532
10EF:  BSF    0A.4
.................... 
.................... //! display info rtc and temperature for user
....................          lcd_dis_xx_yy_zz(4,0,dec_gio_ds,dec_phut_ds,dec_giay_ds,1,1,1);
10F0:  MOVF   6D,W
10F1:  BSF    03.5
10F2:  MOVWF  22
10F3:  BCF    0A.4
10F4:  BCF    03.5
10F5:  CALL   60B
10F6:  BSF    0A.4
10F7:  MOVF   78,W
10F8:  MOVWF  74
10F9:  MOVF   6C,W
10FA:  BSF    03.5
10FB:  MOVWF  22
10FC:  BCF    0A.4
10FD:  BCF    03.5
10FE:  CALL   60B
10FF:  BSF    0A.4
1100:  MOVF   78,W
1101:  MOVWF  75
1102:  MOVF   6B,W
1103:  BSF    03.5
1104:  MOVWF  22
1105:  BCF    0A.4
1106:  BCF    03.5
1107:  CALL   60B
1108:  BSF    0A.4
1109:  MOVF   78,W
110A:  MOVWF  76
110B:  MOVLW  04
110C:  BSF    03.5
110D:  MOVWF  26
110E:  CLRF   27
110F:  MOVF   74,W
1110:  MOVWF  28
1111:  MOVF   75,W
1112:  MOVWF  29
1113:  MOVF   78,W
1114:  MOVWF  2A
1115:  MOVLW  01
1116:  MOVWF  2B
1117:  MOVWF  2C
1118:  MOVWF  2D
1119:  BCF    0A.4
111A:  BCF    03.5
111B:  CALL   637
111C:  BSF    0A.4
....................          lcd_dis_temperature(2,1,dt_ng,dt_tp);
111D:  MOVLW  02
111E:  MOVWF  74
111F:  MOVLW  01
1120:  MOVWF  75
1121:  CLRF   7C
1122:  MOVF   3D,W
1123:  MOVWF  7B
1124:  MOVF   3F,W
1125:  MOVWF  7E
1126:  MOVF   3E,W
1127:  MOVWF  7D
1128:  BCF    0A.4
1129:  CALL   712
112A:  BSF    0A.4
.................... 
.................... //! control delay and servo
....................          control_temperature(dt_ng,limitTemperature);
112B:  MOVF   3D,W
112C:  MOVWF  74
112D:  MOVF   2D,W
112E:  MOVWF  75
....................          control_servo();
....................          
....................          handle_uart();
....................          
.................... //!         fprintf(UART_STREAM, "%s %d\r\n", "dt:rt:", dt_ng);
.................... //!         fprintf(UART_STREAM, "%s %d\r\n", "dt:lt:", limitTemperature);
....................          
....................          break;
*
124F:  GOTO   719
....................       case 1:
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
1250:  BCF    0A.4
1251:  CALL   532
1252:  BSF    0A.4
.................... 
.................... //! change limit temperature
....................          limitTemperature += tick_btn(1,bt2);
1253:  MOVLW  01
1254:  MOVWF  74
1255:  MOVLW  32
1256:  MOVWF  75
1257:  BCF    0A.4
1258:  CALL   7D5
1259:  BSF    0A.4
125A:  MOVF   78,W
125B:  ADDWF  2D,F
....................          limitTemperature -= tick_btn(1,bt1);
125C:  MOVLW  01
125D:  MOVWF  74
125E:  MOVLW  31
125F:  MOVWF  75
1260:  BCF    0A.4
1261:  CALL   7D5
1262:  BSF    0A.4
1263:  MOVF   78,W
1264:  SUBWF  2D,F
.................... 
.................... //! display info temperature limit and sensor
....................          lcd_dis_temperature(2,0,dt_ng,dt_tp);
1265:  MOVLW  02
1266:  MOVWF  74
1267:  CLRF   75
1268:  CLRF   7C
1269:  MOVF   3D,W
126A:  MOVWF  7B
126B:  MOVF   3F,W
126C:  MOVWF  7E
126D:  MOVF   3E,W
126E:  MOVWF  7D
126F:  BCF    0A.4
1270:  CALL   712
1271:  BSF    0A.4
....................          lcd_dis_temperature_limit(2,1,limitTemperature);
1272:  MOVLW  02
1273:  MOVWF  74
1274:  MOVLW  01
1275:  MOVWF  75
1276:  CLRF   7C
1277:  MOVF   2D,W
1278:  MOVWF  7B
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
*
12A7:  MOVLW  01
12A8:  MOVWF  74
12A9:  MOVLW  33
12AA:  MOVWF  75
12AB:  BCF    0A.4
12AC:  CALL   7D5
12AD:  BSF    0A.4
12AE:  MOVF   78,F
12AF:  BTFSC  03.2
12B0:  GOTO   2B2
12B1:  CLRF   38
....................          
....................          break;
12B2:  GOTO   719
....................       case 2:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
12B3:  MOVLW  08
12B4:  MOVWF  74
12B5:  BCF    0A.4
12B6:  CALL   167
12B7:  BSF    0A.4
.................... 
.................... //!
....................          lcd_setCursor(1,0);
12B8:  MOVLW  01
12B9:  BSF    03.5
12BA:  MOVWF  34
12BB:  CLRF   35
12BC:  BCF    0A.4
12BD:  BCF    03.5
12BE:  CALL   313
12BF:  BSF    0A.4
....................          lcd_data("cai dat dong ho");
12C0:  MOVLW  DB
12C1:  BSF    03.6
12C2:  MOVWF  0D
12C3:  MOVLW  00
12C4:  MOVWF  0F
12C5:  BCF    0A.4
12C6:  BCF    03.6
12C7:  CALL   34F
12C8:  BSF    0A.4
....................          if(bdn < 5){
12C9:  MOVF   31,W
12CA:  SUBLW  04
12CB:  BTFSS  03.0
12CC:  GOTO   4DF
....................             if(gt_mod != 0) xu_ly_choptat();
12CD:  MOVF   33,F
12CE:  BTFSC  03.2
12CF:  GOTO   2D5
12D0:  BCF    0A.4
12D1:  BSF    0A.3
12D2:  CALL   000
12D3:  BSF    0A.4
12D4:  BCF    0A.3
....................             phim_chon_hthi_mode();
....................             phim_up();
....................             phim_dw();
....................          }
*
14DE:  GOTO   4F7
....................          else if(bdn >= 10){
14DF:  MOVF   31,W
14E0:  SUBLW  09
14E1:  BTFSC  03.0
14E2:  GOTO   4F7
....................             bdn = 0;
14E3:  CLRF   31
....................             if(tg_chinh < 20) tg_chinh++;
14E4:  BTFSC  34.7
14E5:  GOTO   4EA
14E6:  MOVF   34,W
14E7:  SUBLW  13
14E8:  BTFSS  03.0
14E9:  GOTO   4EC
14EA:  INCF   34,F
14EB:  GOTO   4F1
....................             else{
....................                gt_mod = 0; tt_ht = 0;
14EC:  CLRF   33
14ED:  CLRF   32
....................                e_11 = true; e_22 = true; e_33 = true;
14EE:  BSF    2C.2
14EF:  BSF    2C.3
14F0:  BSF    2C.4
....................             }
....................             if(giay_tam!=giay_ds){
14F1:  MOVF   6B,W
14F2:  SUBWF  30,W
14F3:  BTFSC  03.2
14F4:  GOTO   4F7
....................                giay_tam = giay_ds;
14F5:  MOVF   6B,W
14F6:  MOVWF  30
....................             }
....................          }
....................          giai_ma_gpg_ntn_thu_lcd();
14F7:  BCF    0A.4
14F8:  BSF    0A.3
14F9:  CALL   0DA
14FA:  BSF    0A.4
14FB:  BCF    0A.3
....................          log_mode();
....................          break;
*
157B:  GOTO   719
....................       case 3:
....................          lcd_setCursor(1,0);
157C:  MOVLW  01
157D:  BSF    03.5
157E:  MOVWF  34
157F:  CLRF   35
1580:  BCF    0A.4
1581:  BCF    03.5
1582:  CALL   313
1583:  BSF    0A.4
....................          lcd_data("t/g cho ca an");
1584:  MOVLW  E3
1585:  BSF    03.6
1586:  MOVWF  0D
1587:  MOVLW  00
1588:  MOVWF  0F
1589:  BCF    0A.4
158A:  BCF    03.6
158B:  CALL   34F
158C:  BSF    0A.4
....................          if(bdn < 5){
158D:  MOVF   31,W
158E:  SUBLW  04
158F:  BTFSS  03.0
1590:  GOTO   65B
....................             if(gt_mod != 0) xu_ly_choptat();
1591:  MOVF   33,F
1592:  BTFSC  03.2
1593:  GOTO   599
1594:  BCF    0A.4
1595:  BSF    0A.3
1596:  CALL   000
1597:  BSF    0A.4
1598:  BCF    0A.3
....................             phim_chon_mode_alarm();
....................             phim_up_eat();
....................             phim_dw_eat();
....................          }
*
165A:  GOTO   66C
....................          else if(bdn >= 10){
165B:  MOVF   31,W
165C:  SUBLW  09
165D:  BTFSC  03.0
165E:  GOTO   66C
....................             bdn = 0;
165F:  CLRF   31
....................             if(tg_chinh < 20) tg_chinh++;
1660:  BTFSC  34.7
1661:  GOTO   666
1662:  MOVF   34,W
1663:  SUBLW  13
1664:  BTFSS  03.0
1665:  GOTO   668
1666:  INCF   34,F
1667:  GOTO   66C
....................             else{
....................                gt_mod = 0;
1668:  CLRF   33
....................                e_11 = true; e_22 = true; e_33 = true;
1669:  BSF    2C.2
166A:  BSF    2C.3
166B:  BSF    2C.4
....................             }
....................          }
....................          giai_ma_gpg_alarm_lcd();
166C:  BCF    0A.4
166D:  BSF    0A.3
166E:  CALL   17D
166F:  BSF    0A.4
1670:  BCF    0A.3
....................          log_mode_alarm();
....................          break;
*
16B4:  GOTO   719
....................       case 4:
....................          lcd_setCursor(1,0);
16B5:  MOVLW  01
16B6:  BSF    03.5
16B7:  MOVWF  34
16B8:  CLRF   35
16B9:  BCF    0A.4
16BA:  BCF    03.5
16BB:  CALL   313
16BC:  BSF    0A.4
....................          lcd_data("check com esp");
16BD:  MOVLW  EA
16BE:  BSF    03.6
16BF:  MOVWF  0D
16C0:  MOVLW  00
16C1:  MOVWF  0F
16C2:  BCF    0A.4
16C3:  BCF    03.6
16C4:  CALL   34F
16C5:  BSF    0A.4
....................          lcd_setCursor(1,1);
16C6:  MOVLW  01
16C7:  BSF    03.5
16C8:  MOVWF  34
16C9:  MOVWF  35
16CA:  BCF    0A.4
16CB:  BCF    03.5
16CC:  CALL   313
16CD:  BSF    0A.4
....................          lcd_data(indexComplete + 0x30);
16CE:  MOVLW  30
16CF:  ADDWF  56,W
16D0:  MOVWF  74
16D1:  BSF    03.5
16D2:  MOVWF  37
16D3:  BCF    0A.4
16D4:  BCF    03.5
16D5:  CALL   332
16D6:  BSF    0A.4
....................          if (stringComplete) {
16D7:  MOVF   55,F
16D8:  BTFSC  03.2
16D9:  GOTO   6DF
....................             stringComplete = 0;
16DA:  CLRF   55
....................             index = 0;
16DB:  CLRF   54
....................             lcd_clear();
16DC:  BCF    0A.4
16DD:  CALL   25E
16DE:  BSF    0A.4
.................... 
.................... //!            if(!strncmp(ledon, receivedString, 2)){
.................... //!               output_bit(ledTest,1);
.................... //!            }
.................... //!            else{
.................... //!               output_bit(ledTest,0);
.................... //!            }
....................          }
....................          if(tick_btn(1,bt3)) countLevel = 0;
16DF:  MOVLW  01
16E0:  MOVWF  74
16E1:  MOVLW  33
16E2:  MOVWF  75
16E3:  BCF    0A.4
16E4:  CALL   7D5
16E5:  BSF    0A.4
16E6:  MOVF   78,F
16E7:  BTFSC  03.2
16E8:  GOTO   6EA
16E9:  CLRF   38
....................          break;
16EA:  GOTO   719
....................       default:
....................          lcd_setCursor(2,0);
16EB:  MOVLW  02
16EC:  BSF    03.5
16ED:  MOVWF  34
16EE:  CLRF   35
16EF:  BCF    0A.4
16F0:  BCF    03.5
16F1:  CALL   313
16F2:  BSF    0A.4
....................          lcd_data("Information");
16F3:  MOVLW  F1
16F4:  BSF    03.6
16F5:  MOVWF  0D
16F6:  MOVLW  00
16F7:  MOVWF  0F
16F8:  BCF    0A.4
16F9:  BCF    03.6
16FA:  CALL   34F
16FB:  BSF    0A.4
....................          lcd_setCursor(0,1);
16FC:  BSF    03.5
16FD:  CLRF   34
16FE:  MOVLW  01
16FF:  MOVWF  35
1700:  BCF    0A.4
1701:  BCF    03.5
1702:  CALL   313
1703:  BSF    0A.4
....................          lcd_data("Version: V1.0.0");
1704:  MOVLW  F7
1705:  BSF    03.6
1706:  MOVWF  0D
1707:  MOVLW  00
1708:  MOVWF  0F
1709:  BCF    0A.4
170A:  BCF    03.6
170B:  CALL   34F
170C:  BSF    0A.4
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
170D:  MOVLW  01
170E:  MOVWF  74
170F:  MOVLW  33
1710:  MOVWF  75
1711:  BCF    0A.4
1712:  CALL   7D5
1713:  BSF    0A.4
1714:  MOVF   78,F
1715:  BTFSC  03.2
1716:  GOTO   718
1717:  CLRF   38
....................          break;
1718:  GOTO   719
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void loop(){
.................... //! function to access for change limit temperature, change time for time rtc, change time clock for eat fish, check com with esp, log version sys
....................    menu();
.................... }
.................... 
.................... void main(){
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2B
1005:  BSF    2B.3
1006:  MOVF   2B,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2B.4
100B:  MOVF   2B,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  31
100F:  MOVWF  13
1010:  MOVLW  28
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    14.7
1015:  BCF    14.6
1016:  MOVLW  81
1017:  MOVWF  19
1018:  MOVLW  A6
1019:  MOVWF  18
101A:  MOVLW  90
101B:  BCF    03.5
101C:  MOVWF  18
101D:  BCF    2C.0
101E:  BCF    2C.1
101F:  MOVLW  19
1020:  MOVWF  2D
1021:  CLRF   32
1022:  CLRF   33
1023:  CLRF   34
1024:  CLRF   38
1025:  CLRF   39
1026:  CLRF   3A
1027:  CLRF   54
1028:  CLRF   55
1029:  CLRF   56
102A:  CLRF   58
102B:  CLRF   57
102C:  CLRF   59
102D:  CLRF   5A
102E:  BSF    03.5
102F:  BSF    1F.0
1030:  BSF    1F.1
1031:  BSF    1F.2
1032:  BCF    1F.3
1033:  MOVLW  07
1034:  MOVWF  1C
1035:  BCF    03.7
.................... 
.................... //! setup enviroments
....................    setup_initialize();
*
105C:  BCF    0A.4
105D:  GOTO   10B
105E:  BSF    0A.4
....................    
.................... //! setup ds1307 rtc
....................    ds1307_setup();
105F:  BCF    0A.4
1060:  GOTO   195
1061:  BSF    0A.4
.................... 
.................... //! setup lcd display
....................    lcd_setup();
1062:  BCF    0A.4
1063:  GOTO   267
1064:  BSF    0A.4
.................... 
.................... //! setup servo initialize is 0 degree
....................    servo_degree_0();
1065:  BCF    0A.4
1066:  CALL   2ED
1067:  BSF    0A.4
.................... 
.................... //! display info include: name project and name university
....................    log_lcd_initialize();
1068:  BCF    0A.4
1069:  GOTO   3C3
106A:  BSF    0A.4
....................    
....................    printf("Hello from PIC16F877A!");
106B:  MOVLW  FF
106C:  BSF    03.6
106D:  MOVWF  0D
106E:  MOVLW  00
106F:  MOVWF  0F
1070:  BCF    0A.4
1071:  BCF    03.6
1072:  CALL   3E9
1073:  BSF    0A.4
....................    
....................    while(true){
.................... //! loop function is function suport in process of system
....................       loop();
*
1719:  GOTO   074
....................    }
.................... }
171A:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
