CCS PCM C Compiler, Version 5.115, 43599               10-Jun-24 22:04

               Filename:   E:\STUDY\HKII-2023-2024\DO_AN_1\PROJECT\CODE_FINNAL\main.lst

               ROM used:   4604 words (56%)
                           Largest free fragment is 2048
               RAM used:   91 (25%) at main() level
                           142 (39%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   054
002D:  MOVLW  8C
002E:  MOVWF  04
002F:  BTFSS  00.0
0030:  GOTO   033
0031:  BTFSC  0C.0
0032:  GOTO   057
0033:  MOVF   22,W
0034:  MOVWF  04
0035:  MOVF   23,W
0036:  MOVWF  77
0037:  MOVF   24,W
0038:  MOVWF  78
0039:  MOVF   25,W
003A:  MOVWF  79
003B:  MOVF   26,W
003C:  MOVWF  7A
003D:  MOVF   27,W
003E:  BSF    03.6
003F:  MOVWF  0D
0040:  BCF    03.6
0041:  MOVF   28,W
0042:  BSF    03.6
0043:  MOVWF  0F
0044:  BCF    03.6
0045:  MOVF   29,W
0046:  BSF    03.6
0047:  MOVWF  0C
0048:  BCF    03.6
0049:  MOVF   2A,W
004A:  BSF    03.6
004B:  MOVWF  0E
004C:  BCF    03.6
004D:  MOVF   20,W
004E:  MOVWF  0A
004F:  SWAPF  21,W
0050:  MOVWF  03
0051:  SWAPF  7F,F
0052:  SWAPF  7F,W
0053:  RETFIE
0054:  BCF    0A.3
0055:  BCF    0A.4
0056:  GOTO   05A
0057:  BCF    0A.3
0058:  BCF    0A.4
0059:  GOTO   08F
.................... #include <library_project.c>
.................... /*
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
....................                        SU PHAM KY THUAT - TP.HCM
....................  DO AN 1 - HIEU CHINH NHIET DO HO CA VA CHO CA AN TU DONG - KET NOI ESP
.................... 
....................    THANH VIEN:
....................       VO MINH THUAN   - 21161366
....................       LE QUANG THUONG - 21161367
.................... xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
.................... */
.................... #include <define_pic16f.c>
.................... //! config mode to operation of pic16f877a
.................... #include <16f877a.h>
.................... //////////// Standard Header file for the PIC16F877A device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877A
*
008C:  DATA F3,39
008D:  DATA BA,37
008E:  DATA 6B,00
*
00C2:  DATA C4,37
00C3:  DATA A0,30
00C4:  DATA 6E,10
00C5:  DATA 31,10
00C6:  DATA 2D,10
00C7:  DATA C8,25
00C8:  DATA C9,24
00C9:  DATA 00,00
00CA:  DATA 53,28
00CB:  DATA 4B,2A
00CC:  DATA 2D,2A
00CD:  DATA 50,24
00CE:  DATA C3,26
00CF:  DATA 00,00
00D0:  DATA 2D,00
00D1:  DATA 2D,00
00D2:  DATA 2E,00
00D3:  DATA 2E,00
00D4:  DATA 4E,22
00D5:  DATA 3A,10
00D6:  DATA 00,01
00D7:  DATA A0,37
00D8:  DATA 43,00
00D9:  DATA 4E,22
00DA:  DATA AD,23
00DB:  DATA 48,1D
00DC:  DATA 20,00
00DD:  DATA A0,37
00DE:  DATA 43,00
00DF:  DATA 20,27
00E0:  DATA 20,00
00E1:  DATA 47,28
00E2:  DATA 47,00
00E3:  DATA 4E,2A
00E4:  DATA 4E,00
00E5:  DATA 20,2A
00E6:  DATA 20,00
00E7:  DATA DF,2F
00E8:  DATA 00,00
00E9:  DATA DF,2F
00EA:  DATA 00,00
00EB:  DATA 64,3A
00EC:  DATA 3A,39
00ED:  DATA 74,1D
00EE:  DATA 00,10
00EF:  DATA 64,3A
00F0:  DATA 3A,36
00F1:  DATA 74,1D
00F2:  DATA 00,01
00F3:  DATA 64,3A
00F4:  DATA 3A,39
00F5:  DATA 61,1D
00F6:  DATA 00,01
00F7:  DATA 64,3A
00F8:  DATA 3A,39
00F9:  DATA 63,1D
00FA:  DATA 00,01
00FB:  DATA E3,30
00FC:  DATA 69,10
00FD:  DATA E4,30
00FE:  DATA 74,10
00FF:  DATA E4,37
0100:  DATA EE,33
0101:  DATA 20,34
0102:  DATA 6F,00
0103:  DATA F4,17
0104:  DATA 67,10
0105:  DATA 63,34
0106:  DATA 6F,10
0107:  DATA E3,30
0108:  DATA A0,30
0109:  DATA 6E,00
010A:  DATA 63,34
010B:  DATA E5,31
010C:  DATA 6B,10
010D:  DATA E3,37
010E:  DATA 6D,10
010F:  DATA E5,39
0110:  DATA 70,00
0111:  DATA 49,37
0112:  DATA E6,37
0113:  DATA F2,36
0114:  DATA 61,3A
0115:  DATA E9,37
0116:  DATA 6E,00
0117:  DATA D6,32
0118:  DATA F2,39
0119:  DATA E9,37
011A:  DATA 6E,1D
011B:  DATA 20,2B
011C:  DATA 31,17
011D:  DATA 30,17
011E:  DATA 30,00
011F:  DATA C8,32
0120:  DATA 6C,36
0121:  DATA 6F,10
0122:  DATA 66,39
0123:  DATA EF,36
0124:  DATA 20,28
0125:  DATA C9,21
0126:  DATA 31,1B
0127:  DATA 46,1C
0128:  DATA B7,1B
0129:  DATA C1,10
012A:  DATA 00,00
*
0353:  MOVF   0B,W
0354:  BSF    03.5
0355:  MOVWF  35
0356:  BCF    03.5
0357:  BCF    0B.7
0358:  BSF    03.5
0359:  BSF    03.6
035A:  BSF    0C.7
035B:  BSF    0C.0
035C:  NOP
035D:  NOP
035E:  BCF    03.6
035F:  BTFSS  35.7
0360:  GOTO   364
0361:  BCF    03.5
0362:  BSF    0B.7
0363:  BSF    03.5
0364:  BCF    03.5
0365:  BSF    03.6
0366:  MOVF   0C,W
0367:  ANDLW  7F
0368:  BTFSC  03.2
0369:  GOTO   3C5
036A:  BSF    03.5
036B:  BCF    03.6
036C:  MOVWF  35
036D:  BCF    03.5
036E:  BSF    03.6
036F:  MOVF   0D,W
0370:  BSF    03.5
0371:  BCF    03.6
0372:  MOVWF  36
0373:  BCF    03.5
0374:  BSF    03.6
0375:  MOVF   0F,W
0376:  BSF    03.5
0377:  BCF    03.6
0378:  MOVWF  37
0379:  MOVF   35,W
037A:  MOVWF  38
037B:  BCF    03.5
037C:  CALL   336
037D:  BSF    03.5
037E:  MOVF   36,W
037F:  BCF    03.5
0380:  BSF    03.6
0381:  MOVWF  0D
0382:  BSF    03.5
0383:  BCF    03.6
0384:  MOVF   37,W
0385:  BCF    03.5
0386:  BSF    03.6
0387:  MOVWF  0F
0388:  BCF    03.6
0389:  MOVF   0B,W
038A:  BSF    03.5
038B:  MOVWF  38
038C:  BCF    03.5
038D:  BCF    0B.7
038E:  BSF    03.5
038F:  BSF    03.6
0390:  BSF    0C.7
0391:  BSF    0C.0
0392:  NOP
0393:  NOP
0394:  BCF    03.6
0395:  BTFSS  38.7
0396:  GOTO   39A
0397:  BCF    03.5
0398:  BSF    0B.7
0399:  BSF    03.5
039A:  BCF    03.5
039B:  BSF    03.6
039C:  RLF    0C,W
039D:  RLF    0E,W
039E:  ANDLW  7F
039F:  BTFSC  03.2
03A0:  GOTO   3C5
03A1:  BSF    03.5
03A2:  BCF    03.6
03A3:  MOVWF  35
03A4:  BCF    03.5
03A5:  BSF    03.6
03A6:  MOVF   0D,W
03A7:  BSF    03.5
03A8:  BCF    03.6
03A9:  MOVWF  36
03AA:  BCF    03.5
03AB:  BSF    03.6
03AC:  MOVF   0F,W
03AD:  BSF    03.5
03AE:  BCF    03.6
03AF:  MOVWF  37
03B0:  MOVF   35,W
03B1:  MOVWF  38
03B2:  BCF    03.5
03B3:  CALL   336
03B4:  BSF    03.5
03B5:  MOVF   36,W
03B6:  BCF    03.5
03B7:  BSF    03.6
03B8:  MOVWF  0D
03B9:  BSF    03.5
03BA:  BCF    03.6
03BB:  MOVF   37,W
03BC:  BCF    03.5
03BD:  BSF    03.6
03BE:  MOVWF  0F
03BF:  INCF   0D,F
03C0:  BTFSC  03.2
03C1:  INCF   0F,F
03C2:  BCF    03.6
03C3:  GOTO   353
03C4:  BSF    03.6
03C5:  BCF    03.6
03C6:  RETURN
*
03ED:  MOVF   0B,W
03EE:  BSF    03.5
03EF:  MOVWF  20
03F0:  BCF    03.5
03F1:  BCF    0B.7
03F2:  BSF    03.5
03F3:  BSF    03.6
03F4:  BSF    0C.7
03F5:  BSF    0C.0
03F6:  NOP
03F7:  NOP
03F8:  BCF    03.6
03F9:  BTFSS  20.7
03FA:  GOTO   3FE
03FB:  BCF    03.5
03FC:  BSF    0B.7
03FD:  BSF    03.5
03FE:  BCF    03.5
03FF:  BSF    03.6
0400:  MOVF   0C,W
0401:  ANDLW  7F
0402:  BTFSC  03.2
0403:  GOTO   461
0404:  BSF    03.5
0405:  BCF    03.6
0406:  MOVWF  20
0407:  BCF    03.5
0408:  BSF    03.6
0409:  MOVF   0D,W
040A:  BSF    03.5
040B:  BCF    03.6
040C:  MOVWF  21
040D:  BCF    03.5
040E:  BSF    03.6
040F:  MOVF   0F,W
0410:  BSF    03.5
0411:  BCF    03.6
0412:  MOVWF  22
0413:  MOVF   20,W
0414:  BCF    03.5
0415:  BTFSS  0C.4
0416:  GOTO   415
0417:  MOVWF  19
0418:  BSF    03.5
0419:  MOVF   21,W
041A:  BCF    03.5
041B:  BSF    03.6
041C:  MOVWF  0D
041D:  BSF    03.5
041E:  BCF    03.6
041F:  MOVF   22,W
0420:  BCF    03.5
0421:  BSF    03.6
0422:  MOVWF  0F
0423:  BCF    03.6
0424:  MOVF   0B,W
0425:  BSF    03.5
0426:  MOVWF  23
0427:  BCF    03.5
0428:  BCF    0B.7
0429:  BSF    03.5
042A:  BSF    03.6
042B:  BSF    0C.7
042C:  BSF    0C.0
042D:  NOP
042E:  NOP
042F:  BCF    03.6
0430:  BTFSS  23.7
0431:  GOTO   435
0432:  BCF    03.5
0433:  BSF    0B.7
0434:  BSF    03.5
0435:  BCF    03.5
0436:  BSF    03.6
0437:  RLF    0C,W
0438:  RLF    0E,W
0439:  ANDLW  7F
043A:  BTFSC  03.2
043B:  GOTO   461
043C:  BSF    03.5
043D:  BCF    03.6
043E:  MOVWF  20
043F:  BCF    03.5
0440:  BSF    03.6
0441:  MOVF   0D,W
0442:  BSF    03.5
0443:  BCF    03.6
0444:  MOVWF  21
0445:  BCF    03.5
0446:  BSF    03.6
0447:  MOVF   0F,W
0448:  BSF    03.5
0449:  BCF    03.6
044A:  MOVWF  22
044B:  MOVF   20,W
044C:  BCF    03.5
044D:  BTFSS  0C.4
044E:  GOTO   44D
044F:  MOVWF  19
0450:  BSF    03.5
0451:  MOVF   21,W
0452:  BCF    03.5
0453:  BSF    03.6
0454:  MOVWF  0D
0455:  BSF    03.5
0456:  BCF    03.6
0457:  MOVF   22,W
0458:  BCF    03.5
0459:  BSF    03.6
045A:  MOVWF  0F
045B:  INCF   0D,F
045C:  BTFSC  03.2
045D:  INCF   0F,F
045E:  BCF    03.6
045F:  GOTO   3ED
0460:  BSF    03.6
0461:  BCF    03.6
0462:  RETURN
0463:  MOVF   7D,W
0464:  ANDLW  07
0465:  MOVWF  77
0466:  RRF    7D,W
0467:  MOVWF  78
0468:  RRF    78,F
0469:  RRF    78,F
046A:  MOVLW  1F
046B:  ANDWF  78,F
046C:  MOVF   78,W
046D:  BSF    03.5
046E:  ADDWF  20,W
046F:  MOVWF  04
0470:  BCF    03.7
0471:  BTFSC  21.0
0472:  BSF    03.7
0473:  MOVF   00,W
0474:  MOVWF  78
0475:  INCF   77,F
0476:  GOTO   478
0477:  RRF    78,F
0478:  DECFSZ 77,F
0479:  GOTO   477
047A:  MOVLW  01
047B:  ANDWF  78,F
047C:  BCF    03.5
047D:  RETURN
*
050D:  CLRF   78
050E:  CLRF   79
050F:  CLRF   77
0510:  CLRF   7A
0511:  BSF    03.5
0512:  MOVF   32,W
0513:  BTFSS  03.2
0514:  GOTO   518
0515:  MOVF   31,W
0516:  BTFSC  03.2
0517:  GOTO   532
0518:  MOVLW  10
0519:  MOVWF  33
051A:  BCF    03.0
051B:  RLF    2F,F
051C:  RLF    30,F
051D:  RLF    77,F
051E:  RLF    7A,F
051F:  MOVF   32,W
0520:  SUBWF  7A,W
0521:  BTFSS  03.2
0522:  GOTO   525
0523:  MOVF   31,W
0524:  SUBWF  77,W
0525:  BTFSS  03.0
0526:  GOTO   52E
0527:  MOVF   31,W
0528:  SUBWF  77,F
0529:  BTFSS  03.0
052A:  DECF   7A,F
052B:  MOVF   32,W
052C:  SUBWF  7A,F
052D:  BSF    03.0
052E:  RLF    78,F
052F:  RLF    79,F
0530:  DECFSZ 33,F
0531:  GOTO   51A
0532:  BCF    03.5
0533:  RETURN
*
05BD:  MOVLW  10
05BE:  BSF    03.5
05BF:  MOVWF  20
05C0:  CLRF   77
05C1:  CLRF   7A
05C2:  RRF    7C,F
05C3:  RRF    7B,F
05C4:  BTFSS  03.0
05C5:  GOTO   5CC
05C6:  MOVF   7D,W
05C7:  ADDWF  77,F
05C8:  BTFSC  03.0
05C9:  INCF   7A,F
05CA:  MOVF   7E,W
05CB:  ADDWF  7A,F
05CC:  RRF    7A,F
05CD:  RRF    77,F
05CE:  RRF    79,F
05CF:  RRF    78,F
05D0:  DECFSZ 20,F
05D1:  GOTO   5C2
*
05E6:  CLRF   77
05E7:  CLRF   78
05E8:  BSF    03.5
05E9:  MOVF   26,W
05EA:  BCF    03.0
05EB:  BTFSC  27.0
05EC:  ADDWF  77,F
05ED:  RRF    77,F
05EE:  RRF    78,F
05EF:  BTFSC  27.1
05F0:  ADDWF  77,F
05F1:  RRF    77,F
05F2:  RRF    78,F
05F3:  BTFSC  27.2
05F4:  ADDWF  77,F
05F5:  RRF    77,F
05F6:  RRF    78,F
05F7:  BTFSC  27.3
05F8:  ADDWF  77,F
05F9:  RRF    77,F
05FA:  RRF    78,F
05FB:  BTFSC  27.4
05FC:  ADDWF  77,F
05FD:  RRF    77,F
05FE:  RRF    78,F
05FF:  BTFSC  27.5
0600:  ADDWF  77,F
0601:  RRF    77,F
0602:  RRF    78,F
0603:  BTFSC  27.6
0604:  ADDWF  77,F
0605:  RRF    77,F
0606:  RRF    78,F
0607:  BTFSC  27.7
0608:  ADDWF  77,F
0609:  RRF    77,F
060A:  RRF    78,F
060B:  BCF    03.5
060C:  RETURN
*
0622:  BSF    03.5
0623:  MOVF   36,W
0624:  CLRF   78
0625:  SUBWF  35,W
0626:  BTFSC  03.0
0627:  GOTO   62B
0628:  MOVF   35,W
0629:  MOVWF  77
062A:  GOTO   637
062B:  CLRF   77
062C:  MOVLW  08
062D:  MOVWF  37
062E:  RLF    35,F
062F:  RLF    77,F
0630:  MOVF   36,W
0631:  SUBWF  77,W
0632:  BTFSC  03.0
0633:  MOVWF  77
0634:  RLF    78,F
0635:  DECFSZ 37,F
0636:  GOTO   62E
0637:  BCF    03.5
0638:  RETURN
*
0800:  MOVLW  20
0801:  BSF    03.5
0802:  BTFSS  20.4
0803:  MOVLW  30
0804:  MOVWF  21
0805:  MOVF   7E,W
0806:  MOVWF  77
0807:  BTFSS  7E.7
0808:  GOTO   011
0809:  COMF   77,F
080A:  INCF   77,F
080B:  MOVF   77,W
080C:  MOVWF  7E
080D:  MOVLW  2D
080E:  MOVWF  21
080F:  BSF    20.7
0810:  BSF    20.0
0811:  MOVF   7E,W
0812:  MOVWF  35
0813:  MOVLW  64
0814:  MOVWF  36
0815:  BCF    0A.3
0816:  BCF    03.5
0817:  CALL   622
0818:  BSF    0A.3
0819:  MOVF   77,W
081A:  MOVWF  7E
081B:  MOVLW  30
081C:  ADDWF  78,W
081D:  BSF    03.5
081E:  MOVWF  22
081F:  MOVF   7E,W
0820:  MOVWF  35
0821:  MOVLW  0A
0822:  MOVWF  36
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   622
0826:  BSF    0A.3
0827:  MOVLW  30
0828:  ADDWF  77,W
0829:  BSF    03.5
082A:  MOVWF  24
082B:  MOVLW  30
082C:  ADDWF  78,W
082D:  MOVWF  23
082E:  MOVF   21,W
082F:  MOVWF  77
0830:  MOVLW  30
0831:  SUBWF  22,W
0832:  BTFSC  03.2
0833:  GOTO   038
0834:  BSF    20.1
0835:  BTFSC  20.7
0836:  BSF    20.2
0837:  GOTO   04C
0838:  MOVF   21,W
0839:  MOVWF  22
083A:  MOVLW  20
083B:  MOVWF  21
083C:  MOVLW  30
083D:  SUBWF  23,W
083E:  BTFSC  03.2
083F:  GOTO   044
0840:  BSF    20.0
0841:  BTFSC  20.7
0842:  BSF    20.1
0843:  GOTO   04C
0844:  BTFSS  03.2
0845:  BSF    20.0
0846:  BTFSS  03.2
0847:  GOTO   04C
0848:  MOVF   22,W
0849:  MOVWF  23
084A:  MOVLW  20
084B:  MOVWF  22
084C:  BTFSC  20.2
084D:  GOTO   053
084E:  BTFSC  20.1
084F:  GOTO   059
0850:  BTFSC  20.0
0851:  GOTO   05F
0852:  GOTO   065
0853:  MOVF   21,W
0854:  BCF    03.5
0855:  BTFSS  0C.4
0856:  GOTO   055
0857:  MOVWF  19
0858:  BSF    03.5
0859:  MOVF   22,W
085A:  BCF    03.5
085B:  BTFSS  0C.4
085C:  GOTO   05B
085D:  MOVWF  19
085E:  BSF    03.5
085F:  MOVF   23,W
0860:  BCF    03.5
0861:  BTFSS  0C.4
0862:  GOTO   061
0863:  MOVWF  19
0864:  BSF    03.5
0865:  MOVF   24,W
0866:  BCF    03.5
0867:  BTFSS  0C.4
0868:  GOTO   067
0869:  MOVWF  19
086A:  RETURN
*
09C5:  MOVF   7B,W
09C6:  XORWF  7C,W
09C7:  ANDLW  80
09C8:  MOVWF  7E
09C9:  BTFSS  7B.7
09CA:  GOTO   1CD
09CB:  COMF   7B,F
09CC:  INCF   7B,F
09CD:  BTFSS  7C.7
09CE:  GOTO   1D1
09CF:  COMF   7C,F
09D0:  INCF   7C,F
09D1:  MOVF   7C,W
09D2:  CLRF   78
09D3:  SUBWF  7B,W
09D4:  BTFSC  03.0
09D5:  GOTO   1D9
09D6:  MOVF   7B,W
09D7:  MOVWF  77
09D8:  GOTO   1E5
09D9:  CLRF   77
09DA:  MOVLW  08
09DB:  MOVWF  7D
09DC:  RLF    7B,F
09DD:  RLF    77,F
09DE:  MOVF   7C,W
09DF:  SUBWF  77,W
09E0:  BTFSC  03.0
09E1:  MOVWF  77
09E2:  RLF    78,F
09E3:  DECFSZ 7D,F
09E4:  GOTO   1DC
09E5:  BTFSS  7E.7
09E6:  GOTO   1E9
09E7:  COMF   78,F
09E8:  INCF   78,F
09E9:  RETURN
.................... 
.................... #list
.................... 
.................... #device  adc=10
.................... #fuses   hs, nowdt, put, noprotect, nolvp
.................... #use     delay(clock=20MHz) 
*
01E0:  MOVLW  7C
01E1:  MOVWF  04
01E2:  BCF    03.7
01E3:  MOVF   00,W
01E4:  BTFSC  03.2
01E5:  GOTO   1F3
01E6:  MOVLW  06
01E7:  MOVWF  78
01E8:  CLRF   77
01E9:  DECFSZ 77,F
01EA:  GOTO   1E9
01EB:  DECFSZ 78,F
01EC:  GOTO   1E8
01ED:  MOVLW  7B
01EE:  MOVWF  77
01EF:  DECFSZ 77,F
01F0:  GOTO   1EF
01F1:  DECFSZ 00,F
01F2:  GOTO   1E6
01F3:  RETURN
*
02EB:  MOVLW  03
02EC:  BSF    03.5
02ED:  SUBWF  23,F
02EE:  BTFSS  03.0
02EF:  GOTO   2FA
02F0:  MOVLW  A3
02F1:  MOVWF  04
02F2:  BCF    03.7
02F3:  MOVF   00,W
02F4:  BTFSC  03.2
02F5:  GOTO   2FA
02F6:  GOTO   2F8
02F7:  GOTO   2F8
02F8:  DECFSZ 00,F
02F9:  GOTO   2F7
02FA:  BCF    03.5
02FB:  RETURN
.................... #use     i2c(master,slow,sda=pin_c4,scl=pin_c3)
*
0154:  BCF    14.7
0155:  BCF    0C.3
0156:  BSF    03.5
0157:  MOVF   48,W
0158:  BCF    03.5
0159:  MOVWF  13
015A:  MOVLW  02
015B:  BTFSC  14.7
015C:  GOTO   164
015D:  BSF    03.5
015E:  BTFSC  14.2
015F:  GOTO   15E
0160:  MOVLW  00
0161:  BTFSC  11.6
0162:  MOVLW  01
0163:  BCF    03.5
0164:  MOVWF  78
0165:  RETURN
0166:  BCF    14.6
0167:  BSF    03.5
0168:  BSF    11.3
0169:  BTFSC  11.3
016A:  GOTO   169
016B:  BTFSC  77.0
016C:  BCF    11.5
016D:  BTFSS  77.0
016E:  BSF    11.5
016F:  BSF    11.4
0170:  BTFSC  11.4
0171:  GOTO   170
0172:  BCF    03.5
0173:  MOVF   13,W
0174:  MOVWF  78
0175:  RETURN
.................... #use     rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7, bits = 8, stream=UART_STREAM)
.................... #use fast_io(C)
.................... #use fast_io(D)
.................... #use fast_io(E)
.................... #use fast_io(B)
.................... #use fast_io(A)
.................... 
.................... //! define name again to user
.................... #define usi8  unsigned int8
.................... #define usi16 unsigned int16
.................... #define usi32 unsigned int32
.................... #define si8   signed   int8
.................... #define si16  signed   int16
.................... #define si32  signed   int32
.................... #define bool int1
.................... 
.................... //! define variables
.................... bool flag_10ms = false;
.................... bool flag_10s = false;
.................... bool isDs18b20 = false;
.................... 
.................... usi8 limitTemperature = 25;
.................... 
.................... usi16 tick_10ms;
.................... usi16 tick_100ms;
.................... 
.................... usi8 giay_tam, bdn, tt_ht = 0;
.................... si8 gt_mod = 0, tg_chinh = 0;
.................... 
.................... bool e_11, e_22, e_33;
.................... 
.................... usi8 eat_hh, eat_pp, eat_ss;
.................... 
.................... #define maxLevel 6
.................... 
.................... usi8 countLevel = 0;
.................... usi8 countLevelRev = 0;
.................... 
.................... bool flag_servo;
.................... usi8 count_servo = 0;
.................... 
.................... #define tang false
.................... #define giam true
.................... 
.................... //! define available for ds18b20
.................... usi16 temperature;
.................... usi8 dt_ng;
.................... usi16 dt_tp;
.................... usi16 tt;
.................... 
.................... //! define button to use
.................... #ifndef bt0
.................... #define bt0    pin_b0
.................... #endif
.................... 
.................... #ifndef bt1
.................... #define bt1    pin_b1
.................... #endif
.................... 
.................... #ifndef bt2
.................... #define bt2    pin_b2
.................... #endif
.................... 
.................... #ifndef bt3
.................... #define bt3    pin_b3
.................... #endif
.................... 
.................... //! define pin sensors
.................... #define pin_ds18b20 pin_a0
.................... 
.................... //! define pin controls
.................... #ifndef pinServo
.................... #define pinServo    pin_c1
.................... #endif
.................... 
.................... #ifndef pinDLCold
.................... #define pinDLCold     pin_d6
.................... #endif
.................... 
.................... #ifndef pinDLHot
.................... #define pinDLHot      pin_d7
.................... #endif
.................... 
.................... #ifndef ledTest
.................... #define ledTest       pin_b5
.................... #endif
.................... 
.................... #include <library_uart.c>
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
1037:  BCF    03.5
1038:  CLRF   44
1039:  CLRF   45
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... //! define buffer size is 16 byte
.................... #define BUFFER_SIZE 16
.................... 
.................... //! define available for uart buffer
.................... char receivedString[BUFFER_SIZE]="";
103A:  CLRF   46
.................... volatile unsigned int index = 0;
.................... volatile int stringComplete = 0;
.................... volatile unsigned int indexComplete = 0;
.................... 
.................... #int_rda
.................... void read_uart(){
....................    if(kbhit()){
*
005A:  BTFSS  0C.5
005B:  GOTO   086
.................... //!   Read the received character
....................       char receivedChar = getch();  
005C:  BTFSS  0C.5
005D:  GOTO   05C
005E:  MOVF   1A,W
005F:  BSF    03.5
0060:  MOVWF  4B
....................        
....................        if (receivedChar == '\r' || receivedChar == '\n') {
0061:  MOVF   4B,W
0062:  SUBLW  0D
0063:  BTFSC  03.2
0064:  GOTO   069
0065:  MOVF   4B,W
0066:  SUBLW  0A
0067:  BTFSS  03.2
0068:  GOTO   075
.................... //!        End of string (carriage return detected)
....................            receivedString[index] = '\0';  // Null-terminate the string
0069:  MOVLW  46
006A:  BCF    03.5
006B:  ADDWF  56,W
006C:  MOVWF  04
006D:  BCF    03.7
006E:  CLRF   00
....................            indexComplete = index;
006F:  MOVF   56,W
0070:  MOVWF  58
....................            stringComplete = 1;  // Set the flag to indicate string reception complete
0071:  MOVLW  01
0072:  MOVWF  57
....................        } else {
0073:  GOTO   086
0074:  BSF    03.5
....................           // Store the received character
....................            if (index < BUFFER_SIZE - 1) {
0075:  BCF    03.5
0076:  MOVF   56,W
0077:  SUBLW  0E
0078:  BTFSS  03.0
0079:  GOTO   084
....................                receivedString[index++] = receivedChar;
007A:  MOVF   56,W
007B:  INCF   56,F
007C:  ADDLW  46
007D:  MOVWF  04
007E:  BCF    03.7
007F:  BSF    03.5
0080:  MOVF   4B,W
0081:  MOVWF  00
....................            } else {
0082:  GOTO   087
0083:  BCF    03.5
....................                // Handle buffer overflow
....................                index = BUFFER_SIZE - 1;  // Prevent overflow
0084:  MOVLW  0F
0085:  MOVWF  56
0086:  BSF    03.5
....................            }
....................        }
....................    }
0087:  BCF    03.5
0088:  BCF    0C.5
0089:  BCF    0A.3
008A:  BCF    0A.4
008B:  GOTO   033
.................... }
.................... 
.................... usi8 decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
*
07C1:  MOVF   7D,W
07C2:  BSF    03.5
07C3:  MOVWF  35
07C4:  MOVLW  0A
07C5:  MOVWF  36
07C6:  BCF    03.5
07C7:  CALL   622
07C8:  SWAPF  78,W
07C9:  MOVWF  7E
07CA:  MOVLW  F0
07CB:  ANDWF  7E,F
07CC:  MOVF   7D,W
07CD:  BSF    03.5
07CE:  MOVWF  35
07CF:  MOVLW  0A
07D0:  MOVWF  36
07D1:  BCF    03.5
07D2:  CALL   622
07D3:  MOVF   77,W
07D4:  ADDWF  7E,W
07D5:  MOVWF  78
07D6:  RETURN
.................... }
.................... 
.................... void send_ok(){
....................    printf("ss:ok");
*
07B9:  MOVLW  8C
07BA:  BSF    03.6
07BB:  MOVWF  0D
07BC:  MOVLW  00
07BD:  MOVWF  0F
07BE:  BCF    03.6
07BF:  CALL   3ED
07C0:  RETURN
.................... }
.................... 
.................... void handle_uart(){
....................    if (stringComplete) {
*
1191:  MOVF   57,F
1192:  BTFSC  03.2
1193:  GOTO   226
....................       stringComplete = 0;
1194:  CLRF   57
....................       index = 0;
1195:  CLRF   56
....................       indexComplete = 0;
1196:  CLRF   58
....................       if(receivedString[0] == 's' && receivedString[1] == 't' && receivedString[2] == ':'){
1197:  MOVF   46,W
1198:  SUBLW  73
1199:  BTFSS  03.2
119A:  GOTO   1B6
119B:  MOVF   47,W
119C:  SUBLW  74
119D:  BTFSS  03.2
119E:  GOTO   1B6
119F:  MOVF   48,W
11A0:  SUBLW  3A
11A1:  BTFSS  03.2
11A2:  GOTO   1B6
.................... //!      Header for changing temperature found
.................... //!      frame "st:23"
....................          limitTemperature = ((receivedString[3] - '0') * 10) + (receivedString[4] - '0');
11A3:  MOVLW  30
11A4:  SUBWF  49,W
11A5:  MOVWF  7C
11A6:  BSF    03.5
11A7:  MOVWF  26
11A8:  MOVLW  0A
11A9:  MOVWF  27
11AA:  BCF    0A.4
11AB:  BCF    03.5
11AC:  CALL   5E6
11AD:  BSF    0A.4
11AE:  MOVLW  30
11AF:  SUBWF  4A,W
11B0:  ADDWF  78,W
11B1:  MOVWF  2D
....................          send_ok();
11B2:  BCF    0A.4
11B3:  CALL   7B9
11B4:  BSF    0A.4
....................       }
11B5:  GOTO   226
....................       else if(receivedString[0] == 's' && receivedString[1] == 'a' && receivedString[2] == ':'){
11B6:  MOVF   46,W
11B7:  SUBLW  73
11B8:  BTFSS  03.2
11B9:  GOTO   211
11BA:  MOVF   47,W
11BB:  SUBLW  61
11BC:  BTFSS  03.2
11BD:  GOTO   211
11BE:  MOVF   48,W
11BF:  SUBLW  3A
11C0:  BTFSS  03.2
11C1:  GOTO   211
.................... //!      Header for changing alarm settings found
.................... //!      frame "sa:gpg:11-11-11"
....................          if(receivedString[3] == 'g' && receivedString[4] == 'p' && receivedString[5] == 'g'){
11C2:  MOVF   49,W
11C3:  SUBLW  67
11C4:  BTFSS  03.2
11C5:  GOTO   210
11C6:  MOVF   4A,W
11C7:  SUBLW  70
11C8:  BTFSS  03.2
11C9:  GOTO   210
11CA:  MOVF   4B,W
11CB:  SUBLW  67
11CC:  BTFSS  03.2
11CD:  GOTO   210
....................             // Address for changing gpg alarm settings found
....................             eat_hh = decToBcd((receivedString[7] - '0') * 10) + (receivedString[8] - '0');
11CE:  MOVLW  30
11CF:  SUBWF  4D,W
11D0:  MOVWF  7C
11D1:  BSF    03.5
11D2:  MOVWF  26
11D3:  MOVLW  0A
11D4:  MOVWF  27
11D5:  BCF    0A.4
11D6:  BCF    03.5
11D7:  CALL   5E6
11D8:  BSF    0A.4
11D9:  MOVF   78,W
11DA:  MOVWF  7B
11DB:  MOVWF  7D
11DC:  BCF    0A.4
11DD:  CALL   7C1
11DE:  BSF    0A.4
11DF:  MOVLW  30
11E0:  SUBWF  4E,W
11E1:  ADDWF  78,W
11E2:  MOVWF  37
....................             eat_pp = decToBcd((receivedString[10] - '0') * 10) + (receivedString[11] - '0');
11E3:  MOVLW  30
11E4:  SUBWF  50,W
11E5:  MOVWF  7C
11E6:  BSF    03.5
11E7:  MOVWF  26
11E8:  MOVLW  0A
11E9:  MOVWF  27
11EA:  BCF    0A.4
11EB:  BCF    03.5
11EC:  CALL   5E6
11ED:  BSF    0A.4
11EE:  MOVF   78,W
11EF:  MOVWF  7B
11F0:  MOVWF  7D
11F1:  BCF    0A.4
11F2:  CALL   7C1
11F3:  BSF    0A.4
11F4:  MOVLW  30
11F5:  SUBWF  51,W
11F6:  ADDWF  78,W
11F7:  MOVWF  38
....................             eat_ss = decToBcd((receivedString[13] - '0') * 10) + (receivedString[14] - '0');
11F8:  MOVLW  30
11F9:  SUBWF  53,W
11FA:  MOVWF  7C
11FB:  BSF    03.5
11FC:  MOVWF  26
11FD:  MOVLW  0A
11FE:  MOVWF  27
11FF:  BCF    0A.4
1200:  BCF    03.5
1201:  CALL   5E6
1202:  BSF    0A.4
1203:  MOVF   78,W
1204:  MOVWF  7B
1205:  MOVWF  7D
1206:  BCF    0A.4
1207:  CALL   7C1
1208:  BSF    0A.4
1209:  MOVLW  30
120A:  SUBWF  54,W
120B:  ADDWF  78,W
120C:  MOVWF  39
....................             send_ok();
120D:  BCF    0A.4
120E:  CALL   7B9
120F:  BSF    0A.4
....................          }
....................       }
1210:  GOTO   226
....................       else if(receivedString[0] == 'c' && receivedString[1] == 's' && receivedString[2] == ':'){
1211:  MOVF   46,W
1212:  SUBLW  63
1213:  BTFSS  03.2
1214:  GOTO   226
1215:  MOVF   47,W
1216:  SUBLW  73
1217:  BTFSS  03.2
1218:  GOTO   226
1219:  MOVF   48,W
121A:  SUBLW  3A
121B:  BTFSS  03.2
121C:  GOTO   226
.................... //!      Header for controling servo manual
.................... //!      frame "cs:1" -> servo on    
.................... //!      frame "cs:0" -> servo off
....................          flag_servo = receivedString[3] - '0';
121D:  MOVLW  30
121E:  SUBWF  49,W
121F:  MOVWF  78
1220:  BCF    2C.6
1221:  BTFSC  78.0
1222:  BSF    2C.6
....................          send_ok();
1223:  BCF    0A.4
1224:  CALL   7B9
1225:  BSF    0A.4
....................       }
....................    }  
.................... }
.................... 
.................... 
.................... 
.................... #int_timer1
.................... void interrupt_timer1()
.................... {
....................    set_timer1(59286);
*
008F:  CLRF   0E
0090:  MOVLW  E7
0091:  MOVWF  0F
0092:  MOVLW  96
0093:  MOVWF  0E
0094:  NOP
....................    
....................    flag_10ms = !flag_10ms;
0095:  MOVLW  01
0096:  XORWF  2C,F
.................... 
....................    tick_10ms++;
0097:  INCF   2E,F
0098:  BTFSC  03.2
0099:  INCF   2F,F
.................... 
.................... //! when tick_10ms >= 10 --> 100ms
....................    if(tick_10ms >= 10){
009A:  MOVF   2F,F
009B:  BTFSS  03.2
009C:  GOTO   0A1
009D:  MOVF   2E,W
009E:  SUBLW  09
009F:  BTFSC  03.0
00A0:  GOTO   0BE
....................       bdn++;
00A1:  INCF   33,F
....................       tick_10ms = 0;
00A2:  CLRF   2F
00A3:  CLRF   2E
....................       
....................       if(tick_100ms < 100) tick_100ms++;
00A4:  MOVF   31,F
00A5:  BTFSS  03.2
00A6:  GOTO   0AF
00A7:  MOVF   30,W
00A8:  SUBLW  63
00A9:  BTFSS  03.0
00AA:  GOTO   0AF
00AB:  INCF   30,F
00AC:  BTFSC  03.2
00AD:  INCF   31,F
00AE:  GOTO   0B2
....................       else{
....................          tick_100ms = 0;
00AF:  CLRF   31
00B0:  CLRF   30
....................          flag_10s = true;
00B1:  BSF    2C.1
....................       }
....................       
.................... //! disable flag servo on --> flag_servo >> false
....................       if(flag_servo == true){
00B2:  BTFSS  2C.6
00B3:  GOTO   0BD
....................          if(count_servo < 100) count_servo++; // 10s
00B4:  MOVF   3C,W
00B5:  SUBLW  63
00B6:  BTFSS  03.0
00B7:  GOTO   0BA
00B8:  INCF   3C,F
00B9:  GOTO   0BC
....................          else{
....................             count_servo = 0;
00BA:  CLRF   3C
....................             flag_servo = false;
00BB:  BCF    2C.6
....................          }
....................       }
00BC:  GOTO   0BE
....................       else flag_servo = 0;
00BD:  BCF    2C.6
....................    }
00BE:  BCF    0C.0
00BF:  BCF    0A.3
00C0:  BCF    0A.4
00C1:  GOTO   033
.................... }
.................... 
.................... void setup_initialize(){
.................... //! set up timer 1 to timer count is 10ms of one cycle
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);
*
012B:  MOVLW  B5
012C:  MOVWF  10
....................    set_timer1(59286);
012D:  CLRF   0E
012E:  MOVLW  E7
012F:  MOVWF  0F
0130:  MOVLW  96
0131:  MOVWF  0E
0132:  NOP
.................... 
.................... //! enable interrupt timer 1 and read data uart
....................    enable_interrupts(global);
0133:  MOVLW  C0
0134:  IORWF  0B,F
....................    enable_interrupts(int_timer1);
0135:  BSF    03.5
0136:  BSF    0C.0
....................    enable_interrupts(int_rda);
0137:  BSF    0C.5
.................... 
.................... 
.................... //! setup mode for all gpio of pic16f877a
....................    set_tris_a(0xff);
0138:  MOVLW  FF
0139:  MOVWF  05
....................    set_tris_b(0xdf);
013A:  MOVLW  DF
013B:  MOVWF  06
....................    set_tris_d(0x00); //output_d(0x00);
013C:  MOVLW  00
013D:  MOVWF  08
....................    set_tris_e(0x00); //output_e(0x00);
013E:  BCF    09.0
013F:  BCF    09.1
0140:  BCF    09.2
....................    set_tris_c(0x98); //output_c(0x98);
0141:  MOVLW  98
0142:  MOVWF  07
....................  
.................... //! setup variable initialize
....................    flag_10ms = false;
0143:  BCF    03.5
0144:  BCF    2C.0
....................    flag_10s  = false;
0145:  BCF    2C.1
....................    isDs18b20 = false;
0146:  BCF    2C.2
....................    
....................    limitTemperature = 25;
0147:  MOVLW  19
0148:  MOVWF  2D
....................    
....................    e_11 = true; e_22 = true; e_33 = true;
0149:  BSF    2C.3
014A:  BSF    2C.4
014B:  BSF    2C.5
....................    
....................    eat_hh = 0x09; eat_pp = 0x30; eat_ss = 0x30;
014C:  MOVLW  09
014D:  MOVWF  37
014E:  MOVLW  30
014F:  MOVWF  38
0150:  MOVWF  39
0151:  BCF    0A.3
0152:  BSF    0A.4
0153:  GOTO   05F (RETURN)
.................... }
.................... 
.................... #include <library_button.c>
.................... //! button place
.................... //! bt3 - bt2 - bt1 - bt0
.................... 
.................... usi8 countPush = 0;
.................... usi8 countTick = 0;
.................... 
.................... bool push_btn(bool isRelease, usi8 pin){
.................... //! isRelease == 0 --> push button is hold
.................... //! isRelease == 1 --> push button is release
....................    if(!input(pin)){
*
1078:  MOVF   7B,W
1079:  MOVWF  7D
107A:  BSF    03.5
107B:  CLRF   21
107C:  CLRF   20
107D:  BCF    0A.4
107E:  BCF    03.5
107F:  CALL   463
1080:  BSF    0A.4
1081:  BTFSC  78.0
1082:  GOTO   0AD
....................       if(flag_10ms == true) countPush++;
1083:  BTFSS  2C.0
1084:  GOTO   086
1085:  INCF   5B,F
.................... //! check if countPush == 2 (20ms) --> debound button
....................       if(countPush >= 1){
1086:  MOVF   5B,W
1087:  SUBLW  00
1088:  BTFSC  03.0
1089:  GOTO   0AA
....................          if(!input(pin)){
108A:  MOVF   7B,W
108B:  MOVWF  7D
108C:  BSF    03.5
108D:  CLRF   21
108E:  CLRF   20
108F:  BCF    0A.4
1090:  BCF    03.5
1091:  CALL   463
1092:  BSF    0A.4
1093:  BTFSC  78.0
1094:  GOTO   0A7
....................             if(isRelease == false) while(!input(pin));
1095:  MOVF   76,F
1096:  BTFSS  03.2
1097:  GOTO   0A3
1098:  MOVF   7B,W
1099:  MOVWF  7D
109A:  BSF    03.5
109B:  CLRF   21
109C:  CLRF   20
109D:  BCF    0A.4
109E:  BCF    03.5
109F:  CALL   463
10A0:  BSF    0A.4
10A1:  BTFSS  78.0
10A2:  GOTO   098
....................             countPush = 0;
10A3:  CLRF   5B
....................             return true;
10A4:  MOVLW  01
10A5:  MOVWF  78
10A6:  GOTO   0AF
....................          }
....................          return false;
10A7:  MOVLW  00
10A8:  MOVWF  78
10A9:  GOTO   0AF
....................       }
....................       return false;
10AA:  MOVLW  00
10AB:  MOVWF  78
10AC:  GOTO   0AF
....................    }
.................... //!   countPush = 0;
....................    return false;
10AD:  MOVLW  00
10AE:  MOVWF  78
.................... }
.................... 
.................... bool tick_btn(usi8 delay, usi8 pin){
.................... //! dl is time delay that compute with 10ms for dl is 1
....................    if(!input(pin)){
*
07D7:  MOVF   7B,W
07D8:  MOVWF  7D
07D9:  BSF    03.5
07DA:  CLRF   21
07DB:  CLRF   20
07DC:  BCF    03.5
07DD:  CALL   463
07DE:  BTFSC  78.0
07DF:  GOTO   7ED
....................       if(flag_10ms == true) countTick++;
07E0:  BTFSC  2C.0
07E1:  INCF   5C,F
.................... //! check if countTick >= delay (delay * 10ms) --> time delay wanna to tick rising signal
....................       if(countTick >= delay){
07E2:  MOVF   76,W
07E3:  SUBWF  5C,W
07E4:  BTFSS  03.0
07E5:  GOTO   7EA
....................          countTick = 0;
07E6:  CLRF   5C
....................          return true;
07E7:  MOVLW  01
07E8:  MOVWF  78
07E9:  GOTO   7EF
....................       }
....................       return false;
07EA:  MOVLW  00
07EB:  MOVWF  78
07EC:  GOTO   7EF
....................    }
.................... //!   countTick = 0;
....................    return false;
07ED:  MOVLW  00
07EE:  MOVWF  78
07EF:  RETURN
.................... }
.................... 
.................... #include <library_i2c.c>
.................... #define pcf8574_addr_wr 0x4E // 0b01001110
.................... #define pcf8574_addr_rd 0x4F // 0b01001111
.................... 
.................... //! i2c reset
.................... void i2c_reset()
.................... {
....................    i2c_start();
....................    i2c_stop();
.................... }
.................... 
.................... //! i2c setup write for pcf8574
.................... void i2c_setup_write()
.................... {
....................    i2c_start();
*
027B:  BSF    03.5
027C:  BSF    11.0
027D:  BTFSC  11.0
027E:  GOTO   27D
....................    i2c_write(pcf8574_addr_wr);
027F:  MOVLW  4E
0280:  MOVWF  48
0281:  BCF    03.5
0282:  CALL   154
.................... }
.................... 
.................... //! i2c write 1byte for pcf8574
.................... void i2c_write_1byte(usi8 payload)
.................... {
....................    i2c_start();
*
01FE:  BSF    11.1
01FF:  BTFSC  11.1
0200:  GOTO   1FF
*
021C:  BSF    11.1
021D:  BTFSC  11.1
021E:  GOTO   21D
*
023B:  BSF    11.1
023C:  BTFSC  11.1
023D:  GOTO   23C
*
0294:  BSF    11.1
0295:  BTFSC  11.1
0296:  GOTO   295
....................    i2c_write(pcf8574_addr_wr);
*
0201:  MOVLW  4E
0202:  MOVWF  48
0203:  BCF    03.5
0204:  CALL   154
*
021F:  MOVLW  4E
0220:  MOVWF  48
0221:  BCF    03.5
0222:  CALL   154
*
023E:  MOVLW  4E
023F:  MOVWF  48
0240:  BCF    03.5
0241:  CALL   154
*
0297:  MOVLW  4E
0298:  MOVWF  48
0299:  BCF    03.5
029A:  CALL   154
....................    i2c_write(payload);
*
0205:  BSF    03.5
0206:  MOVF   47,W
0207:  MOVWF  48
0208:  BCF    03.5
0209:  CALL   154
*
0223:  BSF    03.5
0224:  MOVF   47,W
0225:  MOVWF  48
0226:  BCF    03.5
0227:  CALL   154
*
0242:  BSF    03.5
0243:  MOVF   47,W
0244:  MOVWF  48
0245:  BCF    03.5
0246:  CALL   154
*
029B:  BSF    03.5
029C:  MOVF   47,W
029D:  MOVWF  48
029E:  BCF    03.5
029F:  CALL   154
....................    i2c_stop();
*
020A:  BSF    03.5
020B:  BSF    11.2
020C:  BTFSC  11.2
020D:  GOTO   20C
*
0228:  BSF    03.5
0229:  BSF    11.2
022A:  BTFSC  11.2
022B:  GOTO   22A
*
0247:  BSF    03.5
0248:  BSF    11.2
0249:  BTFSC  11.2
024A:  GOTO   249
*
02A0:  BSF    03.5
02A1:  BSF    11.2
02A2:  BTFSC  11.2
02A3:  GOTO   2A2
.................... }
.................... 
.................... 
.................... #include <library_lcd_i2c.c>
.................... #define lcd_cols 16
.................... #define lcd_rows 2
.................... 
.................... // commands
.................... #define LCD_CLEARDISPLAY 0x01
.................... #define LCD_RETURNHOME 0x02
.................... #define LCD_ENTRYMODESET 0x04
.................... #define LCD_DISPLAYCONTROL 0x08
.................... #define LCD_CURSORSHIFT 0x10
.................... #define LCD_FUNCTIONSET 0x20
.................... #define LCD_SETCGRAMADDR 0x40
.................... #define LCD_SETDDRAMADDR 0x80
.................... 
.................... // flags for display entry mode
.................... #define LCD_ENTRYRIGHT 0x00
.................... #define LCD_ENTRYLEFT 0x02
.................... #define LCD_ENTRYSHIFTINCREMENT 0x01
.................... #define LCD_ENTRYSHIFTDECREMENT 0x00
.................... 
.................... // flags for display on/off control
.................... #define LCD_DISPLAYON 0x04
.................... #define LCD_DISPLAYOFF 0x00
.................... #define LCD_CURSORON 0x02
.................... #define LCD_CURSOROFF 0x00
.................... #define LCD_BLINKON 0x01
.................... #define LCD_BLINKOFF 0x00
.................... 
.................... // flags for display/cursor shift
.................... #define LCD_DISPLAYMOVE 0x08
.................... #define LCD_CURSORMOVE 0x00
.................... #define LCD_MOVERIGHT 0x04
.................... #define LCD_MOVELEFT 0x00
.................... 
.................... // flags for function set
.................... #define LCD_8BITMODE 0x10
.................... #define LCD_4BITMODE 0x00
.................... #define LCD_2LINE 0x08
.................... #define LCD_1LINE 0x00
.................... #define LCD_5x10DOTS 0x04
.................... #define LCD_5x8DOTS 0x00
.................... 
.................... // flags for backlight control
.................... #define LCD_BACKLIGHT 0x08
.................... #define LCD_NOBACKLIGHT 0x00
.................... 
.................... #define En 0B00000100  // Enable bit
.................... #define Rw 0B00000010  // Read/Write bit
.................... #define Rs 0B00000001  // Register select bit
.................... 
.................... void write4bits(usi8 value);
.................... void expanderWrite(usi8 _data);
.................... void pulseEnable(usi8 _data);
.................... void lcd_command(usi8 value);
.................... void lcd_display();
.................... void lcd_clear();
.................... void lcd_home();
.................... void lcd_send(usi8 value, usi8 mode);
.................... void lcd_data(usi8 value);
.................... 
.................... usi8 _displayfunction;
.................... usi8 _displaycontrol;
.................... usi8 _displaymode;
.................... usi8 _numlines;
.................... usi8 _cols;
.................... usi8 _rows;
.................... usi8 _backlightval;
.................... 
.................... void lcd_setup(){
....................    _cols = lcd_cols; // 16
*
0276:  MOVLW  10
0277:  MOVWF  61
....................    _rows = lcd_rows; // 2
0278:  MOVLW  02
0279:  MOVWF  62
....................    _backlightval = LCD_NOBACKLIGHT; // back light is off
027A:  CLRF   63
....................    
....................    i2c_setup_write(); // setup i2c
....................    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
*
0283:  CLRF   5D
....................    
....................    _displayfunction |= LCD_2LINE;
0284:  BSF    5D.3
....................    _numlines = _rows; // 2
0285:  MOVF   62,W
0286:  MOVWF  60
....................    
....................    delay_ms(40);
0287:  MOVLW  28
0288:  MOVWF  7C
0289:  CALL   1E0
....................    
....................    expanderWrite(_backlightval); // back light is on
028A:  MOVF   63,W
028B:  BSF    03.5
028C:  MOVWF  45
....................    delay_ms(100);
*
02A4:  MOVLW  64
02A5:  MOVWF  7C
02A6:  BCF    03.5
02A7:  CALL   1E0
....................    
....................    //It is try to set use 4bit in 3 time
....................    write4bits(0x03 << 4);
02A8:  MOVLW  30
02A9:  BSF    03.5
02AA:  MOVWF  42
02AB:  BCF    03.5
02AC:  CALL   1F4
....................    delay_ms(5);
02AD:  MOVLW  05
02AE:  MOVWF  7C
02AF:  CALL   1E0
....................    
....................    write4bits(0x03 << 4);
02B0:  MOVLW  30
02B1:  BSF    03.5
02B2:  MOVWF  42
02B3:  BCF    03.5
02B4:  CALL   1F4
....................    delay_ms(5);
02B5:  MOVLW  05
02B6:  MOVWF  7C
02B7:  CALL   1E0
....................    
....................    write4bits(0x03 << 4);
02B8:  MOVLW  30
02B9:  BSF    03.5
02BA:  MOVWF  42
02BB:  BCF    03.5
02BC:  CALL   1F4
....................    delay_ms(5);
02BD:  MOVLW  05
02BE:  MOVWF  7C
02BF:  CALL   1E0
....................    
....................    write4bits(0x02 << 4); // set using 4bit for lcd16x2
02C0:  MOVLW  20
02C1:  BSF    03.5
02C2:  MOVWF  42
02C3:  BCF    03.5
02C4:  CALL   1F4
....................    
....................    lcd_command(LCD_FUNCTIONSET | _displayfunction);
02C5:  MOVF   5D,W
02C6:  IORLW  20
02C7:  MOVWF  76
02C8:  BSF    03.5
02C9:  MOVWF  3C
02CA:  BCF    03.5
02CB:  CALL   251
....................    
....................    _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
02CC:  MOVLW  04
02CD:  MOVWF  5E
....................    lcd_display();
....................    
....................    lcd_clear();
*
02D6:  CALL   26D
....................    
....................    _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
02D7:  MOVLW  02
02D8:  MOVWF  5F
....................    lcd_command(LCD_ENTRYMODESET | _displaymode);
02D9:  MOVF   5F,W
02DA:  IORLW  04
02DB:  MOVWF  76
02DC:  BSF    03.5
02DD:  MOVWF  3C
02DE:  BCF    03.5
02DF:  CALL   251
....................    
....................    lcd_home();
*
02E8:  BCF    0A.3
02E9:  BSF    0A.4
02EA:  GOTO   065 (RETURN)
.................... }
.................... 
.................... void lcd_clear(){
....................    lcd_command(LCD_CLEARDISPLAY);
*
026D:  MOVLW  01
026E:  BSF    03.5
026F:  MOVWF  3C
0270:  BCF    03.5
0271:  CALL   251
....................    delay_ms(20);
0272:  MOVLW  14
0273:  MOVWF  7C
0274:  CALL   1E0
0275:  RETURN
.................... }
.................... 
.................... void lcd_home(){
....................    lcd_command(LCD_RETURNHOME);
*
02E0:  MOVLW  02
02E1:  BSF    03.5
02E2:  MOVWF  3C
02E3:  BCF    03.5
02E4:  CALL   251
....................    delay_ms(20);
02E5:  MOVLW  14
02E6:  MOVWF  7C
02E7:  CALL   1E0
.................... }
.................... 
.................... void lcd_setCursor(usi8 col, usi8 row){
....................    int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
*
0317:  BSF    03.5
0318:  CLRF   37
0319:  MOVLW  40
031A:  MOVWF  38
031B:  MOVLW  14
031C:  MOVWF  39
031D:  MOVLW  54
031E:  MOVWF  3A
....................    if ( row > _numlines ) {
031F:  MOVF   36,W
0320:  BCF    03.5
0321:  SUBWF  60,W
0322:  BTFSC  03.0
0323:  GOTO   329
....................       row = _numlines-1;
0324:  MOVLW  01
0325:  SUBWF  60,W
0326:  BSF    03.5
0327:  MOVWF  36
0328:  BCF    03.5
....................    }
....................    lcd_command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
0329:  MOVLW  B7
032A:  BSF    03.5
032B:  ADDWF  36,W
032C:  MOVWF  04
032D:  BCF    03.7
032E:  MOVF   00,W
032F:  ADDWF  35,W
0330:  IORLW  80
0331:  MOVWF  3B
0332:  MOVWF  3C
0333:  BCF    03.5
0334:  CALL   251
0335:  RETURN
.................... }
.................... 
.................... void lcd_display() {
....................    _displaycontrol |= LCD_DISPLAYON;
*
02CE:  BSF    5E.2
....................    lcd_command(LCD_DISPLAYCONTROL | _displaycontrol);
02CF:  MOVF   5E,W
02D0:  IORLW  08
02D1:  MOVWF  76
02D2:  BSF    03.5
02D3:  MOVWF  3C
02D4:  BCF    03.5
02D5:  CALL   251
.................... }
.................... 
.................... void lcd_command(usi8 value){
....................    lcd_send(value,0);
*
0251:  BSF    03.5
0252:  MOVF   3C,W
0253:  MOVWF  3D
0254:  CLRF   3E
*
026C:  RETURN
.................... }
.................... 
.................... void lcd_data(usi8 value){
....................    lcd_send(value,Rs);
*
0336:  BSF    03.5
0337:  MOVF   38,W
0338:  MOVWF  3D
0339:  MOVLW  01
033A:  MOVWF  3E
*
0352:  RETURN
.................... }
.................... 
.................... void lcd_send(usi8 value, usi8 mode) {
*
0255:  MOVF   3D,W
0256:  ANDLW  F0
0257:  MOVWF  3F
0258:  SWAPF  3D,W
0259:  MOVWF  77
025A:  MOVLW  F0
025B:  ANDWF  77,F
025C:  MOVF   77,W
025D:  ANDLW  F0
025E:  MOVWF  40
*
033B:  MOVF   3D,W
033C:  ANDLW  F0
033D:  MOVWF  3F
033E:  SWAPF  3D,W
033F:  MOVWF  77
0340:  MOVLW  F0
0341:  ANDWF  77,F
0342:  MOVF   77,W
0343:  ANDLW  F0
0344:  MOVWF  40
....................    usi8 highnib=value&0xf0;
....................    usi8 lownib=(value<<4)&0xf0;
....................    write4bits((highnib)|mode);
*
025F:  MOVF   3F,W
0260:  IORWF  3E,W
0261:  MOVWF  41
0262:  MOVWF  42
0263:  BCF    03.5
0264:  CALL   1F4
*
0345:  MOVF   3F,W
0346:  IORWF  3E,W
0347:  MOVWF  41
0348:  MOVWF  42
0349:  BCF    03.5
034A:  CALL   1F4
....................    write4bits((lownib)|mode); 
*
0265:  BSF    03.5
0266:  MOVF   40,W
0267:  IORWF  3E,W
0268:  MOVWF  41
0269:  MOVWF  42
026A:  BCF    03.5
026B:  CALL   1F4
*
034B:  BSF    03.5
034C:  MOVF   40,W
034D:  IORWF  3E,W
034E:  MOVWF  41
034F:  MOVWF  42
0350:  BCF    03.5
0351:  CALL   1F4
.................... }
.................... 
.................... void write4bits(usi8 value) {
....................    expanderWrite(value);
*
01F4:  BSF    03.5
01F5:  MOVF   42,W
01F6:  MOVWF  45
....................    pulseEnable(value);
*
020E:  MOVF   42,W
020F:  MOVWF  43
*
024F:  BCF    03.5
0250:  RETURN
.................... }
.................... 
.................... void expanderWrite(usi8 _data){
....................    i2c_write_1byte(_data|_backlightval);
*
01F7:  MOVF   45,W
01F8:  BCF    03.5
01F9:  IORWF  63,W
01FA:  BSF    03.5
01FB:  MOVWF  46
01FC:  MOVF   46,W
01FD:  MOVWF  47
*
0215:  MOVF   45,W
0216:  BCF    03.5
0217:  IORWF  63,W
0218:  BSF    03.5
0219:  MOVWF  46
021A:  MOVF   46,W
021B:  MOVWF  47
*
0234:  MOVF   45,W
0235:  BCF    03.5
0236:  IORWF  63,W
0237:  BSF    03.5
0238:  MOVWF  46
0239:  MOVF   46,W
023A:  MOVWF  47
*
028D:  MOVF   45,W
028E:  BCF    03.5
028F:  IORWF  63,W
0290:  BSF    03.5
0291:  MOVWF  46
0292:  MOVF   46,W
0293:  MOVWF  47
.................... }
.................... 
.................... void pulseEnable(usi8 _data){
....................    expanderWrite(_data | En);
*
0210:  MOVF   43,W
0211:  IORLW  04
0212:  MOVWF  44
0213:  MOVF   44,W
0214:  MOVWF  45
....................    delay_us(1);
*
022C:  GOTO   22D
022D:  GOTO   22E
022E:  NOP
....................    expanderWrite(_data & ~En);
022F:  MOVF   43,W
0230:  ANDLW  FB
0231:  MOVWF  44
0232:  MOVF   44,W
0233:  MOVWF  45
....................    delay_us(50);
*
024B:  MOVLW  53
024C:  MOVWF  77
024D:  DECFSZ 77,F
024E:  GOTO   24D
.................... }
.................... 
.................... void log_lcd_initialize(){
....................    lcd_setCursor(1,0);
*
03C7:  MOVLW  01
03C8:  BSF    03.5
03C9:  MOVWF  35
03CA:  CLRF   36
03CB:  BCF    03.5
03CC:  CALL   317
....................    lcd_data("Do an 1 - HKII");
03CD:  MOVLW  C2
03CE:  BSF    03.6
03CF:  MOVWF  0D
03D0:  MOVLW  00
03D1:  MOVWF  0F
03D2:  BCF    03.6
03D3:  CALL   353
....................    lcd_setCursor(3,1);
03D4:  MOVLW  03
03D5:  BSF    03.5
03D6:  MOVWF  35
03D7:  MOVLW  01
03D8:  MOVWF  36
03D9:  BCF    03.5
03DA:  CALL   317
....................    lcd_data("SPKT-TPHCM");
03DB:  MOVLW  CA
03DC:  BSF    03.6
03DD:  MOVWF  0D
03DE:  MOVLW  00
03DF:  MOVWF  0F
03E0:  BCF    03.6
03E1:  CALL   353
....................    delay_ms(2000);
03E2:  MOVLW  08
03E3:  MOVWF  76
03E4:  MOVLW  FA
03E5:  MOVWF  7C
03E6:  CALL   1E0
03E7:  DECFSZ 76,F
03E8:  GOTO   3E4
....................    lcd_clear();
03E9:  CALL   26D
03EA:  BCF    0A.3
03EB:  BSF    0A.4
03EC:  GOTO   06B (RETURN)
.................... }
.................... 
.................... void lcd_dis_xx_yy_zz(usi8 x, usi8 y, usi8 a, usi8 b, usi8 c, bool e3, bool e2, bool e1){
....................    usi8 a_ch, a_dv, b_ch, b_dv, c_ch, c_dv;
....................    a_ch = e3 == true ? a/10 + 0x30 : 0x20; a_dv = e3 == true ? a%10 + 0x30 : 0x20;
*
0639:  BSF    03.5
063A:  DECFSZ 2C,W
063B:  GOTO   646
063C:  MOVF   29,W
063D:  MOVWF  35
063E:  MOVLW  0A
063F:  MOVWF  36
0640:  BCF    03.5
0641:  CALL   622
0642:  MOVLW  30
0643:  ADDWF  78,W
0644:  GOTO   648
0645:  BSF    03.5
0646:  MOVLW  20
0647:  BCF    03.5
0648:  BSF    03.5
0649:  MOVWF  2F
064A:  DECFSZ 2C,W
064B:  GOTO   656
064C:  MOVF   29,W
064D:  MOVWF  35
064E:  MOVLW  0A
064F:  MOVWF  36
0650:  BCF    03.5
0651:  CALL   622
0652:  MOVLW  30
0653:  ADDWF  77,W
0654:  GOTO   658
0655:  BSF    03.5
0656:  MOVLW  20
0657:  BCF    03.5
0658:  BSF    03.5
0659:  MOVWF  30
....................    b_ch = e2 == true ? b/10 + 0x30 : 0x20; b_dv = e2 == true ? b%10 + 0x30 : 0x20;
065A:  DECFSZ 2D,W
065B:  GOTO   666
065C:  MOVF   2A,W
065D:  MOVWF  35
065E:  MOVLW  0A
065F:  MOVWF  36
0660:  BCF    03.5
0661:  CALL   622
0662:  MOVLW  30
0663:  ADDWF  78,W
0664:  GOTO   668
0665:  BSF    03.5
0666:  MOVLW  20
0667:  BCF    03.5
0668:  BSF    03.5
0669:  MOVWF  31
066A:  DECFSZ 2D,W
066B:  GOTO   676
066C:  MOVF   2A,W
066D:  MOVWF  35
066E:  MOVLW  0A
066F:  MOVWF  36
0670:  BCF    03.5
0671:  CALL   622
0672:  MOVLW  30
0673:  ADDWF  77,W
0674:  GOTO   678
0675:  BSF    03.5
0676:  MOVLW  20
0677:  BCF    03.5
0678:  BSF    03.5
0679:  MOVWF  32
....................    c_ch = e1 == true ? c/10 + 0x30 : 0x20; c_dv = e1 == true ? c%10 + 0x30 : 0x20;
067A:  DECFSZ 2E,W
067B:  GOTO   686
067C:  MOVF   2B,W
067D:  MOVWF  35
067E:  MOVLW  0A
067F:  MOVWF  36
0680:  BCF    03.5
0681:  CALL   622
0682:  MOVLW  30
0683:  ADDWF  78,W
0684:  GOTO   688
0685:  BSF    03.5
0686:  MOVLW  20
0687:  BCF    03.5
0688:  BSF    03.5
0689:  MOVWF  33
068A:  DECFSZ 2E,W
068B:  GOTO   696
068C:  MOVF   2B,W
068D:  MOVWF  35
068E:  MOVLW  0A
068F:  MOVWF  36
0690:  BCF    03.5
0691:  CALL   622
0692:  MOVLW  30
0693:  ADDWF  77,W
0694:  GOTO   698
0695:  BSF    03.5
0696:  MOVLW  20
0697:  BCF    03.5
0698:  BSF    03.5
0699:  MOVWF  34
....................    lcd_setCursor(x, y);
069A:  MOVF   27,W
069B:  MOVWF  35
069C:  MOVF   28,W
069D:  MOVWF  36
069E:  BCF    03.5
069F:  CALL   317
....................    lcd_data(a_ch); lcd_data(a_dv); lcd_data("-");
06A0:  BSF    03.5
06A1:  MOVF   2F,W
06A2:  MOVWF  38
06A3:  BCF    03.5
06A4:  CALL   336
06A5:  BSF    03.5
06A6:  MOVF   30,W
06A7:  MOVWF  38
06A8:  BCF    03.5
06A9:  CALL   336
06AA:  MOVLW  D0
06AB:  BSF    03.6
06AC:  MOVWF  0D
06AD:  MOVLW  00
06AE:  MOVWF  0F
06AF:  BCF    03.6
06B0:  CALL   353
....................    lcd_data(b_ch); lcd_data(b_dv); lcd_data("-");
06B1:  BSF    03.5
06B2:  MOVF   31,W
06B3:  MOVWF  38
06B4:  BCF    03.5
06B5:  CALL   336
06B6:  BSF    03.5
06B7:  MOVF   32,W
06B8:  MOVWF  38
06B9:  BCF    03.5
06BA:  CALL   336
06BB:  MOVLW  D1
06BC:  BSF    03.6
06BD:  MOVWF  0D
06BE:  MOVLW  00
06BF:  MOVWF  0F
06C0:  BCF    03.6
06C1:  CALL   353
....................    lcd_data(c_ch); lcd_data(c_dv);
06C2:  BSF    03.5
06C3:  MOVF   33,W
06C4:  MOVWF  38
06C5:  BCF    03.5
06C6:  CALL   336
06C7:  BSF    03.5
06C8:  MOVF   34,W
06C9:  MOVWF  38
06CA:  BCF    03.5
06CB:  CALL   336
06CC:  RETURN
.................... }
.................... 
.................... void lcd_dis_2num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 ch, dv;
....................    lcd_setCursor(x, y);
06CD:  BSF    03.5
06CE:  MOVF   26,W
06CF:  MOVWF  35
06D0:  MOVF   27,W
06D1:  MOVWF  36
06D2:  BCF    03.5
06D3:  CALL   317
....................    ch = dt/10 + 0x30;
06D4:  BSF    03.5
06D5:  MOVF   25,W
06D6:  MOVWF  30
06D7:  MOVF   24,W
06D8:  MOVWF  2F
06D9:  CLRF   32
06DA:  MOVLW  0A
06DB:  MOVWF  31
06DC:  BCF    03.5
06DD:  CALL   50D
06DE:  MOVF   79,W
06DF:  BSF    03.5
06E0:  MOVWF  2D
06E1:  MOVF   78,W
06E2:  MOVWF  2C
06E3:  MOVLW  30
06E4:  ADDWF  2C,W
06E5:  MOVWF  2A
....................    dv = dt%10 + 0x30;
06E6:  MOVF   25,W
06E7:  MOVWF  30
06E8:  MOVF   24,W
06E9:  MOVWF  2F
06EA:  CLRF   32
06EB:  MOVLW  0A
06EC:  MOVWF  31
06ED:  BCF    03.5
06EE:  CALL   50D
06EF:  MOVF   77,W
06F0:  BSF    03.5
06F1:  MOVWF  2C
06F2:  MOVF   7A,W
06F3:  MOVWF  2D
06F4:  MOVLW  30
06F5:  ADDWF  2C,W
06F6:  MOVWF  2B
....................    if(is_xvn == true) if(ch == 0x30) ch = 0x20;
06F7:  DECFSZ 28,W
06F8:  GOTO   6FF
06F9:  MOVF   2A,W
06FA:  SUBLW  30
06FB:  BTFSS  03.2
06FC:  GOTO   6FF
06FD:  MOVLW  20
06FE:  MOVWF  2A
....................    if(is_dot == true) lcd_data(".");
06FF:  DECFSZ 29,W
0700:  GOTO   70A
0701:  MOVLW  D2
0702:  BCF    03.5
0703:  BSF    03.6
0704:  MOVWF  0D
0705:  MOVLW  00
0706:  MOVWF  0F
0707:  BCF    03.6
0708:  CALL   353
0709:  BSF    03.5
....................    lcd_data(ch); lcd_data(dv);
070A:  MOVF   2A,W
070B:  MOVWF  38
070C:  BCF    03.5
070D:  CALL   336
070E:  BSF    03.5
070F:  MOVF   2B,W
0710:  MOVWF  38
0711:  BCF    03.5
0712:  CALL   336
0713:  RETURN
.................... }
.................... 
.................... void lcd_dis_3num_dot(usi16 dt, int8 x, int8 y, bool is_xvn, bool is_dot){
....................    usi8 tr, ch, dv;
....................    lcd_setCursor(x, y); //xxx /10 -> xx 
*
0742:  MOVF   26,W
0743:  MOVWF  35
0744:  MOVF   27,W
0745:  MOVWF  36
0746:  BCF    03.5
0747:  CALL   317
....................    tr = dt/100 + 0x30; 
0748:  BSF    03.5
0749:  MOVF   25,W
074A:  MOVWF  30
074B:  MOVF   24,W
074C:  MOVWF  2F
074D:  CLRF   32
074E:  MOVLW  64
074F:  MOVWF  31
0750:  BCF    03.5
0751:  CALL   50D
0752:  MOVF   79,W
0753:  BSF    03.5
0754:  MOVWF  2E
0755:  MOVF   78,W
0756:  MOVWF  2D
0757:  MOVLW  30
0758:  ADDWF  2D,W
0759:  MOVWF  2A
....................    ch = dt/10%10  + 0x30;
075A:  MOVF   25,W
075B:  MOVWF  30
075C:  MOVF   24,W
075D:  MOVWF  2F
075E:  CLRF   32
075F:  MOVLW  0A
0760:  MOVWF  31
0761:  BCF    03.5
0762:  CALL   50D
0763:  MOVF   79,W
0764:  BSF    03.5
0765:  MOVWF  2E
0766:  MOVF   78,W
0767:  MOVWF  2D
0768:  MOVF   2E,W
0769:  MOVWF  30
076A:  MOVF   2D,W
076B:  MOVWF  2F
076C:  CLRF   32
076D:  MOVLW  0A
076E:  MOVWF  31
076F:  BCF    03.5
0770:  CALL   50D
0771:  MOVF   77,W
0772:  BSF    03.5
0773:  MOVWF  2D
0774:  MOVF   7A,W
0775:  MOVWF  2E
0776:  MOVLW  30
0777:  ADDWF  2D,W
0778:  MOVWF  2B
....................    dv = dt%10     + 0x30;
0779:  MOVF   25,W
077A:  MOVWF  30
077B:  MOVF   24,W
077C:  MOVWF  2F
077D:  CLRF   32
077E:  MOVLW  0A
077F:  MOVWF  31
0780:  BCF    03.5
0781:  CALL   50D
0782:  MOVF   77,W
0783:  BSF    03.5
0784:  MOVWF  2D
0785:  MOVF   7A,W
0786:  MOVWF  2E
0787:  MOVLW  30
0788:  ADDWF  2D,W
0789:  MOVWF  2C
....................    if(is_xvn == true) if(tr == 0x30){
078A:  DECFSZ 28,W
078B:  GOTO   798
078C:  MOVF   2A,W
078D:  SUBLW  30
078E:  BTFSS  03.2
078F:  GOTO   798
....................       tr = 0x20;
0790:  MOVLW  20
0791:  MOVWF  2A
....................       if(ch == 0x30) ch = 0x20;
0792:  MOVF   2B,W
0793:  SUBLW  30
0794:  BTFSS  03.2
0795:  GOTO   798
0796:  MOVLW  20
0797:  MOVWF  2B
....................    }
....................    if(is_dot == true) lcd_data(".");
0798:  DECFSZ 29,W
0799:  GOTO   7A3
079A:  MOVLW  D3
079B:  BCF    03.5
079C:  BSF    03.6
079D:  MOVWF  0D
079E:  MOVLW  00
079F:  MOVWF  0F
07A0:  BCF    03.6
07A1:  CALL   353
07A2:  BSF    03.5
....................    lcd_data(tr); lcd_data(ch); lcd_data(dv);
07A3:  MOVF   2A,W
07A4:  MOVWF  38
07A5:  BCF    03.5
07A6:  CALL   336
07A7:  BSF    03.5
07A8:  MOVF   2B,W
07A9:  MOVWF  38
07AA:  BCF    03.5
07AB:  CALL   336
07AC:  BSF    03.5
07AD:  MOVF   2C,W
07AE:  MOVWF  38
07AF:  BCF    03.5
07B0:  CALL   336
.................... }
.................... 
.................... void lcd_dis_temperature (int8 x, int8 y, usi16 ng, usi16 th){
....................    lcd_setCursor(x,y);
*
0714:  MOVF   76,W
0715:  BSF    03.5
0716:  MOVWF  35
0717:  MOVF   7B,W
0718:  MOVWF  36
0719:  BCF    03.5
071A:  CALL   317
....................    lcd_data("ND: ");
071B:  MOVLW  D4
071C:  BSF    03.6
071D:  MOVWF  0D
071E:  MOVLW  00
071F:  MOVWF  0F
0720:  BCF    03.6
0721:  CALL   353
....................    lcd_dis_2num_dot(ng, x + 4, y, true, false);
0722:  MOVLW  04
0723:  ADDWF  76,W
0724:  MOVWF  7E
0725:  MOVF   7D,W
0726:  BSF    03.5
0727:  MOVWF  25
0728:  MOVF   7C,W
0729:  MOVWF  24
072A:  MOVF   7E,W
072B:  MOVWF  26
072C:  MOVF   7B,W
072D:  MOVWF  27
072E:  MOVLW  01
072F:  MOVWF  28
0730:  CLRF   29
0731:  BCF    03.5
0732:  CALL   6CD
....................    lcd_dis_3num_dot(th, x + 6, y, false, true);
0733:  MOVLW  06
0734:  ADDWF  76,W
0735:  MOVWF  7E
0736:  BSF    03.5
0737:  MOVF   21,W
0738:  MOVWF  25
0739:  MOVF   20,W
073A:  MOVWF  24
073B:  MOVF   7E,W
073C:  MOVWF  26
073D:  MOVF   7B,W
073E:  MOVWF  27
073F:  CLRF   28
0740:  MOVLW  01
0741:  MOVWF  29
....................    lcd_data(" oC");
*
07B1:  MOVLW  D7
07B2:  BSF    03.6
07B3:  MOVWF  0D
07B4:  MOVLW  00
07B5:  MOVWF  0F
07B6:  BCF    03.6
07B7:  CALL   353
07B8:  RETURN
.................... }
.................... 
.................... void lcd_dis_temperature_limit (int8 x, int8 y, usi16 ng){
....................    lcd_setCursor(x,y);
*
1339:  MOVF   76,W
133A:  BSF    03.5
133B:  MOVWF  35
133C:  MOVF   7B,W
133D:  MOVWF  36
133E:  BCF    0A.4
133F:  BCF    03.5
1340:  CALL   317
1341:  BSF    0A.4
....................    lcd_data("ND-GH: ");
1342:  MOVLW  D9
1343:  BSF    03.6
1344:  MOVWF  0D
1345:  MOVLW  00
1346:  MOVWF  0F
1347:  BCF    0A.4
1348:  BCF    03.6
1349:  CALL   353
134A:  BSF    0A.4
....................    lcd_dis_2num_dot(ng, x + 7, y, true, false);
134B:  MOVLW  07
134C:  ADDWF  76,W
134D:  MOVWF  7E
134E:  MOVF   7D,W
134F:  BSF    03.5
1350:  MOVWF  25
1351:  MOVF   7C,W
1352:  MOVWF  24
1353:  MOVF   7E,W
1354:  MOVWF  26
1355:  MOVF   7B,W
1356:  MOVWF  27
1357:  MOVLW  01
1358:  MOVWF  28
1359:  CLRF   29
135A:  BCF    0A.4
135B:  BCF    03.5
135C:  CALL   6CD
135D:  BSF    0A.4
....................    lcd_data(" oC");
135E:  MOVLW  DD
135F:  BSF    03.6
1360:  MOVWF  0D
1361:  MOVLW  00
1362:  MOVWF  0F
1363:  BCF    0A.4
1364:  BCF    03.6
1365:  CALL   353
1366:  BSF    0A.4
.................... }
.................... 
.................... #include <library_ds1307_i2c.c>
.................... #define ds13_addr_wr 0xd0
.................... #define ds13_addr_rd 0xd1
.................... 
.................... //cap nhat time: giay-phut-gio-thu-ngay-thang-nam-madk_msds
.................... usi8 time_w[9]={0x31,0x15,0x15,0x04,0x25,0x10,0x23,0x90,0x91};
*
103B:  MOVLW  31
103C:  MOVWF  64
103D:  MOVLW  15
103E:  MOVWF  65
103F:  MOVWF  66
1040:  MOVLW  04
1041:  MOVWF  67
1042:  MOVLW  25
1043:  MOVWF  68
1044:  MOVLW  10
1045:  MOVWF  69
1046:  MOVLW  23
1047:  MOVWF  6A
1048:  MOVLW  90
1049:  MOVWF  6B
104A:  MOVLW  91
104B:  MOVWF  6C
.................... usi8 time_r[9]={0x30,0x30,0x10,0x08,0x20,0x02,0x20,0x90,0x91};
104C:  MOVLW  30
104D:  MOVWF  6D
104E:  MOVWF  6E
104F:  MOVLW  10
1050:  MOVWF  6F
1051:  MOVLW  08
1052:  MOVWF  70
1053:  MOVLW  20
1054:  MOVWF  71
1055:  MOVLW  02
1056:  MOVWF  72
1057:  MOVLW  20
1058:  MOVWF  73
1059:  MOVLW  90
105A:  MOVWF  74
105B:  MOVLW  91
105C:  MOVWF  75
.................... 
.................... #define dec_giay_eat  ds1307_bcdToDec(eat_ss)
.................... #define dec_phut_eat  ds1307_bcdToDec(eat_pp)
.................... #define dec_gio_eat   ds1307_bcdToDec(eat_hh)
.................... 
.................... #define dec_giay_ds  ds1307_bcdToDec(time_r[0])
.................... #define dec_phut_ds  ds1307_bcdToDec(time_r[1])
.................... #define dec_gio_ds   ds1307_bcdToDec(time_r[2])
.................... #define dec_thu_ds   ds1307_bcdToDec(time_r[3])
.................... #define dec_ngay_ds  ds1307_bcdToDec(time_r[4])
.................... #define dec_thang_ds ds1307_bcdToDec(time_r[5])
.................... #define dec_nam_ds   ds1307_bcdToDec(time_r[6])
.................... 
.................... #define giay_ds  time_r[0]
.................... #define phut_ds  time_r[1]
.................... #define gio_ds   time_r[2]
.................... #define thu_ds   time_r[3]
.................... #define ngay_ds  time_r[4]
.................... #define thang_ds time_r[5]
.................... #define nam_ds   time_r[6]
.................... 
.................... #define ma_qd   time_w[8]
.................... #define ma_ds   time_r[8]
.................... 
.................... usi8 ds1307_decToBcd(usi8 val) {
....................     return ((val / 10 * 16) + (val % 10));
.................... }
.................... 
.................... usi8 ds1307_bcdToDec(usi8 val) {
....................     return ((val / 16 * 10) + (val % 16));
*
060D:  BSF    03.5
060E:  SWAPF  23,W
060F:  MOVWF  77
0610:  MOVLW  0F
0611:  ANDWF  77,F
0612:  MOVF   77,W
0613:  MOVWF  25
0614:  MOVWF  26
0615:  MOVLW  0A
0616:  MOVWF  27
0617:  BCF    03.5
0618:  CALL   5E6
0619:  MOVF   78,W
061A:  BSF    03.5
061B:  MOVWF  24
061C:  MOVF   23,W
061D:  ANDLW  0F
061E:  ADDWF  24,W
061F:  MOVWF  78
0620:  BCF    03.5
0621:  RETURN
.................... }
.................... 
.................... void ds1307_read_time(usi8 j)     
.................... {   
....................    usi8 i; 
....................    i2c_start();
*
0176:  BSF    03.5
0177:  BSF    11.0
0178:  BTFSC  11.0
0179:  GOTO   178
....................    i2c_write(ds13_addr_wr);
017A:  MOVLW  D0
017B:  MOVWF  48
017C:  BCF    03.5
017D:  CALL   154
....................    i2c_write(0x00);                     
017E:  BSF    03.5
017F:  CLRF   48
0180:  BCF    03.5
0181:  CALL   154
....................    i2c_start();               
0182:  BSF    03.5
0183:  BSF    11.1
0184:  BTFSC  11.1
0185:  GOTO   184
....................    i2c_write(ds13_addr_rd);                              
0186:  MOVLW  D1
0187:  MOVWF  48
0188:  BCF    03.5
0189:  CALL   154
....................    for(i=0;i<j;i++) time_r[i]=i2c_read();
018A:  CLRF   7B
018B:  MOVF   76,W
018C:  SUBWF  7B,W
018D:  BTFSC  03.0
018E:  GOTO   19A
018F:  MOVLW  6D
0190:  ADDWF  7B,W
0191:  MOVWF  04
0192:  BCF    03.7
0193:  MOVLW  01
0194:  MOVWF  77
0195:  CALL   166
0196:  MOVF   78,W
0197:  MOVWF  00
0198:  INCF   7B,F
0199:  GOTO   18B
....................                                  
....................    i = i2c_read(0); //not ack, don't care i  
019A:  CLRF   77
019B:  CALL   166
019C:  MOVF   78,W
019D:  MOVWF  7B
....................    i2c_stop();
019E:  BSF    03.5
019F:  BSF    11.2
01A0:  BTFSC  11.2
01A1:  GOTO   1A0
01A2:  BCF    03.5
01A3:  RETURN
.................... }
.................... 
.................... void ds1307_update_time(int1 sel)                 
.................... {         
....................    usi8 i;
....................    i2c_start();
*
01AD:  BSF    03.5
01AE:  BSF    11.0
01AF:  BTFSC  11.0
01B0:  GOTO   1AF
....................    i2c_write(ds13_addr_wr);
01B1:  MOVLW  D0
01B2:  MOVWF  48
01B3:  BCF    03.5
01B4:  CALL   154
....................    i2c_write(0x00);
01B5:  BSF    03.5
01B6:  CLRF   48
01B7:  BCF    03.5
01B8:  CALL   154
....................    for(i=0;i<9;i++)                          
01B9:  CLRF   7B
01BA:  MOVF   7B,W
01BB:  SUBLW  08
01BC:  BTFSS  03.0
01BD:  GOTO   1D8
....................    {  
....................       if(sel)  i2c_write(time_w[i]);
01BE:  MOVF   76,F
01BF:  BTFSC  03.2
01C0:  GOTO   1CC
01C1:  MOVLW  64
01C2:  ADDWF  7B,W
01C3:  MOVWF  04
01C4:  BCF    03.7
01C5:  MOVF   00,W
01C6:  MOVWF  7C
01C7:  BSF    03.5
01C8:  MOVWF  48
01C9:  BCF    03.5
01CA:  CALL   154
01CB:  GOTO   1D6
....................       else     i2c_write(time_r[i]);
01CC:  MOVLW  6D
01CD:  ADDWF  7B,W
01CE:  MOVWF  04
01CF:  BCF    03.7
01D0:  MOVF   00,W
01D1:  MOVWF  7C
01D2:  BSF    03.5
01D3:  MOVWF  48
01D4:  BCF    03.5
01D5:  CALL   154
01D6:  INCF   7B,F
01D7:  GOTO   1BA
....................    }                                 
....................    i2c_stop();        
01D8:  BSF    03.5
01D9:  BSF    11.2
01DA:  BTFSC  11.2
01DB:  GOTO   1DA
01DC:  BCF    03.5
.................... }  
.................... 
.................... void ds1307_setup()
.................... {                                              
....................    ds1307_read_time(9);          
*
01A4:  MOVLW  09
01A5:  MOVWF  76
01A6:  CALL   176
....................    if(ma_qd!=ma_ds)
01A7:  MOVF   75,W
01A8:  SUBWF  6C,W
01A9:  BTFSC  03.2
01AA:  GOTO   1DD
....................    {
....................       ds1307_update_time(1);
01AB:  MOVLW  01
01AC:  MOVWF  76
....................    }
*
01DD:  BCF    0A.3
01DE:  BSF    0A.4
01DF:  GOTO   062 (RETURN)
.................... }
.................... 
.................... void ds1307_save_ds(usi8 dcdt,dt)                 
.................... {           
....................    i2c_start();
*
09A7:  BSF    03.5
09A8:  BSF    11.0
09A9:  BTFSC  11.0
09AA:  GOTO   1A9
....................    i2c_write(ds13_addr_wr);        
09AB:  MOVLW  D0
09AC:  MOVWF  48
09AD:  BCF    0A.3
09AE:  BCF    03.5
09AF:  CALL   154
09B0:  BSF    0A.3
....................    i2c_write(dcdt);    
09B1:  MOVF   76,W
09B2:  BSF    03.5
09B3:  MOVWF  48
09B4:  BCF    0A.3
09B5:  BCF    03.5
09B6:  CALL   154
09B7:  BSF    0A.3
....................    i2c_write(dt);
09B8:  MOVF   7B,W
09B9:  BSF    03.5
09BA:  MOVWF  48
09BB:  BCF    0A.3
09BC:  BCF    03.5
09BD:  CALL   154
09BE:  BSF    0A.3
....................    i2c_stop();
09BF:  BSF    03.5
09C0:  BSF    11.2
09C1:  BTFSC  11.2
09C2:  GOTO   1C1
09C3:  BCF    03.5
09C4:  RETURN
.................... }
.................... 
.................... #include <library_ds18b20.c>
.................... #include <touch.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                        Dallas Touch Driver                        ////
.................... ////                                                                   ////
.................... ////                                                                   ////
.................... ////  data = touch_read_bit()     Reads one bit from a touch device    ////
.................... ////                                                                   ////
.................... ////  data = touch_read_BYTE()    Reads one byte from a touch device.  ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_bit(data)  Writes one bit to a touch device     ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  ok = touch_write_byte(data) Writes one byte to a touch device    ////
.................... ////                              and returns true if all went ok.     ////
.................... ////                              A false indicates a collision with   ////
.................... ////                              another device.                      ////
.................... ////                                                                   ////
.................... ////  present = touch_present()   Issues a reset and returns true      ////
.................... ////                              if the touch device is there.        ////
.................... ////                                                                   ////
.................... ////  reset_pulse()               Issues a reset and waits for a       ////
.................... ////                              present pulse.                       ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef  TOUCH_C
.................... #define  TOUCH_C
.................... 
.................... #ifndef TOUCH_PIN
....................    #define TOUCH_PIN  PIN_B0
.................... #endif
.................... 
.................... #define TOUCH_PIN_LOW()    output_drive(TOUCH_PIN); output_low(TOUCH_PIN)
.................... #define TOUCH_PIN_HIGH()    output_drive(TOUCH_PIN); output_high(TOUCH_PIN)
.................... #define TOUCH_PIN_FLOAT()  output_float(TOUCH_PIN)
.................... #define TOUCH_PIN_READ()      input_state(TOUCH_PIN)
.................... 
.................... /////////////////////////////
.................... ////                     ////
.................... //// Function Prototypes ////
.................... ////                     ////
.................... /////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit();
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte();
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data);
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data);
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present();
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse();
.................... 
.................... //////////////////////////////////
.................... ////                          ////
.................... //// Function Implementations ////
.................... ////                          ////
.................... //////////////////////////////////
.................... 
.................... /*
.................... int1 touch_read_bit()
.................... This will read back a bit from the DS1993
.................... PARAMS: none
.................... RETURNS: A bit from the DS1993
.................... */
.................... int1 touch_read_bit()
.................... {
....................    int1 data;
.................... 
....................    TOUCH_PIN_LOW();
....................    delay_us(14);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    data = TOUCH_PIN_READ();
....................    delay_us(100);
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BYTE touch_read_byte()
.................... This will read back a byte from the DS1993
.................... PARAMS: none
.................... RETURNS: A byte from the DS1993
.................... */
.................... BYTE touch_read_byte()
.................... {
....................    BYTE i,data;
.................... 
....................    for(i=1; i <= 8; ++i)
....................       shift_right(&data, 1, touch_read_bit());
.................... 
....................    return data;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_bit(int1 data)
.................... This will write a bit to the DS1993
.................... PARAMS: The bit to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_bit(int1 data)
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(10);
....................    if(data)
....................    {
....................       TOUCH_PIN_HIGH();
....................       delay_us(10);
....................       if(!TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    else
....................    {
....................       TOUCH_PIN_LOW();
....................       delay_us(10);
....................       if(TOUCH_PIN_READ())
....................          return FALSE;
....................    }
....................    delay_us(50);
....................    TOUCH_PIN_HIGH();
....................    delay_us(50);
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_write_byte(BYTE data)
.................... This will write a byte to the DS1993
.................... PARAMS: The byte to write
.................... RETURNS: True if completed successfully, false if otherwise
.................... */
.................... BOOLEAN touch_write_byte(BYTE data)
.................... {
....................    BYTE i;
.................... 
....................    for(i=1; i<=8; ++i)
....................       if(!touch_write_bit(shift_right(&data, 1, 0)))
....................          return FALSE;
.................... 
....................    return TRUE;
.................... }
.................... 
.................... /*
.................... BOOLEAN touch_present()
.................... This will evaluate whether or not there is a touch present on the DS1993
.................... PARAMS: none
.................... RETURNS: True if a touch is present, false if otherwise
.................... */
.................... BOOLEAN touch_present()
.................... {
....................    BOOLEAN present;
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
.................... 
....................    if(!TOUCH_PIN_READ())
....................       return FALSE;
.................... 
....................    delay_us(65);
....................    present = !TOUCH_PIN_READ();
....................    delay_us(240);
....................    return present;
.................... }
.................... 
.................... /*
.................... void reset_pulse()
.................... This will send the DS1993 a reset pulse
.................... PARAMS: none
.................... RETURNS: none
.................... */
.................... void reset_pulse()
.................... {
....................    TOUCH_PIN_LOW();
....................    delay_us(500);
....................    TOUCH_PIN_FLOAT();
....................    delay_us(5);
....................    while(!touch_present());
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #define search_rom       0xf0
.................... #define read_rom         0x33
.................... #define match_rom        0x55
.................... #define skip_rom         0xcc
.................... #define alarm_search     0xec
.................... #define read_scratchpad  0xbe
.................... #define write_scratchpad 0x4e
.................... #define copy_scratchpad  0x48
.................... #define convert_t        0x44
.................... 
.................... bool ds18b20_start(){
....................    output_low(pin_ds18b20);
*
047E:  BCF    05.0
....................    output_drive(pin_ds18b20);
047F:  BSF    03.5
0480:  BCF    05.0
....................    delay_us(500);
0481:  MOVLW  02
0482:  MOVWF  22
0483:  MOVLW  F9
0484:  MOVWF  23
0485:  BCF    03.5
0486:  CALL   2EB
0487:  BSF    03.5
0488:  DECFSZ 22,F
0489:  GOTO   483
....................    output_float(pin_ds18b20);
048A:  BSF    05.0
....................    delay_us(100);
048B:  MOVLW  A6
048C:  MOVWF  77
048D:  DECFSZ 77,F
048E:  GOTO   48D
048F:  NOP
....................    if(!input(pin_ds18b20)){
0490:  BCF    03.5
0491:  BTFSC  05.0
0492:  GOTO   4A1
....................       delay_us(400);
0493:  MOVLW  02
0494:  BSF    03.5
0495:  MOVWF  22
0496:  MOVLW  C7
0497:  MOVWF  23
0498:  BCF    03.5
0499:  CALL   2EB
049A:  BSF    03.5
049B:  DECFSZ 22,F
049C:  GOTO   496
....................       return true;
049D:  MOVLW  01
049E:  MOVWF  78
049F:  GOTO   4A4
04A0:  BCF    03.5
....................    }
....................    return false;
04A1:  MOVLW  00
04A2:  MOVWF  78
04A3:  BSF    03.5
04A4:  BCF    03.5
04A5:  RETURN
.................... }
.................... 
.................... void ds18b20_write_bit(bool value){
....................    output_low(pin_ds18b20);
*
04BC:  BCF    03.5
04BD:  BCF    05.0
....................    output_drive(pin_ds18b20);
04BE:  BSF    03.5
04BF:  BCF    05.0
....................    delay_us(2);
04C0:  MOVLW  03
04C1:  MOVWF  77
04C2:  DECFSZ 77,F
04C3:  GOTO   4C2
....................    output_bit(pin_ds18b20, value);
04C4:  MOVF   25,F
04C5:  BTFSS  03.2
04C6:  GOTO   4CB
04C7:  BCF    03.5
04C8:  BCF    05.0
04C9:  GOTO   4CD
04CA:  BSF    03.5
04CB:  BCF    03.5
04CC:  BSF    05.0
....................    delay_us(80);
04CD:  MOVLW  85
04CE:  MOVWF  77
04CF:  DECFSZ 77,F
04D0:  GOTO   4CF
....................    output_float(pin_ds18b20);
04D1:  BSF    03.5
04D2:  BSF    05.0
....................    delay_us(2);
04D3:  MOVLW  03
04D4:  MOVWF  77
04D5:  DECFSZ 77,F
04D6:  GOTO   4D5
.................... }
.................... 
.................... void ds18b20_write_byte(int8 value){
....................    for(int8 i = 0; i < 8; i++)
*
04A6:  BSF    03.5
04A7:  CLRF   23
04A8:  MOVF   23,W
04A9:  SUBLW  07
04AA:  BTFSS  03.0
04AB:  GOTO   4D9
....................       ds18b20_write_bit(bit_test(value,i));
04AC:  MOVF   22,W
04AD:  MOVWF  77
04AE:  MOVF   23,W
04AF:  MOVWF  78
04B0:  BTFSC  03.2
04B1:  GOTO   4B6
04B2:  BCF    03.0
04B3:  RRF    77,F
04B4:  DECFSZ 78,F
04B5:  GOTO   4B2
04B6:  MOVLW  00
04B7:  BTFSC  77.0
04B8:  MOVLW  01
04B9:  MOVWF  24
04BA:  MOVF   24,W
04BB:  MOVWF  25
*
04D7:  INCF   23,F
04D8:  GOTO   4A8
04D9:  BCF    03.5
04DA:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_bit(){
....................    bool value;
....................    output_low(pin_ds18b20);
*
04E2:  BCF    03.5
04E3:  BCF    05.0
....................    output_drive(pin_ds18b20);
04E4:  BSF    03.5
04E5:  BCF    05.0
....................    delay_us(2);
04E6:  MOVLW  03
04E7:  MOVWF  77
04E8:  DECFSZ 77,F
04E9:  GOTO   4E8
....................    output_float(pin_ds18b20);
04EA:  BSF    05.0
....................    delay_us(5);
04EB:  MOVLW  08
04EC:  MOVWF  77
04ED:  DECFSZ 77,F
04EE:  GOTO   4ED
....................    value = input(pin_ds18b20);
04EF:  BCF    28.0
04F0:  BCF    03.5
04F1:  BTFSS  05.0
04F2:  GOTO   4F6
04F3:  BSF    03.5
04F4:  BSF    28.0
04F5:  BCF    03.5
....................    delay_us(100);
04F6:  MOVLW  A6
04F7:  MOVWF  77
04F8:  DECFSZ 77,F
04F9:  GOTO   4F8
04FA:  NOP
....................    return value;
04FB:  MOVLW  00
04FC:  BSF    03.5
04FD:  BTFSC  28.0
04FE:  MOVLW  01
04FF:  MOVWF  78
.................... }
.................... 
.................... int8 ds18b20_read_byte(){
*
04DB:  BSF    03.5
04DC:  CLRF   26
....................    int8 value = 0;
....................    for(int8 i = 0; i < 8; i++)
04DD:  CLRF   27
04DE:  MOVF   27,W
04DF:  SUBLW  07
04E0:  BTFSS  03.0
04E1:  GOTO   509
....................       shift_right(&value,1,ds18b20_read_bit());
*
0500:  MOVF   78,F
0501:  BTFSS  03.2
0502:  GOTO   505
0503:  BCF    03.0
0504:  GOTO   506
0505:  BSF    03.0
0506:  RRF    26,F
0507:  INCF   27,F
0508:  GOTO   4DE
....................    return value;
0509:  MOVF   26,W
050A:  MOVWF  78
050B:  BCF    03.5
050C:  RETURN
.................... }
.................... 
.................... bool ds18b20_read_temp_c2(usi16 *raw_temp_value){
....................    if(!ds18b20_start())
*
0537:  CALL   47E
0538:  MOVF   78,F
0539:  BTFSS  03.2
053A:  GOTO   53E
....................       return false;
053B:  MOVLW  00
053C:  MOVWF  78
053D:  GOTO   5A1
....................    ds18b20_write_byte(skip_rom);
053E:  MOVLW  CC
053F:  BSF    03.5
0540:  MOVWF  22
0541:  BCF    03.5
0542:  CALL   4A6
....................    ds18b20_write_byte(convert_t);
0543:  MOVLW  44
0544:  BSF    03.5
0545:  MOVWF  22
0546:  BCF    03.5
0547:  CALL   4A6
....................    while(ds18b20_read_byte() == 0);
0548:  CALL   4DB
0549:  MOVF   78,F
054A:  BTFSC  03.2
054B:  GOTO   548
....................    if(!ds18b20_start())
054C:  CALL   47E
054D:  MOVF   78,F
054E:  BTFSS  03.2
054F:  GOTO   553
....................       return false;
0550:  MOVLW  00
0551:  MOVWF  78
0552:  GOTO   5A1
....................    ds18b20_write_byte(skip_rom);
0553:  MOVLW  CC
0554:  BSF    03.5
0555:  MOVWF  22
0556:  BCF    03.5
0557:  CALL   4A6
....................    ds18b20_write_byte(read_scratchpad);
0558:  MOVLW  BE
0559:  BSF    03.5
055A:  MOVWF  22
055B:  BCF    03.5
055C:  CALL   4A6
....................    *raw_temp_value = ds18b20_read_byte();
055D:  MOVF   7C,W
055E:  MOVWF  7A
055F:  MOVF   7B,W
0560:  BSF    03.5
0561:  MOVWF  20
0562:  MOVF   7C,W
0563:  MOVWF  21
0564:  BCF    03.5
0565:  CALL   4DB
0566:  BSF    03.5
0567:  MOVF   20,W
0568:  MOVWF  04
0569:  BCF    03.7
056A:  BTFSC  21.0
056B:  BSF    03.7
056C:  INCF   04,F
056D:  CLRF   00
056E:  DECF   04,F
056F:  MOVF   78,W
0570:  MOVWF  00
....................    *raw_temp_value |= (int16)(ds18b20_read_byte()) << 8;
0571:  MOVF   7C,W
0572:  MOVWF  7A
0573:  MOVF   7B,W
0574:  MOVWF  20
0575:  MOVF   7C,W
0576:  MOVWF  21
0577:  MOVF   20,W
0578:  MOVWF  04
0579:  BCF    03.7
057A:  BTFSC  21.0
057B:  BSF    03.7
057C:  INCF   04,F
057D:  MOVF   00,W
057E:  MOVWF  23
057F:  DECF   04,F
0580:  MOVF   00,W
0581:  MOVWF  22
0582:  BCF    03.5
0583:  CALL   4DB
0584:  BSF    03.5
0585:  CLRF   25
0586:  MOVF   78,W
0587:  MOVWF  24
0588:  MOVWF  7A
0589:  MOVLW  00
058A:  IORWF  22,W
058B:  MOVWF  77
058C:  MOVF   7A,W
058D:  IORWF  23,W
058E:  MOVWF  7A
058F:  MOVF   77,W
0590:  MOVWF  22
0591:  MOVF   7A,W
0592:  MOVWF  23
0593:  MOVF   20,W
0594:  MOVWF  04
0595:  BCF    03.7
0596:  BTFSC  21.0
0597:  BSF    03.7
0598:  INCF   04,F
0599:  MOVF   23,W
059A:  MOVWF  00
059B:  DECF   04,F
059C:  MOVF   22,W
059D:  MOVWF  00
....................    return true;
059E:  MOVLW  01
059F:  MOVWF  78
05A0:  BCF    03.5
.................... }
.................... 
.................... void ds18b20_read_temp(){
....................    if(ds18b20_read_temp_c2(&temperature)){
*
0534:  CLRF   7C
0535:  MOVLW  3D
0536:  MOVWF  7B
*
05A1:  MOVF   78,F
05A2:  BTFSC  03.2
05A3:  GOTO   5E4
....................       isDs18b20 = true;
05A4:  BSF    2C.2
....................       dt_ng = temperature>>4;
05A5:  RRF    3E,W
05A6:  MOVWF  7A
05A7:  RRF    3D,W
05A8:  MOVWF  79
05A9:  RRF    7A,F
05AA:  RRF    79,F
05AB:  RRF    7A,F
05AC:  RRF    79,F
05AD:  RRF    7A,F
05AE:  RRF    79,F
05AF:  MOVF   79,W
05B0:  MOVWF  3F
....................       tt = temperature & 0x000f;
05B1:  MOVF   3D,W
05B2:  ANDLW  0F
05B3:  MOVWF  42
05B4:  CLRF   43
....................       dt_tp = (tt*625)/10;
05B5:  MOVF   43,W
05B6:  MOVWF  7C
05B7:  MOVF   42,W
05B8:  MOVWF  7B
05B9:  MOVLW  02
05BA:  MOVWF  7E
05BB:  MOVLW  71
05BC:  MOVWF  7D
*
05D2:  MOVF   79,W
05D3:  MOVWF  7C
05D4:  MOVF   78,W
05D5:  MOVWF  7B
05D6:  MOVF   79,W
05D7:  MOVWF  30
05D8:  MOVF   78,W
05D9:  MOVWF  2F
05DA:  CLRF   32
05DB:  MOVLW  0A
05DC:  MOVWF  31
05DD:  BCF    03.5
05DE:  CALL   50D
05DF:  MOVF   79,W
05E0:  MOVWF  41
05E1:  MOVF   78,W
05E2:  MOVWF  40
....................    }
05E3:  GOTO   5E5
....................    else isDs18b20 = false;
05E4:  BCF    2C.2
05E5:  RETURN
.................... }
.................... 
.................... #include <library_change_rtc.c>
.................... 
.................... usi8 tang_or_giam_bcd(unsigned int8 x, int1 sel){
....................    usi8 y, dv, ch, v;
....................    ch = (x>>4);
*
096C:  SWAPF  76,W
096D:  MOVWF  7E
096E:  MOVLW  0F
096F:  ANDWF  7E,F
....................    dv = x& 0x0f;
0970:  MOVF   76,W
0971:  ANDLW  0F
0972:  MOVWF  7D
....................    y = ch*10 + dv;
0973:  MOVF   7E,W
0974:  BSF    03.5
0975:  MOVWF  26
0976:  MOVLW  0A
0977:  MOVWF  27
0978:  BCF    0A.3
0979:  BCF    03.5
097A:  CALL   5E6
097B:  BSF    0A.3
097C:  MOVF   7D,W
097D:  ADDWF  78,W
097E:  MOVWF  7C
....................    if(sel == 0) y++;
097F:  MOVF   7B,F
0980:  BTFSS  03.2
0981:  GOTO   184
0982:  INCF   7C,F
0983:  GOTO   185
....................    else         y--;
0984:  DECF   7C,F
....................    ch = y/10; dv = y%10;
0985:  MOVF   7C,W
0986:  BSF    03.5
0987:  MOVWF  35
0988:  MOVLW  0A
0989:  MOVWF  36
098A:  BCF    0A.3
098B:  BCF    03.5
098C:  CALL   622
098D:  BSF    0A.3
098E:  MOVF   78,W
098F:  MOVWF  7E
0990:  MOVF   7C,W
0991:  BSF    03.5
0992:  MOVWF  35
0993:  MOVLW  0A
0994:  MOVWF  36
0995:  BCF    0A.3
0996:  BCF    03.5
0997:  CALL   622
0998:  BSF    0A.3
0999:  MOVF   77,W
099A:  MOVWF  7D
....................    v = (ch<<4)|dv;
099B:  SWAPF  7E,W
099C:  MOVWF  77
099D:  MOVLW  F0
099E:  ANDWF  77,F
099F:  MOVF   77,W
09A0:  IORWF  7D,W
09A1:  BSF    03.5
09A2:  MOVWF  20
....................    return v;
09A3:  MOVF   20,W
09A4:  MOVWF  78
09A5:  BCF    03.5
09A6:  RETURN
.................... }
.................... 
.................... void tat_bat_2led_chinh(){
....................    if(gt_mod == 1 || gt_mod == 4) { e_11 = ~e_11; e_22 = true; e_33 = true;}
*
086E:  DECFSZ 35,W
086F:  GOTO   071
0870:  GOTO   075
0871:  MOVF   35,W
0872:  SUBLW  04
0873:  BTFSS  03.2
0874:  GOTO   07A
0875:  MOVLW  08
0876:  XORWF  2C,F
0877:  BSF    2C.4
0878:  BSF    2C.5
0879:  GOTO   097
....................    else if(gt_mod == 2 || gt_mod == 5) { e_11 = true; e_22 = ~e_22; e_33 = true;}
087A:  MOVF   35,W
087B:  SUBLW  02
087C:  BTFSC  03.2
087D:  GOTO   082
087E:  MOVF   35,W
087F:  SUBLW  05
0880:  BTFSS  03.2
0881:  GOTO   087
0882:  BSF    2C.3
0883:  MOVLW  10
0884:  XORWF  2C,F
0885:  BSF    2C.5
0886:  GOTO   097
....................    else if(gt_mod == 3 || gt_mod == 6) { e_11 = true; e_22 = true; e_33 = ~e_33;}
0887:  MOVF   35,W
0888:  SUBLW  03
0889:  BTFSC  03.2
088A:  GOTO   08F
088B:  MOVF   35,W
088C:  SUBLW  06
088D:  BTFSS  03.2
088E:  GOTO   094
088F:  BSF    2C.3
0890:  BSF    2C.4
0891:  MOVLW  20
0892:  XORWF  2C,F
0893:  GOTO   097
....................    else { e_11 = true; e_22 = true; e_33 = true;}
0894:  BSF    2C.3
0895:  BSF    2C.4
0896:  BSF    2C.5
.................... }
.................... 
.................... void giai_ma_gpg_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_ds,dec_phut_ds,dec_giay_ds,e_33, e_22, e_11);
*
089C:  MOVF   6F,W
089D:  BSF    03.5
089E:  MOVWF  23
089F:  BCF    0A.3
08A0:  BCF    03.5
08A1:  CALL   60D
08A2:  BSF    0A.3
08A3:  MOVF   78,W
08A4:  BSF    03.5
08A5:  MOVWF  20
08A6:  BCF    03.5
08A7:  MOVF   6E,W
08A8:  BSF    03.5
08A9:  MOVWF  23
08AA:  BCF    0A.3
08AB:  BCF    03.5
08AC:  CALL   60D
08AD:  BSF    0A.3
08AE:  MOVF   78,W
08AF:  BSF    03.5
08B0:  MOVWF  21
08B1:  BCF    03.5
08B2:  MOVF   6D,W
08B3:  BSF    03.5
08B4:  MOVWF  23
08B5:  BCF    0A.3
08B6:  BCF    03.5
08B7:  CALL   60D
08B8:  BSF    0A.3
08B9:  MOVF   78,W
08BA:  BSF    03.5
08BB:  MOVWF  22
08BC:  MOVLW  00
08BD:  BCF    03.5
08BE:  BTFSC  2C.5
08BF:  MOVLW  01
08C0:  BSF    03.5
08C1:  MOVWF  23
08C2:  MOVLW  00
08C3:  BCF    03.5
08C4:  BTFSC  2C.4
08C5:  MOVLW  01
08C6:  BSF    03.5
08C7:  MOVWF  24
08C8:  MOVLW  00
08C9:  BCF    03.5
08CA:  BTFSC  2C.3
08CB:  MOVLW  01
08CC:  BSF    03.5
08CD:  MOVWF  25
08CE:  MOVLW  04
08CF:  MOVWF  27
08D0:  MOVLW  01
08D1:  MOVWF  28
08D2:  MOVF   20,W
08D3:  MOVWF  29
08D4:  MOVF   21,W
08D5:  MOVWF  2A
08D6:  MOVF   22,W
08D7:  MOVWF  2B
08D8:  MOVF   23,W
08D9:  MOVWF  2C
08DA:  MOVF   24,W
08DB:  MOVWF  2D
08DC:  MOVF   25,W
08DD:  MOVWF  2E
08DE:  BCF    0A.3
08DF:  BCF    03.5
08E0:  CALL   639
08E1:  BSF    0A.3
08E2:  RETURN
.................... }
.................... 
.................... void giai_ma_ntn_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_ngay_ds,dec_thang_ds,dec_nam_ds,e_33, e_22, e_11);
08E3:  MOVF   71,W
08E4:  BSF    03.5
08E5:  MOVWF  23
08E6:  BCF    0A.3
08E7:  BCF    03.5
08E8:  CALL   60D
08E9:  BSF    0A.3
08EA:  MOVF   78,W
08EB:  BSF    03.5
08EC:  MOVWF  20
08ED:  MOVF   72,W
08EE:  MOVWF  23
08EF:  BCF    0A.3
08F0:  BCF    03.5
08F1:  CALL   60D
08F2:  BSF    0A.3
08F3:  MOVF   78,W
08F4:  BSF    03.5
08F5:  MOVWF  21
08F6:  MOVF   73,W
08F7:  MOVWF  23
08F8:  BCF    0A.3
08F9:  BCF    03.5
08FA:  CALL   60D
08FB:  BSF    0A.3
08FC:  MOVF   78,W
08FD:  BSF    03.5
08FE:  MOVWF  22
08FF:  MOVLW  00
0900:  BCF    03.5
0901:  BTFSC  2C.5
0902:  MOVLW  01
0903:  BSF    03.5
0904:  MOVWF  23
0905:  MOVLW  00
0906:  BCF    03.5
0907:  BTFSC  2C.4
0908:  MOVLW  01
0909:  BSF    03.5
090A:  MOVWF  24
090B:  MOVLW  00
090C:  BCF    03.5
090D:  BTFSC  2C.3
090E:  MOVLW  01
090F:  BSF    03.5
0910:  MOVWF  25
0911:  MOVLW  04
0912:  MOVWF  27
0913:  MOVLW  01
0914:  MOVWF  28
0915:  MOVF   20,W
0916:  MOVWF  29
0917:  MOVF   21,W
0918:  MOVWF  2A
0919:  MOVF   22,W
091A:  MOVWF  2B
091B:  MOVF   23,W
091C:  MOVWF  2C
091D:  MOVF   24,W
091E:  MOVWF  2D
091F:  MOVF   25,W
0920:  MOVWF  2E
0921:  BCF    0A.3
0922:  BCF    03.5
0923:  CALL   639
0924:  BSF    0A.3
0925:  RETURN
.................... }
.................... 
.................... void giai_ma_thu_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,0x00,dec_thu_ds,0x00,0, e_22, 0);
0926:  MOVF   70,W
0927:  BSF    03.5
0928:  MOVWF  23
0929:  BCF    0A.3
092A:  BCF    03.5
092B:  CALL   60D
092C:  BSF    0A.3
092D:  MOVF   78,W
092E:  MOVWF  7B
092F:  MOVLW  00
0930:  BTFSC  2C.4
0931:  MOVLW  01
0932:  MOVWF  7C
0933:  MOVLW  04
0934:  BSF    03.5
0935:  MOVWF  27
0936:  MOVLW  01
0937:  MOVWF  28
0938:  CLRF   29
0939:  MOVF   78,W
093A:  MOVWF  2A
093B:  CLRF   2B
093C:  CLRF   2C
093D:  MOVF   7C,W
093E:  MOVWF  2D
093F:  CLRF   2E
0940:  BCF    0A.3
0941:  BCF    03.5
0942:  CALL   639
0943:  BSF    0A.3
0944:  RETURN
.................... }
.................... 
.................... void giai_ma_gpg_ntn_thu_lcd(){
....................    if(gt_mod == 0){
0945:  MOVF   35,F
0946:  BTFSS  03.2
0947:  GOTO   157
....................       if(tt_ht == 0 || tt_ht == 1) giai_ma_gpg_lcd();
0948:  MOVF   34,F
0949:  BTFSC  03.2
094A:  GOTO   14D
094B:  DECFSZ 34,W
094C:  GOTO   14E
094D:  CALL   09C
....................       if(tt_ht == 2) giai_ma_ntn_lcd();
094E:  MOVF   34,W
094F:  SUBLW  02
0950:  BTFSC  03.2
0951:  CALL   0E3
....................       if(tt_ht == 3) giai_ma_thu_lcd();
0952:  MOVF   34,W
0953:  SUBLW  03
0954:  BTFSC  03.2
0955:  CALL   126
....................    }
0956:  GOTO   16B
....................    else{
....................       if(gt_mod < 4)       giai_ma_gpg_lcd();
0957:  BTFSC  35.7
0958:  GOTO   15D
0959:  MOVF   35,W
095A:  SUBLW  03
095B:  BTFSS  03.0
095C:  GOTO   15F
095D:  CALL   09C
095E:  GOTO   16B
....................       else if(gt_mod < 7)  giai_ma_ntn_lcd();
095F:  BTFSC  35.7
0960:  GOTO   165
0961:  MOVF   35,W
0962:  SUBLW  06
0963:  BTFSS  03.0
0964:  GOTO   167
0965:  CALL   0E3
0966:  GOTO   16B
....................       else if(gt_mod == 7) giai_ma_thu_lcd();
0967:  MOVF   35,W
0968:  SUBLW  07
0969:  BTFSC  03.2
096A:  CALL   126
....................    }
096B:  RETURN
.................... }
.................... 
.................... void xu_ly_choptat(){
....................    if(gt_mod != 0){
*
086B:  MOVF   35,F
086C:  BTFSC  03.2
086D:  GOTO   098
....................       tat_bat_2led_chinh();
....................    }
*
0897:  GOTO   09B
....................    else { e_11 = true; e_22 = true; e_33 = true;}
0898:  BSF    2C.3
0899:  BSF    2C.4
089A:  BSF    2C.5
089B:  RETURN
....................    
.................... }
.................... 
.................... void phim_chon_hthi_mode(){
....................    if(tick_btn(2, bt3)){
*
1395:  MOVLW  02
1396:  MOVWF  76
1397:  MOVLW  33
1398:  MOVWF  7B
1399:  BCF    0A.4
139A:  CALL   7D7
139B:  BSF    0A.4
139C:  MOVF   78,F
139D:  BTFSC  03.2
139E:  GOTO   3C6
....................       tt_ht = 1;
139F:  MOVLW  01
13A0:  MOVWF  34
....................       if(tt_ht == 1){
13A1:  DECFSZ 34,W
13A2:  GOTO   3C0
....................          gt_mod++;
13A3:  INCF   35,F
....................          if(gt_mod < 4) tt_ht = 1;
13A4:  BTFSC  35.7
13A5:  GOTO   3AA
13A6:  MOVF   35,W
13A7:  SUBLW  03
13A8:  BTFSS  03.0
13A9:  GOTO   3AD
13AA:  MOVLW  01
13AB:  MOVWF  34
13AC:  GOTO   3C0
....................          else if(gt_mod < 7) tt_ht = 2;
13AD:  BTFSC  35.7
13AE:  GOTO   3B3
13AF:  MOVF   35,W
13B0:  SUBLW  06
13B1:  BTFSS  03.0
13B2:  GOTO   3B6
13B3:  MOVLW  02
13B4:  MOVWF  34
13B5:  GOTO   3C0
....................          else if(gt_mod == 7) tt_ht = 3;
13B6:  MOVF   35,W
13B7:  SUBLW  07
13B8:  BTFSS  03.2
13B9:  GOTO   3BD
13BA:  MOVLW  03
13BB:  MOVWF  34
13BC:  GOTO   3C0
....................          else{
....................             gt_mod = 0;
13BD:  CLRF   35
....................             tt_ht = 0;
13BE:  CLRF   34
....................             countLevel = 0;
13BF:  CLRF   3A
....................          }
....................       }
....................       tg_chinh = 0;
13C0:  CLRF   36
....................       giai_ma_gpg_ntn_thu_lcd();
13C1:  BCF    0A.4
13C2:  BSF    0A.3
13C3:  CALL   145
13C4:  BSF    0A.4
13C5:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay(){
....................    if(giay_ds == 0x59) giay_ds = 0;
*
13E2:  MOVF   6D,W
13E3:  SUBLW  59
13E4:  BTFSS  03.2
13E5:  GOTO   3E8
13E6:  CLRF   6D
13E7:  GOTO   3F2
....................    else giay_ds = tang_or_giam_bcd(giay_ds, tang);
13E8:  MOVF   6D,W
13E9:  MOVWF  76
13EA:  CLRF   7B
13EB:  BCF    0A.4
13EC:  BSF    0A.3
13ED:  CALL   16C
13EE:  BSF    0A.4
13EF:  BCF    0A.3
13F0:  MOVF   78,W
13F1:  MOVWF  6D
....................    ds1307_save_ds(0,giay_ds);
13F2:  CLRF   76
13F3:  MOVF   6D,W
13F4:  MOVWF  7B
13F5:  BCF    0A.4
13F6:  BSF    0A.3
13F7:  CALL   1A7
13F8:  BSF    0A.4
13F9:  BCF    0A.3
.................... }
.................... void tang_phut(){
....................    if(phut_ds == 0x59) phut_ds = 0;
*
13FB:  MOVF   6E,W
13FC:  SUBLW  59
13FD:  BTFSS  03.2
13FE:  GOTO   401
13FF:  CLRF   6E
1400:  GOTO   40B
....................    else phut_ds = tang_or_giam_bcd(phut_ds, tang);
1401:  MOVF   6E,W
1402:  MOVWF  76
1403:  CLRF   7B
1404:  BCF    0A.4
1405:  BSF    0A.3
1406:  CALL   16C
1407:  BSF    0A.4
1408:  BCF    0A.3
1409:  MOVF   78,W
140A:  MOVWF  6E
....................    ds1307_save_ds(1,phut_ds);
140B:  MOVLW  01
140C:  MOVWF  76
140D:  MOVF   6E,W
140E:  MOVWF  7B
140F:  BCF    0A.4
1410:  BSF    0A.3
1411:  CALL   1A7
1412:  BSF    0A.4
1413:  BCF    0A.3
.................... }
.................... void tang_gio(){
....................    if(gio_ds == 0x23) gio_ds = 0;
*
1415:  MOVF   6F,W
1416:  SUBLW  23
1417:  BTFSS  03.2
1418:  GOTO   41B
1419:  CLRF   6F
141A:  GOTO   425
....................    else gio_ds = tang_or_giam_bcd(gio_ds, tang);
141B:  MOVF   6F,W
141C:  MOVWF  76
141D:  CLRF   7B
141E:  BCF    0A.4
141F:  BSF    0A.3
1420:  CALL   16C
1421:  BSF    0A.4
1422:  BCF    0A.3
1423:  MOVF   78,W
1424:  MOVWF  6F
....................    ds1307_save_ds(2,gio_ds);
1425:  MOVLW  02
1426:  MOVWF  76
1427:  MOVF   6F,W
1428:  MOVWF  7B
1429:  BCF    0A.4
142A:  BSF    0A.3
142B:  CALL   1A7
142C:  BSF    0A.4
142D:  BCF    0A.3
.................... }
.................... void chinh_tang_gpg(){
....................    switch(gt_mod){
*
13D7:  MOVF   35,W
13D8:  XORLW  01
13D9:  BTFSC  03.2
13DA:  GOTO   3E2
13DB:  XORLW  03
13DC:  BTFSC  03.2
13DD:  GOTO   3FB
13DE:  XORLW  01
13DF:  BTFSC  03.2
13E0:  GOTO   415
13E1:  GOTO   42F
....................       case 1:
....................          tang_giay();
....................          break;
*
13FA:  GOTO   430
....................       case 2:
....................          tang_phut();
....................          break;
*
1414:  GOTO   430
....................       case 3:
....................          tang_gio();
....................          break;
*
142E:  GOTO   430
....................       default: break;
142F:  GOTO   430
....................    }
.................... }
.................... void tang_nam(){
....................    if(nam_ds == 0x99) nam_ds = 0;
*
1442:  MOVF   73,W
1443:  SUBLW  99
1444:  BTFSS  03.2
1445:  GOTO   448
1446:  CLRF   73
1447:  GOTO   452
....................    else nam_ds = tang_or_giam_bcd(nam_ds, tang);
1448:  MOVF   73,W
1449:  MOVWF  76
144A:  CLRF   7B
144B:  BCF    0A.4
144C:  BSF    0A.3
144D:  CALL   16C
144E:  BSF    0A.4
144F:  BCF    0A.3
1450:  MOVF   78,W
1451:  MOVWF  73
....................    ds1307_save_ds(6,nam_ds);
1452:  MOVLW  06
1453:  MOVWF  76
1454:  MOVF   73,W
1455:  MOVWF  7B
1456:  BCF    0A.4
1457:  BSF    0A.3
1458:  CALL   1A7
1459:  BSF    0A.4
145A:  BCF    0A.3
.................... }
.................... void tang_thang(){
....................    if(thang_ds == 0x12) thang_ds = 1;
*
145C:  MOVF   72,W
145D:  SUBLW  12
145E:  BTFSS  03.2
145F:  GOTO   463
1460:  MOVLW  01
1461:  MOVWF  72
1462:  GOTO   46D
....................    else thang_ds = tang_or_giam_bcd(thang_ds, tang);
1463:  MOVF   72,W
1464:  MOVWF  76
1465:  CLRF   7B
1466:  BCF    0A.4
1467:  BSF    0A.3
1468:  CALL   16C
1469:  BSF    0A.4
146A:  BCF    0A.3
146B:  MOVF   78,W
146C:  MOVWF  72
....................    ds1307_save_ds(5,thang_ds);
146D:  MOVLW  05
146E:  MOVWF  76
146F:  MOVF   72,W
1470:  MOVWF  7B
1471:  BCF    0A.4
1472:  BSF    0A.3
1473:  CALL   1A7
1474:  BSF    0A.4
1475:  BCF    0A.3
.................... }
.................... void tang_ngay(){
....................    if(ngay_ds == 0x31) ngay_ds = 1;
*
1477:  MOVF   71,W
1478:  SUBLW  31
1479:  BTFSS  03.2
147A:  GOTO   47E
147B:  MOVLW  01
147C:  MOVWF  71
147D:  GOTO   488
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, tang);
147E:  MOVF   71,W
147F:  MOVWF  76
1480:  CLRF   7B
1481:  BCF    0A.4
1482:  BSF    0A.3
1483:  CALL   16C
1484:  BSF    0A.4
1485:  BCF    0A.3
1486:  MOVF   78,W
1487:  MOVWF  71
....................    ds1307_save_ds(4,ngay_ds);
1488:  MOVLW  04
1489:  MOVWF  76
148A:  MOVF   71,W
148B:  MOVWF  7B
148C:  BCF    0A.4
148D:  BSF    0A.3
148E:  CALL   1A7
148F:  BSF    0A.4
1490:  BCF    0A.3
.................... }
.................... void chinh_tang_ntn(){
....................    switch(gt_mod){
*
1437:  MOVF   35,W
1438:  XORLW  04
1439:  BTFSC  03.2
143A:  GOTO   442
143B:  XORLW  01
143C:  BTFSC  03.2
143D:  GOTO   45C
143E:  XORLW  03
143F:  BTFSC  03.2
1440:  GOTO   477
1441:  GOTO   492
....................       case 4:
....................          tang_nam();
....................          break;
*
145B:  GOTO   493
....................       case 5:
....................          tang_thang();
....................          break;
*
1476:  GOTO   493
....................       case 6:
....................          tang_ngay();
....................          break;
*
1491:  GOTO   493
....................       default: break;
1492:  GOTO   493
....................    }
.................... }
.................... void chinh_tang_thu(){
....................    if(thu_ds == 8) thu_ds = 2;
*
1498:  MOVF   70,W
1499:  SUBLW  08
149A:  BTFSS  03.2
149B:  GOTO   49F
149C:  MOVLW  02
149D:  MOVWF  70
149E:  GOTO   4A0
....................    else thu_ds++;
149F:  INCF   70,F
....................    ds1307_save_ds(3,thu_ds);
14A0:  MOVLW  03
14A1:  MOVWF  76
14A2:  MOVF   70,W
14A3:  MOVWF  7B
14A4:  BCF    0A.4
14A5:  BSF    0A.3
14A6:  CALL   1A7
14A7:  BSF    0A.4
14A8:  BCF    0A.3
.................... }
.................... 
.................... void phim_up(){
....................    if(tick_btn(1, bt1)){
*
13C6:  MOVLW  01
13C7:  MOVWF  76
13C8:  MOVLW  31
13C9:  MOVWF  7B
13CA:  BCF    0A.4
13CB:  CALL   7D7
13CC:  BSF    0A.4
13CD:  MOVF   78,F
13CE:  BTFSC  03.2
13CF:  GOTO   4B1
....................       tg_chinh = 0;
13D0:  CLRF   36
....................       if(gt_mod<4) chinh_tang_gpg();
13D1:  BTFSC  35.7
13D2:  GOTO   3D7
13D3:  MOVF   35,W
13D4:  SUBLW  03
13D5:  BTFSS  03.0
13D6:  GOTO   431
*
1430:  GOTO   4A9
....................       else if(gt_mod<7) chinh_tang_ntn();
1431:  BTFSC  35.7
1432:  GOTO   437
1433:  MOVF   35,W
1434:  SUBLW  06
1435:  BTFSS  03.0
1436:  GOTO   494
*
1493:  GOTO   4A9
....................       else if(gt_mod==7) chinh_tang_thu();
1494:  MOVF   35,W
1495:  SUBLW  07
1496:  BTFSS  03.2
1497:  GOTO   4A9
....................       e_11 = true; e_22 = true; e_33 = true;
*
14A9:  BSF    2C.3
14AA:  BSF    2C.4
14AB:  BSF    2C.5
....................       giai_ma_gpg_ntn_thu_lcd();
14AC:  BCF    0A.4
14AD:  BSF    0A.3
14AE:  CALL   145
14AF:  BSF    0A.4
14B0:  BCF    0A.3
....................    }
.................... }
.................... void giam_giay(){
....................    if(giay_ds == 0) giay_ds = 0x59;
*
14CD:  MOVF   6D,F
14CE:  BTFSS  03.2
14CF:  GOTO   4D3
14D0:  MOVLW  59
14D1:  MOVWF  6D
14D2:  GOTO   4DE
....................    else giay_ds = tang_or_giam_bcd(giay_ds,giam);
14D3:  MOVF   6D,W
14D4:  MOVWF  76
14D5:  MOVLW  01
14D6:  MOVWF  7B
14D7:  BCF    0A.4
14D8:  BSF    0A.3
14D9:  CALL   16C
14DA:  BSF    0A.4
14DB:  BCF    0A.3
14DC:  MOVF   78,W
14DD:  MOVWF  6D
....................    ds1307_save_ds(0,giay_ds);
14DE:  CLRF   76
14DF:  MOVF   6D,W
14E0:  MOVWF  7B
14E1:  BCF    0A.4
14E2:  BSF    0A.3
14E3:  CALL   1A7
14E4:  BSF    0A.4
14E5:  BCF    0A.3
.................... }
.................... void giam_phut(){
....................    if(phut_ds == 0) phut_ds = 0x59;
*
14E7:  MOVF   6E,F
14E8:  BTFSS  03.2
14E9:  GOTO   4ED
14EA:  MOVLW  59
14EB:  MOVWF  6E
14EC:  GOTO   4F8
....................    else phut_ds = tang_or_giam_bcd(phut_ds,giam);
14ED:  MOVF   6E,W
14EE:  MOVWF  76
14EF:  MOVLW  01
14F0:  MOVWF  7B
14F1:  BCF    0A.4
14F2:  BSF    0A.3
14F3:  CALL   16C
14F4:  BSF    0A.4
14F5:  BCF    0A.3
14F6:  MOVF   78,W
14F7:  MOVWF  6E
....................    ds1307_save_ds(1,phut_ds);
14F8:  MOVLW  01
14F9:  MOVWF  76
14FA:  MOVF   6E,W
14FB:  MOVWF  7B
14FC:  BCF    0A.4
14FD:  BSF    0A.3
14FE:  CALL   1A7
14FF:  BSF    0A.4
1500:  BCF    0A.3
.................... }
.................... void giam_gio(){
....................    if(gio_ds == 0) gio_ds = 0x23;
*
1502:  MOVF   6F,F
1503:  BTFSS  03.2
1504:  GOTO   508
1505:  MOVLW  23
1506:  MOVWF  6F
1507:  GOTO   513
....................    else gio_ds = tang_or_giam_bcd(gio_ds,giam);
1508:  MOVF   6F,W
1509:  MOVWF  76
150A:  MOVLW  01
150B:  MOVWF  7B
150C:  BCF    0A.4
150D:  BSF    0A.3
150E:  CALL   16C
150F:  BSF    0A.4
1510:  BCF    0A.3
1511:  MOVF   78,W
1512:  MOVWF  6F
....................    ds1307_save_ds(2,gio_ds);
1513:  MOVLW  02
1514:  MOVWF  76
1515:  MOVF   6F,W
1516:  MOVWF  7B
1517:  BCF    0A.4
1518:  BSF    0A.3
1519:  CALL   1A7
151A:  BSF    0A.4
151B:  BCF    0A.3
.................... }
.................... void chinh_giam_gpg(){
....................    switch(gt_mod){
*
14C2:  MOVF   35,W
14C3:  XORLW  01
14C4:  BTFSC  03.2
14C5:  GOTO   4CD
14C6:  XORLW  03
14C7:  BTFSC  03.2
14C8:  GOTO   4E7
14C9:  XORLW  01
14CA:  BTFSC  03.2
14CB:  GOTO   502
14CC:  GOTO   51D
....................       case 1:
....................          giam_giay();
....................          break;
*
14E6:  GOTO   51E
....................       case 2:
....................          giam_phut();
....................          break;
*
1501:  GOTO   51E
....................       case 3:
....................          giam_gio();
....................          break;
*
151C:  GOTO   51E
....................       default: break;
151D:  GOTO   51E
....................    }
.................... }
.................... void giam_nam(){
....................    if(nam_ds == 0x0) nam_ds = 0x99;
*
1530:  MOVF   73,F
1531:  BTFSS  03.2
1532:  GOTO   536
1533:  MOVLW  99
1534:  MOVWF  73
1535:  GOTO   541
....................    else nam_ds = tang_or_giam_bcd(nam_ds, giam);
1536:  MOVF   73,W
1537:  MOVWF  76
1538:  MOVLW  01
1539:  MOVWF  7B
153A:  BCF    0A.4
153B:  BSF    0A.3
153C:  CALL   16C
153D:  BSF    0A.4
153E:  BCF    0A.3
153F:  MOVF   78,W
1540:  MOVWF  73
....................    ds1307_save_ds(6,nam_ds);
1541:  MOVLW  06
1542:  MOVWF  76
1543:  MOVF   73,W
1544:  MOVWF  7B
1545:  BCF    0A.4
1546:  BSF    0A.3
1547:  CALL   1A7
1548:  BSF    0A.4
1549:  BCF    0A.3
.................... }
.................... void giam_thang(){
....................    if(thang_ds == 0x1) thang_ds = 12;
*
154B:  DECFSZ 72,W
154C:  GOTO   550
154D:  MOVLW  0C
154E:  MOVWF  72
154F:  GOTO   55B
....................    else thang_ds = tang_or_giam_bcd(thang_ds, giam);
1550:  MOVF   72,W
1551:  MOVWF  76
1552:  MOVLW  01
1553:  MOVWF  7B
1554:  BCF    0A.4
1555:  BSF    0A.3
1556:  CALL   16C
1557:  BSF    0A.4
1558:  BCF    0A.3
1559:  MOVF   78,W
155A:  MOVWF  72
....................    ds1307_save_ds(5,thang_ds);
155B:  MOVLW  05
155C:  MOVWF  76
155D:  MOVF   72,W
155E:  MOVWF  7B
155F:  BCF    0A.4
1560:  BSF    0A.3
1561:  CALL   1A7
1562:  BSF    0A.4
1563:  BCF    0A.3
.................... }
.................... void giam_ngay(){
....................    if(ngay_ds == 0x1) ngay_ds = 21;
*
1565:  DECFSZ 71,W
1566:  GOTO   56A
1567:  MOVLW  15
1568:  MOVWF  71
1569:  GOTO   575
....................    else ngay_ds = tang_or_giam_bcd(ngay_ds, giam);
156A:  MOVF   71,W
156B:  MOVWF  76
156C:  MOVLW  01
156D:  MOVWF  7B
156E:  BCF    0A.4
156F:  BSF    0A.3
1570:  CALL   16C
1571:  BSF    0A.4
1572:  BCF    0A.3
1573:  MOVF   78,W
1574:  MOVWF  71
....................    ds1307_save_ds(4,ngay_ds);
1575:  MOVLW  04
1576:  MOVWF  76
1577:  MOVF   71,W
1578:  MOVWF  7B
1579:  BCF    0A.4
157A:  BSF    0A.3
157B:  CALL   1A7
157C:  BSF    0A.4
157D:  BCF    0A.3
.................... }
.................... void chinh_giam_ntn(){
....................    switch(gt_mod){
*
1525:  MOVF   35,W
1526:  XORLW  04
1527:  BTFSC  03.2
1528:  GOTO   530
1529:  XORLW  01
152A:  BTFSC  03.2
152B:  GOTO   54B
152C:  XORLW  03
152D:  BTFSC  03.2
152E:  GOTO   565
152F:  GOTO   57F
....................       case 4:
....................          giam_nam();
....................          break;
*
154A:  GOTO   580
....................       case 5:
....................          giam_thang();
....................          break;
*
1564:  GOTO   580
....................       case 6:
....................          giam_ngay();
....................          break;
*
157E:  GOTO   580
....................       default: break;
157F:  GOTO   580
....................    }
.................... }
.................... void chinh_giam_thu(){
....................    if(thu_ds == 2) thu_ds = 8;
*
1585:  MOVF   70,W
1586:  SUBLW  02
1587:  BTFSS  03.2
1588:  GOTO   58C
1589:  MOVLW  08
158A:  MOVWF  70
158B:  GOTO   58D
....................    else thu_ds--;
158C:  DECF   70,F
....................    ds1307_save_ds(3,thu_ds);
158D:  MOVLW  03
158E:  MOVWF  76
158F:  MOVF   70,W
1590:  MOVWF  7B
1591:  BCF    0A.4
1592:  BSF    0A.3
1593:  CALL   1A7
1594:  BSF    0A.4
1595:  BCF    0A.3
.................... }
.................... void phim_dw(){
....................    if(tick_btn(1, bt2)){
*
14B1:  MOVLW  01
14B2:  MOVWF  76
14B3:  MOVLW  32
14B4:  MOVWF  7B
14B5:  BCF    0A.4
14B6:  CALL   7D7
14B7:  BSF    0A.4
14B8:  MOVF   78,F
14B9:  BTFSC  03.2
14BA:  GOTO   59E
....................       tg_chinh = 0;
14BB:  CLRF   36
....................       if(gt_mod<4) chinh_giam_gpg();
14BC:  BTFSC  35.7
14BD:  GOTO   4C2
14BE:  MOVF   35,W
14BF:  SUBLW  03
14C0:  BTFSS  03.0
14C1:  GOTO   51F
*
151E:  GOTO   596
....................       else if(gt_mod<7) chinh_giam_ntn();
151F:  BTFSC  35.7
1520:  GOTO   525
1521:  MOVF   35,W
1522:  SUBLW  06
1523:  BTFSS  03.0
1524:  GOTO   581
*
1580:  GOTO   596
....................       else if(gt_mod==7) chinh_giam_thu();
1581:  MOVF   35,W
1582:  SUBLW  07
1583:  BTFSS  03.2
1584:  GOTO   596
....................       e_11 = true; e_22 = true; e_33 = true;
*
1596:  BSF    2C.3
1597:  BSF    2C.4
1598:  BSF    2C.5
....................       giai_ma_gpg_ntn_thu_lcd();
1599:  BCF    0A.4
159A:  BSF    0A.3
159B:  CALL   145
159C:  BSF    0A.4
159D:  BCF    0A.3
....................    }
.................... }
.................... void log_mode(){
....................    lcd_setCursor(0, 1);
*
15BC:  BSF    03.5
15BD:  CLRF   35
15BE:  MOVLW  01
15BF:  MOVWF  36
15C0:  BCF    0A.4
15C1:  BCF    03.5
15C2:  CALL   317
15C3:  BSF    0A.4
....................    if(tt_ht == 0) lcd_data(" N ");
15C4:  MOVF   34,F
15C5:  BTFSS  03.2
15C6:  GOTO   5D1
15C7:  MOVLW  DF
15C8:  BSF    03.6
15C9:  MOVWF  0D
15CA:  MOVLW  00
15CB:  MOVWF  0F
15CC:  BCF    0A.4
15CD:  BCF    03.6
15CE:  CALL   353
15CF:  BSF    0A.4
15D0:  GOTO   5F8
....................    else if(tt_ht == 1) lcd_data("GPG");
15D1:  DECFSZ 34,W
15D2:  GOTO   5DD
15D3:  MOVLW  E1
15D4:  BSF    03.6
15D5:  MOVWF  0D
15D6:  MOVLW  00
15D7:  MOVWF  0F
15D8:  BCF    0A.4
15D9:  BCF    03.6
15DA:  CALL   353
15DB:  BSF    0A.4
15DC:  GOTO   5F8
....................    else if(tt_ht == 2) lcd_data("NTN");
15DD:  MOVF   34,W
15DE:  SUBLW  02
15DF:  BTFSS  03.2
15E0:  GOTO   5EB
15E1:  MOVLW  E3
15E2:  BSF    03.6
15E3:  MOVWF  0D
15E4:  MOVLW  00
15E5:  MOVWF  0F
15E6:  BCF    0A.4
15E7:  BCF    03.6
15E8:  CALL   353
15E9:  BSF    0A.4
15EA:  GOTO   5F8
....................    else if(tt_ht == 3) lcd_data(" T ");
15EB:  MOVF   34,W
15EC:  SUBLW  03
15ED:  BTFSS  03.2
15EE:  GOTO   5F8
15EF:  MOVLW  E5
15F0:  BSF    03.6
15F1:  MOVWF  0D
15F2:  MOVLW  00
15F3:  MOVWF  0F
15F4:  BCF    0A.4
15F5:  BCF    03.6
15F6:  CALL   353
15F7:  BSF    0A.4
....................    lcd_setCursor(13, 1);
15F8:  MOVLW  0D
15F9:  BSF    03.5
15FA:  MOVWF  35
15FB:  MOVLW  01
15FC:  MOVWF  36
15FD:  BCF    0A.4
15FE:  BCF    03.5
15FF:  CALL   317
1600:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
1601:  MOVLW  30
1602:  ADDWF  35,W
1603:  MOVWF  76
1604:  BSF    03.5
1605:  MOVWF  38
1606:  BCF    0A.4
1607:  BCF    03.5
1608:  CALL   336
1609:  BSF    0A.4
....................    if(gt_mod != 0){
160A:  MOVF   35,F
160B:  BTFSC  03.2
160C:  GOTO   632
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
160D:  MOVF   36,W
160E:  MOVWF  7B
160F:  MOVLW  0A
1610:  MOVWF  7C
1611:  BCF    0A.4
1612:  BSF    0A.3
1613:  CALL   1C5
1614:  BSF    0A.4
1615:  BCF    0A.3
1616:  MOVLW  30
1617:  ADDWF  78,W
1618:  MOVWF  76
1619:  BSF    03.5
161A:  MOVWF  38
161B:  BCF    0A.4
161C:  BCF    03.5
161D:  CALL   336
161E:  BSF    0A.4
161F:  MOVF   36,W
1620:  MOVWF  7B
1621:  MOVLW  0A
1622:  MOVWF  7C
1623:  BCF    0A.4
1624:  BSF    0A.3
1625:  CALL   1C5
1626:  BSF    0A.4
1627:  BCF    0A.3
1628:  MOVLW  30
1629:  ADDWF  77,W
162A:  MOVWF  76
162B:  BSF    03.5
162C:  MOVWF  38
162D:  BCF    0A.4
162E:  BCF    03.5
162F:  CALL   336
1630:  BSF    0A.4
....................    }
1631:  GOTO   63B
....................    else
....................       lcd_data("__");
1632:  MOVLW  E7
1633:  BSF    03.6
1634:  MOVWF  0D
1635:  MOVLW  00
1636:  MOVWF  0F
1637:  BCF    0A.4
1638:  BCF    03.6
1639:  CALL   353
163A:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_change_alarm_eat.c>
.................... void giai_ma_gpg_alarm_lcd(){
....................    lcd_dis_xx_yy_zz(4,1,dec_gio_eat,dec_phut_eat,dec_giay_eat,e_33, e_22, e_11);
*
09EA:  MOVF   37,W
09EB:  BSF    03.5
09EC:  MOVWF  23
09ED:  BCF    0A.3
09EE:  BCF    03.5
09EF:  CALL   60D
09F0:  BSF    0A.3
09F1:  MOVF   78,W
09F2:  BSF    03.5
09F3:  MOVWF  20
09F4:  BCF    03.5
09F5:  MOVF   38,W
09F6:  BSF    03.5
09F7:  MOVWF  23
09F8:  BCF    0A.3
09F9:  BCF    03.5
09FA:  CALL   60D
09FB:  BSF    0A.3
09FC:  MOVF   78,W
09FD:  BSF    03.5
09FE:  MOVWF  21
09FF:  BCF    03.5
0A00:  MOVF   39,W
0A01:  BSF    03.5
0A02:  MOVWF  23
0A03:  BCF    0A.3
0A04:  BCF    03.5
0A05:  CALL   60D
0A06:  BSF    0A.3
0A07:  MOVF   78,W
0A08:  BSF    03.5
0A09:  MOVWF  22
0A0A:  MOVLW  00
0A0B:  BCF    03.5
0A0C:  BTFSC  2C.5
0A0D:  MOVLW  01
0A0E:  BSF    03.5
0A0F:  MOVWF  23
0A10:  MOVLW  00
0A11:  BCF    03.5
0A12:  BTFSC  2C.4
0A13:  MOVLW  01
0A14:  BSF    03.5
0A15:  MOVWF  24
0A16:  MOVLW  00
0A17:  BCF    03.5
0A18:  BTFSC  2C.3
0A19:  MOVLW  01
0A1A:  BSF    03.5
0A1B:  MOVWF  25
0A1C:  MOVLW  04
0A1D:  MOVWF  27
0A1E:  MOVLW  01
0A1F:  MOVWF  28
0A20:  MOVF   20,W
0A21:  MOVWF  29
0A22:  MOVF   21,W
0A23:  MOVWF  2A
0A24:  MOVF   22,W
0A25:  MOVWF  2B
0A26:  MOVF   23,W
0A27:  MOVWF  2C
0A28:  MOVF   24,W
0A29:  MOVWF  2D
0A2A:  MOVF   25,W
0A2B:  MOVWF  2E
0A2C:  BCF    0A.3
0A2D:  BCF    03.5
0A2E:  CALL   639
0A2F:  BSF    0A.3
0A30:  RETURN
.................... }
.................... void phim_chon_mode_alarm(){
....................    if(tick_btn(2, bt3)){
*
1659:  MOVLW  02
165A:  MOVWF  76
165B:  MOVLW  33
165C:  MOVWF  7B
165D:  BCF    0A.4
165E:  CALL   7D7
165F:  BSF    0A.4
1660:  MOVF   78,F
1661:  BTFSC  03.2
1662:  GOTO   673
....................       if(gt_mod < 3) gt_mod++;
1663:  BTFSC  35.7
1664:  GOTO   669
1665:  MOVF   35,W
1666:  SUBLW  02
1667:  BTFSS  03.0
1668:  GOTO   66B
1669:  INCF   35,F
166A:  GOTO   66D
....................       else{
....................          gt_mod = 0;
166B:  CLRF   35
....................          countLevel = 0;
166C:  CLRF   3A
....................       }
....................       tg_chinh = 0;
166D:  CLRF   36
....................       giai_ma_gpg_alarm_lcd();
166E:  BCF    0A.4
166F:  BSF    0A.3
1670:  CALL   1EA
1671:  BSF    0A.4
1672:  BCF    0A.3
....................    }
.................... }
.................... void tang_giay_eat(){
....................    if(eat_ss == 0x59) eat_ss = 0x00;
*
1689:  MOVF   39,W
168A:  SUBLW  59
168B:  BTFSS  03.2
168C:  GOTO   68F
168D:  CLRF   39
168E:  GOTO   699
....................    else eat_ss = tang_or_giam_bcd(eat_ss, tang);
168F:  MOVF   39,W
1690:  MOVWF  76
1691:  CLRF   7B
1692:  BCF    0A.4
1693:  BSF    0A.3
1694:  CALL   16C
1695:  BSF    0A.4
1696:  BCF    0A.3
1697:  MOVF   78,W
1698:  MOVWF  39
.................... }
.................... void tang_phut_eat(){
....................    if(eat_pp == 0x59) eat_pp = 0x00;
*
169A:  MOVF   38,W
169B:  SUBLW  59
169C:  BTFSS  03.2
169D:  GOTO   6A0
169E:  CLRF   38
169F:  GOTO   6AA
....................    else eat_pp = tang_or_giam_bcd(eat_pp, tang);
16A0:  MOVF   38,W
16A1:  MOVWF  76
16A2:  CLRF   7B
16A3:  BCF    0A.4
16A4:  BSF    0A.3
16A5:  CALL   16C
16A6:  BSF    0A.4
16A7:  BCF    0A.3
16A8:  MOVF   78,W
16A9:  MOVWF  38
.................... }
.................... void tang_gio_eat(){
....................    if(eat_hh == 0x23) eat_hh = 0x00;
*
16AB:  MOVF   37,W
16AC:  SUBLW  23
16AD:  BTFSS  03.2
16AE:  GOTO   6B1
16AF:  CLRF   37
16B0:  GOTO   6BB
....................    else eat_hh = tang_or_giam_bcd(eat_hh, tang);
16B1:  MOVF   37,W
16B2:  MOVWF  76
16B3:  CLRF   7B
16B4:  BCF    0A.4
16B5:  BSF    0A.3
16B6:  CALL   16C
16B7:  BSF    0A.4
16B8:  BCF    0A.3
16B9:  MOVF   78,W
16BA:  MOVWF  37
.................... }
.................... void chinh_tang_gpg_eat(){
....................    switch(gt_mod){
*
167E:  MOVF   35,W
167F:  XORLW  01
1680:  BTFSC  03.2
1681:  GOTO   689
1682:  XORLW  03
1683:  BTFSC  03.2
1684:  GOTO   69A
1685:  XORLW  01
1686:  BTFSC  03.2
1687:  GOTO   6AB
1688:  GOTO   6BC
....................       case 1:
....................          tang_giay_eat();
....................          break;
*
1699:  GOTO   6BD
....................       case 2:
....................          tang_phut_eat();
....................          break;
*
16AA:  GOTO   6BD
....................       case 3:
....................          tang_gio_eat();
....................          break;
*
16BB:  GOTO   6BD
....................       default: break;
16BC:  GOTO   6BD
....................    }
.................... }
.................... 
.................... void phim_up_eat(){
....................    if(tick_btn(1, bt1)){
*
1673:  MOVLW  01
1674:  MOVWF  76
1675:  MOVLW  31
1676:  MOVWF  7B
1677:  BCF    0A.4
1678:  CALL   7D7
1679:  BSF    0A.4
167A:  MOVF   78,F
167B:  BTFSC  03.2
167C:  GOTO   6C5
....................       tg_chinh = 0;
167D:  CLRF   36
....................       chinh_tang_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
16BD:  BSF    2C.3
16BE:  BSF    2C.4
16BF:  BSF    2C.5
....................       giai_ma_gpg_alarm_lcd();
16C0:  BCF    0A.4
16C1:  BSF    0A.3
16C2:  CALL   1EA
16C3:  BSF    0A.4
16C4:  BCF    0A.3
....................    }
.................... }
.................... 
.................... void giam_giay_eat(){
....................    if(eat_ss == 0) eat_ss = 0x59;
*
16DB:  MOVF   39,F
16DC:  BTFSS  03.2
16DD:  GOTO   6E1
16DE:  MOVLW  59
16DF:  MOVWF  39
16E0:  GOTO   6EC
....................    else eat_ss = tang_or_giam_bcd(eat_ss,giam);
16E1:  MOVF   39,W
16E2:  MOVWF  76
16E3:  MOVLW  01
16E4:  MOVWF  7B
16E5:  BCF    0A.4
16E6:  BSF    0A.3
16E7:  CALL   16C
16E8:  BSF    0A.4
16E9:  BCF    0A.3
16EA:  MOVF   78,W
16EB:  MOVWF  39
.................... }
.................... void giam_phut_eat(){
....................    if(eat_pp == 0) eat_pp = 0x59;
*
16ED:  MOVF   38,F
16EE:  BTFSS  03.2
16EF:  GOTO   6F3
16F0:  MOVLW  59
16F1:  MOVWF  38
16F2:  GOTO   6FE
....................    else eat_pp = tang_or_giam_bcd(eat_pp,giam);
16F3:  MOVF   38,W
16F4:  MOVWF  76
16F5:  MOVLW  01
16F6:  MOVWF  7B
16F7:  BCF    0A.4
16F8:  BSF    0A.3
16F9:  CALL   16C
16FA:  BSF    0A.4
16FB:  BCF    0A.3
16FC:  MOVF   78,W
16FD:  MOVWF  38
.................... }
.................... void giam_gio_eat(){
....................    if(eat_hh == 0) eat_hh = 0x23;
*
16FF:  MOVF   37,F
1700:  BTFSS  03.2
1701:  GOTO   705
1702:  MOVLW  23
1703:  MOVWF  37
1704:  GOTO   710
....................    else eat_hh = tang_or_giam_bcd(eat_hh,giam);
1705:  MOVF   37,W
1706:  MOVWF  76
1707:  MOVLW  01
1708:  MOVWF  7B
1709:  BCF    0A.4
170A:  BSF    0A.3
170B:  CALL   16C
170C:  BSF    0A.4
170D:  BCF    0A.3
170E:  MOVF   78,W
170F:  MOVWF  37
.................... }
.................... void chinh_giam_gpg_eat(){
....................    switch(gt_mod){
*
16D0:  MOVF   35,W
16D1:  XORLW  01
16D2:  BTFSC  03.2
16D3:  GOTO   6DB
16D4:  XORLW  03
16D5:  BTFSC  03.2
16D6:  GOTO   6ED
16D7:  XORLW  01
16D8:  BTFSC  03.2
16D9:  GOTO   6FF
16DA:  GOTO   711
....................       case 1:
....................          giam_giay_eat();
....................          break;
*
16EC:  GOTO   712
....................       case 2:
....................          giam_phut_eat();
....................          break;
*
16FE:  GOTO   712
....................       case 3:
....................          giam_gio_eat();
....................          break;
*
1710:  GOTO   712
....................       default: break;
1711:  GOTO   712
....................    }
.................... }
.................... void phim_dw_eat(){
....................    if(tick_btn(1, bt2)){
*
16C5:  MOVLW  01
16C6:  MOVWF  76
16C7:  MOVLW  32
16C8:  MOVWF  7B
16C9:  BCF    0A.4
16CA:  CALL   7D7
16CB:  BSF    0A.4
16CC:  MOVF   78,F
16CD:  BTFSC  03.2
16CE:  GOTO   71A
....................       tg_chinh = 0;
16CF:  CLRF   36
....................       chinh_giam_gpg_eat();
....................       e_11 = true; e_22 = true; e_33 = true;
*
1712:  BSF    2C.3
1713:  BSF    2C.4
1714:  BSF    2C.5
....................       giai_ma_gpg_alarm_lcd();
1715:  BCF    0A.4
1716:  BSF    0A.3
1717:  CALL   1EA
1718:  BSF    0A.4
1719:  BCF    0A.3
....................    }
.................... }
.................... void log_mode_alarm(){
....................    lcd_setCursor(13, 1);
*
1731:  MOVLW  0D
1732:  BSF    03.5
1733:  MOVWF  35
1734:  MOVLW  01
1735:  MOVWF  36
1736:  BCF    0A.4
1737:  BCF    03.5
1738:  CALL   317
1739:  BSF    0A.4
....................    lcd_data(gt_mod + 0x30);
173A:  MOVLW  30
173B:  ADDWF  35,W
173C:  MOVWF  76
173D:  BSF    03.5
173E:  MOVWF  38
173F:  BCF    0A.4
1740:  BCF    03.5
1741:  CALL   336
1742:  BSF    0A.4
....................    if(gt_mod != 0){
1743:  MOVF   35,F
1744:  BTFSC  03.2
1745:  GOTO   76B
....................       lcd_data(tg_chinh/10 + 0x30); lcd_data(tg_chinh%10 + 0x30);
1746:  MOVF   36,W
1747:  MOVWF  7B
1748:  MOVLW  0A
1749:  MOVWF  7C
174A:  BCF    0A.4
174B:  BSF    0A.3
174C:  CALL   1C5
174D:  BSF    0A.4
174E:  BCF    0A.3
174F:  MOVLW  30
1750:  ADDWF  78,W
1751:  MOVWF  76
1752:  BSF    03.5
1753:  MOVWF  38
1754:  BCF    0A.4
1755:  BCF    03.5
1756:  CALL   336
1757:  BSF    0A.4
1758:  MOVF   36,W
1759:  MOVWF  7B
175A:  MOVLW  0A
175B:  MOVWF  7C
175C:  BCF    0A.4
175D:  BSF    0A.3
175E:  CALL   1C5
175F:  BSF    0A.4
1760:  BCF    0A.3
1761:  MOVLW  30
1762:  ADDWF  77,W
1763:  MOVWF  76
1764:  BSF    03.5
1765:  MOVWF  38
1766:  BCF    0A.4
1767:  BCF    03.5
1768:  CALL   336
1769:  BSF    0A.4
....................    }
176A:  GOTO   774
....................    else
....................       lcd_data("__");
176B:  MOVLW  E9
176C:  BSF    03.6
176D:  MOVWF  0D
176E:  MOVLW  00
176F:  MOVWF  0F
1770:  BCF    0A.4
1771:  BCF    03.6
1772:  CALL   353
1773:  BSF    0A.4
.................... }
.................... 
.................... 
.................... #include <library_control_chiller.c>
.................... void control_temperature(int8 nd_ss, int8 gh){
....................    if(nd_ss > gh){
*
111C:  MOVF   7B,W
111D:  SUBWF  7C,W
111E:  BTFSC  03.0
111F:  GOTO   123
....................    // water is hot
....................       output_bit(pinDLCold, 1);
1120:  BSF    08.6
....................       output_bit(pinDLHot,  0);
1121:  BCF    08.7
....................    }
1122:  GOTO   125
....................    else{
....................    // water is cold
....................       output_bit(pinDLCold, 0);
1123:  BCF    08.6
....................       output_bit(pinDLHot,  1);
1124:  BSF    08.7
....................    }
.................... }
.................... 
.................... void servo_degree_0(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
02FC:  CLRF   76
02FD:  MOVF   76,W
02FE:  SUBLW  31
02FF:  BTFSS  03.0
0300:  GOTO   316
....................       output_bit(pinServo, 1);
0301:  BSF    07.1
....................       Delay_us(800); // pulse of 800us
0302:  MOVLW  04
0303:  MOVWF  7B
0304:  MOVLW  C7
0305:  BSF    03.5
0306:  MOVWF  23
0307:  BCF    03.5
0308:  CALL   2EB
0309:  DECFSZ 7B,F
030A:  GOTO   304
....................       output_bit(pinServo, 0);
030B:  BCF    07.1
....................       Delay_us(19200);
030C:  MOVLW  13
030D:  MOVWF  7C
030E:  CALL   1E0
030F:  MOVLW  C8
0310:  BSF    03.5
0311:  MOVWF  23
0312:  BCF    03.5
0313:  CALL   2EB
0314:  INCF   76,F
0315:  GOTO   2FD
....................    }
0316:  RETURN
.................... }
.................... 
.................... void servo_degree_90(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
*
1164:  CLRF   7B
1165:  MOVF   7B,W
1166:  SUBLW  31
1167:  BTFSS  03.0
1168:  GOTO   18D
....................       output_bit(pinServo, 1);
1169:  BSF    07.1
....................       Delay_us(1500); // pulse of 1500us
116A:  MOVLW  01
116B:  MOVWF  7C
116C:  BCF    0A.4
116D:  CALL   1E0
116E:  BSF    0A.4
116F:  MOVLW  02
1170:  MOVWF  7C
1171:  MOVLW  F9
1172:  BSF    03.5
1173:  MOVWF  23
1174:  BCF    0A.4
1175:  BCF    03.5
1176:  CALL   2EB
1177:  BSF    0A.4
1178:  DECFSZ 7C,F
1179:  GOTO   171
....................       output_bit(pinServo, 0);
117A:  BCF    07.1
....................       Delay_us(18500);
117B:  MOVLW  12
117C:  MOVWF  7C
117D:  BCF    0A.4
117E:  CALL   1E0
117F:  BSF    0A.4
1180:  MOVLW  02
1181:  MOVWF  7C
1182:  MOVLW  F9
1183:  BSF    03.5
1184:  MOVWF  23
1185:  BCF    0A.4
1186:  BCF    03.5
1187:  CALL   2EB
1188:  BSF    0A.4
1189:  DECFSZ 7C,F
118A:  GOTO   182
118B:  INCF   7B,F
118C:  GOTO   165
....................    }
.................... }
.................... 
.................... void servo_degree_180(){
....................    unsigned int i;
....................    for(i = 0; i < 50; i++){
....................       output_bit(pinServo, 1);
....................       Delay_us(2200); // pulse of 2200us
....................       output_bit(pinServo, 0);
....................       Delay_us(17800);
....................    }
.................... }
.................... 
.................... void control_servo(){
....................    if(dec_gio_ds == dec_gio_eat && dec_phut_ds == dec_phut_eat && dec_giay_ds == dec_giay_eat){
*
1125:  MOVF   6F,W
1126:  BSF    03.5
1127:  MOVWF  23
1128:  BCF    0A.4
1129:  BCF    03.5
112A:  CALL   60D
112B:  BSF    0A.4
112C:  MOVF   78,W
112D:  MOVWF  7B
112E:  MOVF   37,W
112F:  BSF    03.5
1130:  MOVWF  23
1131:  BCF    0A.4
1132:  BCF    03.5
1133:  CALL   60D
1134:  BSF    0A.4
1135:  MOVF   78,W
1136:  SUBWF  7B,W
1137:  BTFSS  03.2
1138:  GOTO   162
1139:  MOVF   6E,W
113A:  BSF    03.5
113B:  MOVWF  23
113C:  BCF    0A.4
113D:  BCF    03.5
113E:  CALL   60D
113F:  BSF    0A.4
1140:  MOVF   78,W
1141:  MOVWF  7B
1142:  MOVF   38,W
1143:  BSF    03.5
1144:  MOVWF  23
1145:  BCF    0A.4
1146:  BCF    03.5
1147:  CALL   60D
1148:  BSF    0A.4
1149:  MOVF   78,W
114A:  SUBWF  7B,W
114B:  BTFSS  03.2
114C:  GOTO   162
114D:  MOVF   6D,W
114E:  BSF    03.5
114F:  MOVWF  23
1150:  BCF    0A.4
1151:  BCF    03.5
1152:  CALL   60D
1153:  BSF    0A.4
1154:  MOVF   78,W
1155:  MOVWF  7B
1156:  MOVF   39,W
1157:  BSF    03.5
1158:  MOVWF  23
1159:  BCF    0A.4
115A:  BCF    03.5
115B:  CALL   60D
115C:  BSF    0A.4
115D:  MOVF   78,W
115E:  SUBWF  7B,W
115F:  BTFSS  03.2
1160:  GOTO   162
....................       flag_servo = true;
1161:  BSF    2C.6
....................    }
....................    if(flag_servo){
1162:  BTFSS  2C.6
1163:  GOTO   18E
....................       servo_degree_90();
....................    }
*
118D:  GOTO   191
....................    else{
....................       servo_degree_0();
118E:  BCF    0A.4
118F:  CALL   2FC
1190:  BSF    0A.4
....................    }
.................... }
.................... 
.................... 
.................... #include <library_menu.c>
.................... 
.................... void menu(){
....................    if (push_btn(false,bt0)) countLevel++;
*
1075:  CLRF   76
1076:  MOVLW  30
1077:  MOVWF  7B
*
10AF:  MOVF   78,F
10B0:  BTFSC  03.2
10B1:  GOTO   0B3
10B2:  INCF   3A,F
.................... 
....................    if (countLevel >= maxLevel) countLevel = 0;
10B3:  MOVF   3A,W
10B4:  SUBLW  05
10B5:  BTFSC  03.0
10B6:  GOTO   0B8
10B7:  CLRF   3A
....................    
....................    if(countLevel != countLevelRev){
10B8:  MOVF   3B,W
10B9:  SUBWF  3A,W
10BA:  BTFSC  03.2
10BB:  GOTO   0C1
....................       countLevelRev = countLevel;
10BC:  MOVF   3A,W
10BD:  MOVWF  3B
....................       lcd_clear();
10BE:  BCF    0A.4
10BF:  CALL   26D
10C0:  BSF    0A.4
....................    }
....................    
....................    switch(countLevel){
10C1:  MOVF   3A,W
10C2:  BTFSC  03.2
10C3:  GOTO   0D1
10C4:  XORLW  01
10C5:  BTFSC  03.2
10C6:  GOTO   30C
10C7:  XORLW  03
10C8:  BTFSC  03.2
10C9:  GOTO   373
10CA:  XORLW  01
10CB:  BTFSC  03.2
10CC:  GOTO   63C
10CD:  XORLW  07
10CE:  BTFSC  03.2
10CF:  GOTO   775
10D0:  GOTO   7AB
....................       case 0:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
10D1:  MOVLW  08
10D2:  MOVWF  76
10D3:  BCF    0A.4
10D4:  CALL   176
10D5:  BSF    0A.4
.................... 
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
10D6:  BCF    0A.4
10D7:  CALL   534
10D8:  BSF    0A.4
.................... 
.................... //! display info rtc and temperature for user
....................          lcd_dis_xx_yy_zz(4,0,dec_gio_ds,dec_phut_ds,dec_giay_ds,1,1,1);
10D9:  MOVF   6F,W
10DA:  BSF    03.5
10DB:  MOVWF  23
10DC:  BCF    0A.4
10DD:  BCF    03.5
10DE:  CALL   60D
10DF:  BSF    0A.4
10E0:  MOVF   78,W
10E1:  MOVWF  7B
10E2:  MOVF   6E,W
10E3:  BSF    03.5
10E4:  MOVWF  23
10E5:  BCF    0A.4
10E6:  BCF    03.5
10E7:  CALL   60D
10E8:  BSF    0A.4
10E9:  MOVF   78,W
10EA:  MOVWF  7C
10EB:  MOVF   6D,W
10EC:  BSF    03.5
10ED:  MOVWF  23
10EE:  BCF    0A.4
10EF:  BCF    03.5
10F0:  CALL   60D
10F1:  BSF    0A.4
10F2:  MOVF   78,W
10F3:  MOVWF  7D
10F4:  MOVLW  04
10F5:  BSF    03.5
10F6:  MOVWF  27
10F7:  CLRF   28
10F8:  MOVF   7B,W
10F9:  MOVWF  29
10FA:  MOVF   7C,W
10FB:  MOVWF  2A
10FC:  MOVF   78,W
10FD:  MOVWF  2B
10FE:  MOVLW  01
10FF:  MOVWF  2C
1100:  MOVWF  2D
1101:  MOVWF  2E
1102:  BCF    0A.4
1103:  BCF    03.5
1104:  CALL   639
1105:  BSF    0A.4
....................          lcd_dis_temperature(2,1,dt_ng,dt_tp);
1106:  MOVLW  02
1107:  MOVWF  76
1108:  MOVLW  01
1109:  MOVWF  7B
110A:  CLRF   7D
110B:  MOVF   3F,W
110C:  MOVWF  7C
110D:  MOVF   41,W
110E:  BSF    03.5
110F:  MOVWF  21
1110:  BCF    03.5
1111:  MOVF   40,W
1112:  BSF    03.5
1113:  MOVWF  20
1114:  BCF    0A.4
1115:  BCF    03.5
1116:  CALL   714
1117:  BSF    0A.4
.................... 
.................... //! control delay and servo
....................          control_temperature(dt_ng,limitTemperature);
1118:  MOVF   3F,W
1119:  MOVWF  7B
111A:  MOVF   2D,W
111B:  MOVWF  7C
....................          control_servo();
....................          
....................          handle_uart();
....................          
....................          if(flag_10s == true){
*
1226:  BTFSS  2C.1
1227:  GOTO   30B
....................             flag_10s = false;
1228:  BCF    2C.1
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:rt:", dt_ng);
1229:  MOVLW  EB
122A:  BSF    03.6
122B:  MOVWF  0D
122C:  MOVLW  00
122D:  MOVWF  0F
122E:  BCF    0A.4
122F:  BCF    03.6
1230:  CALL   3ED
1231:  BSF    0A.4
1232:  MOVF   3F,W
1233:  MOVWF  7E
1234:  MOVLW  18
1235:  BSF    03.5
1236:  MOVWF  20
1237:  BCF    0A.4
1238:  BSF    0A.3
1239:  BCF    03.5
123A:  CALL   000
123B:  BSF    0A.4
123C:  BCF    0A.3
123D:  MOVLW  0D
123E:  BTFSS  0C.4
123F:  GOTO   23E
1240:  MOVWF  19
1241:  MOVLW  0A
1242:  BTFSS  0C.4
1243:  GOTO   242
1244:  MOVWF  19
....................             fprintf(UART_STREAM, "%s%d\r\n", "dt:lt:", limitTemperature);
1245:  MOVLW  EF
1246:  BSF    03.6
1247:  MOVWF  0D
1248:  MOVLW  00
1249:  MOVWF  0F
124A:  BCF    0A.4
124B:  BCF    03.6
124C:  CALL   3ED
124D:  BSF    0A.4
124E:  MOVF   2D,W
124F:  MOVWF  7E
1250:  MOVLW  18
1251:  BSF    03.5
1252:  MOVWF  20
1253:  BCF    0A.4
1254:  BSF    0A.3
1255:  BCF    03.5
1256:  CALL   000
1257:  BSF    0A.4
1258:  BCF    0A.3
1259:  MOVLW  0D
125A:  BTFSS  0C.4
125B:  GOTO   25A
125C:  MOVWF  19
125D:  MOVLW  0A
125E:  BTFSS  0C.4
125F:  GOTO   25E
1260:  MOVWF  19
....................             fprintf(UART_STREAM, "%s%d-%d-%d\r\n", "dt:ra:", dec_gio_eat, dec_phut_eat, dec_giay_eat);
1261:  MOVF   37,W
1262:  BSF    03.5
1263:  MOVWF  23
1264:  BCF    0A.4
1265:  BCF    03.5
1266:  CALL   60D
1267:  BSF    0A.4
1268:  MOVF   78,W
1269:  MOVWF  7B
126A:  MOVF   38,W
126B:  BSF    03.5
126C:  MOVWF  23
126D:  BCF    0A.4
126E:  BCF    03.5
126F:  CALL   60D
1270:  BSF    0A.4
1271:  MOVF   78,W
1272:  MOVWF  7C
1273:  MOVF   39,W
1274:  BSF    03.5
1275:  MOVWF  23
1276:  BCF    0A.4
1277:  BCF    03.5
1278:  CALL   60D
1279:  BSF    0A.4
127A:  MOVF   78,W
127B:  MOVWF  7D
127C:  MOVLW  F3
127D:  BSF    03.6
127E:  MOVWF  0D
127F:  MOVLW  00
1280:  MOVWF  0F
1281:  BCF    0A.4
1282:  BCF    03.6
1283:  CALL   3ED
1284:  BSF    0A.4
1285:  MOVF   7B,W
1286:  MOVWF  7E
1287:  MOVLW  18
1288:  BSF    03.5
1289:  MOVWF  20
128A:  BCF    0A.4
128B:  BSF    0A.3
128C:  BCF    03.5
128D:  CALL   000
128E:  BSF    0A.4
128F:  BCF    0A.3
1290:  MOVLW  2D
1291:  BTFSS  0C.4
1292:  GOTO   291
1293:  MOVWF  19
1294:  MOVF   7C,W
1295:  MOVWF  7E
1296:  MOVLW  18
1297:  BSF    03.5
1298:  MOVWF  20
1299:  BCF    0A.4
129A:  BSF    0A.3
129B:  BCF    03.5
129C:  CALL   000
129D:  BSF    0A.4
129E:  BCF    0A.3
129F:  MOVLW  2D
12A0:  BTFSS  0C.4
12A1:  GOTO   2A0
12A2:  MOVWF  19
12A3:  MOVF   7D,W
12A4:  MOVWF  7E
12A5:  MOVLW  18
12A6:  BSF    03.5
12A7:  MOVWF  20
12A8:  BCF    0A.4
12A9:  BSF    0A.3
12AA:  BCF    03.5
12AB:  CALL   000
12AC:  BSF    0A.4
12AD:  BCF    0A.3
12AE:  MOVLW  0D
12AF:  BTFSS  0C.4
12B0:  GOTO   2AF
12B1:  MOVWF  19
12B2:  MOVLW  0A
12B3:  BTFSS  0C.4
12B4:  GOTO   2B3
12B5:  MOVWF  19
....................             fprintf(UART_STREAM, "%s%d-%d-%d\r\n", "dt:rc:", dec_gio_ds, dec_phut_ds, dec_giay_ds);
12B6:  MOVF   6F,W
12B7:  BSF    03.5
12B8:  MOVWF  23
12B9:  BCF    0A.4
12BA:  BCF    03.5
12BB:  CALL   60D
12BC:  BSF    0A.4
12BD:  MOVF   78,W
12BE:  MOVWF  7B
12BF:  MOVF   6E,W
12C0:  BSF    03.5
12C1:  MOVWF  23
12C2:  BCF    0A.4
12C3:  BCF    03.5
12C4:  CALL   60D
12C5:  BSF    0A.4
12C6:  MOVF   78,W
12C7:  MOVWF  7C
12C8:  MOVF   6D,W
12C9:  BSF    03.5
12CA:  MOVWF  23
12CB:  BCF    0A.4
12CC:  BCF    03.5
12CD:  CALL   60D
12CE:  BSF    0A.4
12CF:  MOVF   78,W
12D0:  MOVWF  7D
12D1:  MOVLW  F7
12D2:  BSF    03.6
12D3:  MOVWF  0D
12D4:  MOVLW  00
12D5:  MOVWF  0F
12D6:  BCF    0A.4
12D7:  BCF    03.6
12D8:  CALL   3ED
12D9:  BSF    0A.4
12DA:  MOVF   7B,W
12DB:  MOVWF  7E
12DC:  MOVLW  18
12DD:  BSF    03.5
12DE:  MOVWF  20
12DF:  BCF    0A.4
12E0:  BSF    0A.3
12E1:  BCF    03.5
12E2:  CALL   000
12E3:  BSF    0A.4
12E4:  BCF    0A.3
12E5:  MOVLW  2D
12E6:  BTFSS  0C.4
12E7:  GOTO   2E6
12E8:  MOVWF  19
12E9:  MOVF   7C,W
12EA:  MOVWF  7E
12EB:  MOVLW  18
12EC:  BSF    03.5
12ED:  MOVWF  20
12EE:  BCF    0A.4
12EF:  BSF    0A.3
12F0:  BCF    03.5
12F1:  CALL   000
12F2:  BSF    0A.4
12F3:  BCF    0A.3
12F4:  MOVLW  2D
12F5:  BTFSS  0C.4
12F6:  GOTO   2F5
12F7:  MOVWF  19
12F8:  MOVF   7D,W
12F9:  MOVWF  7E
12FA:  MOVLW  18
12FB:  BSF    03.5
12FC:  MOVWF  20
12FD:  BCF    0A.4
12FE:  BSF    0A.3
12FF:  BCF    03.5
1300:  CALL   000
1301:  BSF    0A.4
1302:  BCF    0A.3
1303:  MOVLW  0D
1304:  BTFSS  0C.4
1305:  GOTO   304
1306:  MOVWF  19
1307:  MOVLW  0A
1308:  BTFSS  0C.4
1309:  GOTO   308
130A:  MOVWF  19
....................          }
....................          break;
130B:  GOTO   7D9
....................       case 1:
.................... //! function to read temperature from ds18b20 sensor
....................          ds18b20_read_temp();
130C:  BCF    0A.4
130D:  CALL   534
130E:  BSF    0A.4
.................... 
.................... //! change limit temperature
....................          limitTemperature += tick_btn(1,bt2);
130F:  MOVLW  01
1310:  MOVWF  76
1311:  MOVLW  32
1312:  MOVWF  7B
1313:  BCF    0A.4
1314:  CALL   7D7
1315:  BSF    0A.4
1316:  MOVF   78,W
1317:  ADDWF  2D,F
....................          limitTemperature -= tick_btn(1,bt1);
1318:  MOVLW  01
1319:  MOVWF  76
131A:  MOVLW  31
131B:  MOVWF  7B
131C:  BCF    0A.4
131D:  CALL   7D7
131E:  BSF    0A.4
131F:  MOVF   78,W
1320:  SUBWF  2D,F
.................... 
.................... //! display info temperature limit and sensor
....................          lcd_dis_temperature(2,0,dt_ng,dt_tp);
1321:  MOVLW  02
1322:  MOVWF  76
1323:  CLRF   7B
1324:  CLRF   7D
1325:  MOVF   3F,W
1326:  MOVWF  7C
1327:  MOVF   41,W
1328:  BSF    03.5
1329:  MOVWF  21
132A:  BCF    03.5
132B:  MOVF   40,W
132C:  BSF    03.5
132D:  MOVWF  20
132E:  BCF    0A.4
132F:  BCF    03.5
1330:  CALL   714
1331:  BSF    0A.4
....................          lcd_dis_temperature_limit(2,1,limitTemperature);
1332:  MOVLW  02
1333:  MOVWF  76
1334:  MOVLW  01
1335:  MOVWF  7B
1336:  CLRF   7D
1337:  MOVF   2D,W
1338:  MOVWF  7C
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
*
1367:  MOVLW  01
1368:  MOVWF  76
1369:  MOVLW  33
136A:  MOVWF  7B
136B:  BCF    0A.4
136C:  CALL   7D7
136D:  BSF    0A.4
136E:  MOVF   78,F
136F:  BTFSC  03.2
1370:  GOTO   372
1371:  CLRF   3A
....................          
....................          break;
1372:  GOTO   7D9
....................       case 2:
.................... //! function to read time rtc from ds1307 sensor
....................          ds1307_read_time(8);
1373:  MOVLW  08
1374:  MOVWF  76
1375:  BCF    0A.4
1376:  CALL   176
1377:  BSF    0A.4
.................... 
.................... //!
....................          lcd_setCursor(1,0);
1378:  MOVLW  01
1379:  BSF    03.5
137A:  MOVWF  35
137B:  CLRF   36
137C:  BCF    0A.4
137D:  BCF    03.5
137E:  CALL   317
137F:  BSF    0A.4
....................          lcd_data("cai dat dong ho");
1380:  MOVLW  FB
1381:  BSF    03.6
1382:  MOVWF  0D
1383:  MOVLW  00
1384:  MOVWF  0F
1385:  BCF    0A.4
1386:  BCF    03.6
1387:  CALL   353
1388:  BSF    0A.4
....................          if(bdn < 5){
1389:  MOVF   33,W
138A:  SUBLW  04
138B:  BTFSS  03.0
138C:  GOTO   59F
....................             if(gt_mod != 0) xu_ly_choptat();
138D:  MOVF   35,F
138E:  BTFSC  03.2
138F:  GOTO   395
1390:  BCF    0A.4
1391:  BSF    0A.3
1392:  CALL   06B
1393:  BSF    0A.4
1394:  BCF    0A.3
....................             phim_chon_hthi_mode();
....................             phim_up();
....................             phim_dw();
....................          }
*
159E:  GOTO   5B7
....................          else if(bdn >= 10){
159F:  MOVF   33,W
15A0:  SUBLW  09
15A1:  BTFSC  03.0
15A2:  GOTO   5B7
....................             bdn = 0;
15A3:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
15A4:  BTFSC  36.7
15A5:  GOTO   5AA
15A6:  MOVF   36,W
15A7:  SUBLW  13
15A8:  BTFSS  03.0
15A9:  GOTO   5AC
15AA:  INCF   36,F
15AB:  GOTO   5B1
....................             else{
....................                gt_mod = 0; tt_ht = 0;
15AC:  CLRF   35
15AD:  CLRF   34
....................                e_11 = true; e_22 = true; e_33 = true;
15AE:  BSF    2C.3
15AF:  BSF    2C.4
15B0:  BSF    2C.5
....................             }
....................             if(giay_tam!=giay_ds){
15B1:  MOVF   6D,W
15B2:  SUBWF  32,W
15B3:  BTFSC  03.2
15B4:  GOTO   5B7
....................                giay_tam = giay_ds;
15B5:  MOVF   6D,W
15B6:  MOVWF  32
....................             }
....................          }
....................          giai_ma_gpg_ntn_thu_lcd();
15B7:  BCF    0A.4
15B8:  BSF    0A.3
15B9:  CALL   145
15BA:  BSF    0A.4
15BB:  BCF    0A.3
....................          log_mode();
....................          break;
*
163B:  GOTO   7D9
....................       case 3:
....................          lcd_setCursor(1,0);
163C:  MOVLW  01
163D:  BSF    03.5
163E:  MOVWF  35
163F:  CLRF   36
1640:  BCF    0A.4
1641:  BCF    03.5
1642:  CALL   317
1643:  BSF    0A.4
....................          lcd_data("t/g cho ca an");
1644:  MOVLW  03
1645:  BSF    03.6
1646:  MOVWF  0D
1647:  MOVLW  01
1648:  MOVWF  0F
1649:  BCF    0A.4
164A:  BCF    03.6
164B:  CALL   353
164C:  BSF    0A.4
....................          if(bdn < 5){
164D:  MOVF   33,W
164E:  SUBLW  04
164F:  BTFSS  03.0
1650:  GOTO   71B
....................             if(gt_mod != 0) xu_ly_choptat();
1651:  MOVF   35,F
1652:  BTFSC  03.2
1653:  GOTO   659
1654:  BCF    0A.4
1655:  BSF    0A.3
1656:  CALL   06B
1657:  BSF    0A.4
1658:  BCF    0A.3
....................             phim_chon_mode_alarm();
....................             phim_up_eat();
....................             phim_dw_eat();
....................          }
*
171A:  GOTO   72C
....................          else if(bdn >= 10){
171B:  MOVF   33,W
171C:  SUBLW  09
171D:  BTFSC  03.0
171E:  GOTO   72C
....................             bdn = 0;
171F:  CLRF   33
....................             if(tg_chinh < 20) tg_chinh++;
1720:  BTFSC  36.7
1721:  GOTO   726
1722:  MOVF   36,W
1723:  SUBLW  13
1724:  BTFSS  03.0
1725:  GOTO   728
1726:  INCF   36,F
1727:  GOTO   72C
....................             else{
....................                gt_mod = 0;
1728:  CLRF   35
....................                e_11 = true; e_22 = true; e_33 = true;
1729:  BSF    2C.3
172A:  BSF    2C.4
172B:  BSF    2C.5
....................             }
....................          }
....................          giai_ma_gpg_alarm_lcd();
172C:  BCF    0A.4
172D:  BSF    0A.3
172E:  CALL   1EA
172F:  BSF    0A.4
1730:  BCF    0A.3
....................          log_mode_alarm();
....................          break;
*
1774:  GOTO   7D9
....................       case 4:
....................          lcd_setCursor(1,0);
1775:  MOVLW  01
1776:  BSF    03.5
1777:  MOVWF  35
1778:  CLRF   36
1779:  BCF    0A.4
177A:  BCF    03.5
177B:  CALL   317
177C:  BSF    0A.4
....................          lcd_data("check com esp");
177D:  MOVLW  0A
177E:  BSF    03.6
177F:  MOVWF  0D
1780:  MOVLW  01
1781:  MOVWF  0F
1782:  BCF    0A.4
1783:  BCF    03.6
1784:  CALL   353
1785:  BSF    0A.4
....................          lcd_setCursor(1,1);
1786:  MOVLW  01
1787:  BSF    03.5
1788:  MOVWF  35
1789:  MOVWF  36
178A:  BCF    0A.4
178B:  BCF    03.5
178C:  CALL   317
178D:  BSF    0A.4
....................          lcd_data(indexComplete + 0x30);
178E:  MOVLW  30
178F:  ADDWF  58,W
1790:  MOVWF  7B
1791:  BSF    03.5
1792:  MOVWF  38
1793:  BCF    0A.4
1794:  BCF    03.5
1795:  CALL   336
1796:  BSF    0A.4
....................          if (stringComplete) {
1797:  MOVF   57,F
1798:  BTFSC  03.2
1799:  GOTO   79F
....................             stringComplete = 0;
179A:  CLRF   57
....................             index = 0;
179B:  CLRF   56
....................             lcd_clear();
179C:  BCF    0A.4
179D:  CALL   26D
179E:  BSF    0A.4
.................... 
.................... //!            if(!strncmp(ledon, receivedString, 2)){
.................... //!               output_bit(ledTest,1);
.................... //!            }
.................... //!            else{
.................... //!               output_bit(ledTest,0);
.................... //!            }
....................          }
....................          if(tick_btn(1,bt3)) countLevel = 0;
179F:  MOVLW  01
17A0:  MOVWF  76
17A1:  MOVLW  33
17A2:  MOVWF  7B
17A3:  BCF    0A.4
17A4:  CALL   7D7
17A5:  BSF    0A.4
17A6:  MOVF   78,F
17A7:  BTFSC  03.2
17A8:  GOTO   7AA
17A9:  CLRF   3A
....................          break;
17AA:  GOTO   7D9
....................       default:
....................          lcd_setCursor(2,0);
17AB:  MOVLW  02
17AC:  BSF    03.5
17AD:  MOVWF  35
17AE:  CLRF   36
17AF:  BCF    0A.4
17B0:  BCF    03.5
17B1:  CALL   317
17B2:  BSF    0A.4
....................          lcd_data("Information");
17B3:  MOVLW  11
17B4:  BSF    03.6
17B5:  MOVWF  0D
17B6:  MOVLW  01
17B7:  MOVWF  0F
17B8:  BCF    0A.4
17B9:  BCF    03.6
17BA:  CALL   353
17BB:  BSF    0A.4
....................          lcd_setCursor(0,1);
17BC:  BSF    03.5
17BD:  CLRF   35
17BE:  MOVLW  01
17BF:  MOVWF  36
17C0:  BCF    0A.4
17C1:  BCF    03.5
17C2:  CALL   317
17C3:  BSF    0A.4
....................          lcd_data("Version: V1.0.0");
17C4:  MOVLW  17
17C5:  BSF    03.6
17C6:  MOVWF  0D
17C7:  MOVLW  01
17C8:  MOVWF  0F
17C9:  BCF    0A.4
17CA:  BCF    03.6
17CB:  CALL   353
17CC:  BSF    0A.4
.................... 
.................... //! when button 3 is true --> return menu 0
....................          if(tick_btn(1,bt3)) countLevel = 0;
17CD:  MOVLW  01
17CE:  MOVWF  76
17CF:  MOVLW  33
17D0:  MOVWF  7B
17D1:  BCF    0A.4
17D2:  CALL   7D7
17D3:  BSF    0A.4
17D4:  MOVF   78,F
17D5:  BTFSC  03.2
17D6:  GOTO   7D8
17D7:  CLRF   3A
....................          break;
17D8:  GOTO   7D9
....................    }
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void loop(){
.................... //! function to access for change limit temperature, change time for time rtc, change time clock for eat fish, check com with esp, log version sys
....................    menu();
.................... }
.................... 
.................... void main(){
*
1000:  MOVF   03,W
1001:  ANDLW  1F
1002:  MOVWF  03
1003:  MOVLW  FF
1004:  MOVWF  2B
1005:  BSF    2B.3
1006:  MOVF   2B,W
1007:  BSF    03.5
1008:  MOVWF  07
1009:  BCF    03.5
100A:  BSF    2B.4
100B:  MOVF   2B,W
100C:  BSF    03.5
100D:  MOVWF  07
100E:  MOVLW  31
100F:  MOVWF  13
1010:  MOVLW  28
1011:  BCF    03.5
1012:  MOVWF  14
1013:  BSF    03.5
1014:  BSF    14.7
1015:  BCF    14.6
1016:  MOVLW  81
1017:  MOVWF  19
1018:  MOVLW  A6
1019:  MOVWF  18
101A:  MOVLW  90
101B:  BCF    03.5
101C:  MOVWF  18
101D:  BCF    2C.0
101E:  BCF    2C.1
101F:  BCF    2C.2
1020:  MOVLW  19
1021:  MOVWF  2D
1022:  CLRF   34
1023:  CLRF   35
1024:  CLRF   36
1025:  CLRF   3A
1026:  CLRF   3B
1027:  CLRF   3C
1028:  CLRF   56
1029:  CLRF   57
102A:  CLRF   58
102B:  CLRF   5A
102C:  CLRF   59
102D:  CLRF   5B
102E:  CLRF   5C
102F:  BSF    03.5
1030:  BSF    1F.0
1031:  BSF    1F.1
1032:  BSF    1F.2
1033:  BCF    1F.3
1034:  MOVLW  07
1035:  MOVWF  1C
1036:  BCF    03.7
.................... 
.................... //! setup enviroments
....................    setup_initialize();
*
105D:  BCF    0A.4
105E:  GOTO   12B
105F:  BSF    0A.4
....................    
.................... //! setup ds1307 rtc
....................    ds1307_setup();
1060:  BCF    0A.4
1061:  GOTO   1A4
1062:  BSF    0A.4
.................... 
.................... //! setup lcd display
....................    lcd_setup();
1063:  BCF    0A.4
1064:  GOTO   276
1065:  BSF    0A.4
.................... 
.................... //! setup servo initialize is 0 degree
....................    servo_degree_0();
1066:  BCF    0A.4
1067:  CALL   2FC
1068:  BSF    0A.4
.................... 
.................... //! display info include: name project and name university
....................    log_lcd_initialize();
1069:  BCF    0A.4
106A:  GOTO   3C7
106B:  BSF    0A.4
....................    
....................    printf("Hello from PIC16F877A!");
106C:  MOVLW  1F
106D:  BSF    03.6
106E:  MOVWF  0D
106F:  MOVLW  01
1070:  MOVWF  0F
1071:  BCF    0A.4
1072:  BCF    03.6
1073:  CALL   3ED
1074:  BSF    0A.4
....................    
....................    while(true){
.................... //! loop function is function suport in process of system
....................       loop();
*
17D9:  GOTO   075
....................    }
.................... }
17DA:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
